<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>双周赛100 T1：把钱分给最多的儿童</title>
      <link href="/2023/07/07/shuang-zhou-sai-100-t1-ba-qian-fen-gei-zui-duo-de-er-tong/"/>
      <url>/2023/07/07/shuang-zhou-sai-100-t1-ba-qian-fen-gei-zui-duo-de-er-tong/</url>
      
        <content type="html"><![CDATA[<h3 id="双周赛100T1：将钱分给最多的儿童"><a href="#双周赛100T1：将钱分给最多的儿童" class="headerlink" title="双周赛100T1：将钱分给最多的儿童"></a>双周赛100T1：将钱分给最多的儿童</h3><h3 id="1-题目说明"><a href="#1-题目说明" class="headerlink" title="1. 题目说明"></a>1. 题目说明</h3><p>​给你一个整数 <code>money</code> ，表示你总共有的钱数（单位为美元）和另一个整数 <code>children</code> ，表示你要将钱分配给多少个儿童。</p><p>​你需要按照如下规则分配：</p><ul><li><p>所有的钱都必须被分配。</p></li><li><p>每个儿童至少获得 <code>1</code> 美元。</p></li><li><p>没有人获得 <code>4</code> 美元。</p><p>请你按照上述规则分配金钱，并返回 <strong>最多</strong> 有多少个儿童获得 <strong>恰好</strong> <code>8</code> 美元。如果没有任何分配方案，返回 <code>-1</code>.</p></li></ul><hr><ul><li><p><strong>示例</strong>：</p></li><li><pre><code>输入：money = 20, children = 3输出：1解释：最多获得 8 美元的儿童数为 1 。一种分配方案为：- 给第一个儿童分配 8 美元。- 给第二个儿童分配 9 美元。- 给第三个儿童分配 3 美元。没有分配方案能让获得 8 美元的儿童数超过 1 。</code></pre></li></ul><h3 id="2-解答分析"><a href="#2-解答分析" class="headerlink" title="2. 解答分析"></a>2. 解答分析</h3><ul><li><strong>分析：</strong></li><li><ul><li>最开始一以为这类题目都是直接模拟来做，但是发现限定条件有点多，主要是不好分类。这里<code>条件2:每个儿童至少获得1美元</code>，这里需要保证的是儿童分到的钱不为<code>0</code>，至少为<code>1</code>。==换句话说就是先给每个儿童分配1美元==  //对应的是：money-children。此时如果money&lt;0，那么直接返回-1。</li><li>然后<code>目的：返回获得8美元的儿童的最大数量</code>，此时条件改为每个获得<code>7</code>美元的儿童最大个数，我们将此时的money / 7 ，让尽可能多的儿童分到<code>7</code>美元，并向下取整，并且需要同当前的儿童的个数进行对比，不能够超过儿童实际人数，返回的是<code>ans=Math.min(money/7,children);</code>并且此时的<code>money-=ans*7;//最后的钱数</code>,<code>children-=ans;//剩余的未分配的儿童人数</code>。</li><li>此时开始判定<code>条件1和条件3：每个人都必须分配，没有儿童分到了4美元</code>。<ul><li><ol><li>如果此时剩余<code>0</code>人，也就是全部儿童都分完了（钱数都是<code>8</code>）,如果money&gt;0,说明还需要再分给一个儿童，也就是<code>ans-1</code>,有一个儿童不是8。</li></ol></li><li><ol start="2"><li>如果此时剩余1人（此时此人的钱数是<code>1</code>），且<code>money=3</code>,为了避免分配<code>4</code>美元，需要的是将此时的<code>3</code>分配给一个分到<code>8</code>的儿童，此时<code>ans-1</code>;</li></ol></li><li><ol start="3"><li>其余情况全部给一个人，如果这个人分配到<code>4</code>美元，那么它可以继续分给其他人，<code>ans</code>的总数保持不变。(<strong>也就是剩余money的值无非是mod7的正整数剩余系，4，5；6就进一位了，人数向下取整的时候要+1;对应的人数也是如此，剩余2、3…人数越多越可以分配剩余钱数不到4美元</strong>)。</li></ol></li></ul></li></ul></li></ul><hr><h3 id="3-具体代码"><a href="#3-具体代码" class="headerlink" title="3. 具体代码"></a>3. 具体代码</h3><ul><li><p><strong>代码</strong>：</p></li><li><pre class="line-numbers language-Java"><code class="language-Java">class Solution{    public int distMoney(int money,int children){        money-=chilrdren;//最开始的每个人初始值要为1        if(money<0) return -1;//不满足每个儿童获得钱数至少为1的条件，返回-1、        int ans=Math.min(money/7,children);        money-=ans*7;        children-=ans;        if(children==0 && money>0          ||children==1 && money==3){            ans--;        }        return ans;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>总结：</strong> <strong>时间复杂度为O(1),未用到循环遍历</strong>；<strong>空间复杂度为：O(1)，仅使用了若干额外的变量。</strong></p></li></ul><hr><p><span style="color:lightblue;font-size:30px;">END~</span></p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/07/07/shuang-zhou-sai-100-t1-ba-qian-fen-gei-zui-duo-de-er-tong/2.jpg" alt="2" style="zoom:80%;">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Offer26：重排链表</title>
      <link href="/2023/07/07/offer26-chong-pai-lian-biao/"/>
      <url>/2023/07/07/offer26-chong-pai-lian-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="Offer26：重排链表"><a href="#Offer26：重排链表" class="headerlink" title="Offer26：重排链表"></a>Offer26：重排链表</h3><hr><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h3><ul><li><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><p><code>L0 → L1 → … → Ln-1 → Ln</code><br>请将其重新排列后变为：</p><pre class="line-numbers language-none"><code class="language-none">L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例 1:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入: head = [1,2,3,4]输出: [1,4,2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr></li></ul><h3 id="2-解答分析"><a href="#2-解答分析" class="headerlink" title="2. 解答分析"></a>2. 解答分析</h3><ul><li><p><strong>分析：</strong> 这题不难发现，最后需要输出的链表其实是<code>前半部分</code>和<code>后半部分的翻转</code>,接着再头连着头，依次进行排序输出。</p><ul><li>所以最原始的方法是需要3个不同的函数功能。<ol><li><code>reorderList()</code>函数：主函数，用于均分两半链表，并将它们进行操作。</li><li>``reverse()`函数：翻转后半部分的链表。</li><li><code>link()</code>函数：用于连接前半部分链表、后半部分链表。</li></ol></li></ul><hr></li><li><p><strong>代码：</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution{    public void recorderList(ListNode head){        ListNode dummy=new ListNode(0);        dummy.next=head;//哨兵        ListNode fast=dummy;//快指针        ListNode slow=dummy;//慢指针       while(fast!=null &amp;&amp; fast.next!=null){           slow=slow.next;           fast=fast.next.next;       }                ListNode temp=slow.next;//中间节点的指针暂定为temp        slow.next=null;//准备连接，slow.next为空了        link(head,reverse(temp),dummy);//开始连接    }    private ListNode reverse(ListNode head){//反转链表，注意指针的指向位置        ListNode prev=null;        ListNode cur=head;        while(cur!=null){            ListNode next=cur.next;            cur.next=prev;            prev=cur;            cur=next;        }        return prev;    }    private void link(ListNode node1,ListNode node2,ListNode head){//借助原链表的头结点head（在本题函数中指的是哨兵节点dummy）,按照题目要求连接前后两部分，新链表的头节点为prev        ListNode prev=head;        while(node1!=null &amp;&amp; node2!=null){            ListNode temp=node1.next;//当前node1节点的下一个位置为temp                       prev.next=node1;//prev指针指向node1部分第一个节点            node1.next=node2;//node1后面连的是反转后node2的第一个            prev=node2;//prev开始下一次连接                        node1=temp;//node1后移            node2=node2.next;//node2后移        }        if(node1!=null){            prev.next=node1;//这一个if是用来判断前半部分链表必须比后半部分多，当node1无法匹配连接node2时，直接连接返回node1的节点值。        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr></li></ul><h3 id="3-思考总结"><a href="#3-思考总结" class="headerlink" title="3. 思考总结"></a>3. 思考总结</h3><ul><li><p><strong>思考：</strong> 其实代码不用写三个函数，用在一个函数内部即可，不需要来回调用，实现<code>折半翻转再重连</code>即可。代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution {    public void reorderList(ListNode head) {        ListNode f = head, s = head;        while (f.next != null &amp;&amp; f.next.next != null) {            s = s.next;//慢指针找到中间的节点            f = f.next.next;//快指针直接到末尾节点        }        ListNode t = s.next;//暂存的t节点是慢指针的下一位        f=null;//快指针此时位于最后一个节点，赋值为空        while (t != null) {//翻转            t = s.next;            s.next = f;            f = s;            s = t;        }        s = head;//这里是将后半部分翻转。此时快指针指向原链表的最后一位元素        while (s != null) {//再重新进行连接            t = s.next;//保留当前位置的下一位            s.next = f;//后半部分的最后一位            s = f;            f = t;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>END</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/07/07/offer26-chong-pai-lian-biao/1.jpg" alt="1"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指Offer（专项） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 1.两数之和</title>
      <link href="/2023/07/07/leetcode-1-liang-shu-zhi-he/"/>
      <url>/2023/07/07/leetcode-1-liang-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<h3 id="Leetcode-1-两数之和"><a href="#Leetcode-1-两数之和" class="headerlink" title="Leetcode 1.两数之和"></a>Leetcode 1.两数之和</h3><h3 id="1-题目说明"><a href="#1-题目说明" class="headerlink" title="1. 题目说明"></a>1. 题目说明</h3><ul><li><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><hr><h3 id="2-解答分析"><a href="#2-解答分析" class="headerlink" title="2. 解答分析"></a>2. 解答分析</h3><ul><li><p>本题有好多种解法，这里选择两种常见的解法，一种是直接上循环，不断遍历数组；另外一种是利用哈希表，返回对应表的下标（利用<code>key</code> 和<code>value</code>）</p><ul><li><h5 id="方法1：利用遍历模拟"><a href="#方法1：利用遍历模拟" class="headerlink" title="方法1：利用遍历模拟"></a><strong>方法1：利用遍历模拟</strong></h5><ul><li>本题要求的是返回两个数字和为<code>target</code>的数组元素的下标，这里可以直接交换遍历，比如最简单的for循环，我们会把两个指针所指向的值之和，依次比较，最后返回数组元素的下标（构建新的数组）</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution{    public int[] twoSum(int []nums,int target){        int j=1;        int i=0;        int maxLen=nums.length-1;        while(nums[i]+nums[j]!=target){            if(j==maxLen)}{            i++;            j=i;        }        j++:        }    return new int[]{i,j};    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>时间复杂度：O(n^2^)</strong>,一个是i，另外一个是j的循环遍历，至少需要<strong>n(n-1)<strong>的步骤；</strong>空间复杂度为O(1)</strong></li></ul><hr></li><li><h5 id="方法2：Hash表"><a href="#方法2：Hash表" class="headerlink" title="方法2：Hash表"></a><strong>方法2：Hash表</strong></h5><ul><li>Hash表是一种数据结构关系，利用==键(key)==和==值(value)==的<code>一一对应</code>的关系，生成map。map目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）</li><li>在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素</li><li>本题的map我们这样定义：<code>key</code>为数组中的num[i]值，对应的<code>value</code>为 ：下标元素i；</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution{    public int[] twoSum(int[] nums,int target){        int[]res=new int[2];//首先生成最后需要返回的数组，保存的是数组的元素下标        if(nums==null || nums.length==0){            return res;//考虑特例        }        Map&lt;Integer,Integer&gt;map=new HashMap&lt;&gt;();//建立HashMap        for(int i=0;i&lt;nums.length;i++){            int temp=target-nums[i];//从第i个元素开始，看看当前的元素数组中是否存在可以满足条件的值            if(map.containsKey(temp)){                res[1]=i;                res[0]=map.get(temp);//这里的get返回的是满足条件的temp数组元素的下标，注意我们定义Value是数组元素的下标，对应的Key是数组元素的值                break;//跳出循环            }            map.put(nums[i],i);//如果没有找到匹配的对，对于大的循环而言，只需要在HashMap中添加对应的nums值和下标即可，为后续的元素查找匹配提供map数据资源。        }        return res;//返回需要的元素数组下标的新数组    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>时间复杂度：O(n)<strong>，利用HashMap的数据结构大大提高了查找的效率，就相当于是额外开辟内存空间进行数组元素的值、下标的匹配关系映射，通过牺牲空间复杂度换取时间、效率的提高，</strong>空间复杂度为：O(n),（相当于为每个元素都开辟了n-1的空间）。</strong></li></ul></li></ul></li></ul><hr><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>​这道题很经典，其实还有很多其他的解法，这里由于篇幅就不一一介绍了。对于不同的数据结构和算法而言，我们实现的目标、途径都是不同，同样，时间和空间的各自复杂度的考虑也存在差异，多加练习，多多增加对于每道题目的不同思考方式，继续加油！</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode刷题 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>First_In</title>
      <link href="/2023/07/05/first-in/"/>
      <url>/2023/07/05/first-in/</url>
      
        <content type="html"><![CDATA[<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><ol><li>第一篇博客简单测试实现的功能，后续会继续优化网页的显示</li><li>得抓紧时间学习新知识，争取找点找到实习工作</li><li>一切都拼尽全力，一切都顺其自然，让自己快乐快乐这才叫做意义</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/05/hello-world/"/>
      <url>/2023/07/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
