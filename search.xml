<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>字节1015秋招笔试</title>
      <link href="/2023/10/15/zi-jie-1015-qiu-zhao-bi-shi/"/>
      <url>/2023/10/15/zi-jie-1015-qiu-zhao-bi-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="%E5%AD%97%E8%8A%821015%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98" tabindex="-1">字节1015笔试真题</h3><blockquote><p>好久都没更新秋招公司得笔试真题了，搞其他技术栈方面比较多。今天来看看字节大厂的题目，难度适中，没有特别绕的题目，但是发现很多题目，并没有现成的模板可以套，需要自己总结算法的思想加以应用。</p></blockquote><p>​</p><h3 id="1015.t1" tabindex="-1">1015.T1</h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h4><p>小红有一个长度为n的01字符串，小红想知道最长的美丽连续子串是什么，输出它的长度。如果一个字符串的长度是偶数，且前一半全是0且后一半全是1或者前一半全是1且后一半全是0，那么这个字符串就是美丽串。</p><p>如<code>0011</code>，<code>111000</code>都是美丽串。</p><p><strong>输入描述：</strong></p><p>一行一个长度为n的01字符串。</p><p>​</p><p><strong>输出描述：</strong></p><p>输出一个整数表示答案。</p><p><strong>示例1：</strong></p><pre class="line-numbers language-none"><code class="language-none">// 输入：000001111011011// 输出：8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><h4 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h4><ul><li><p>题目中存在两个比较重要的条件，<strong>一个是长度为偶数</strong>，<strong>一个是五五开含01</strong>。</p></li><li><p>对于这类的题目，我们可以找到最大的连续的<code>0</code>或<code>1</code>的个数，取相邻的两个数目的最小值，再在全体字符串中找到<code>ans</code>取最大值即可。</p><p>​</p></li></ul><h4 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3. 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class title1 {    public static void main(String[] args){        Scanner in=new Scanner(System.in);        String s= in.next();        int n=s.length();        int ans=0;        int prev=0;        for(int i=0;i&lt;n;i++){            int j=i;            while(j&lt;n &amp;&amp; s.charAt(j)==s.charAt(i)){                ++j;            }            int cur=Math.min(prev,j-i);//找到较小的连续字符串            ans=Math.max(ans,cur);            prev=j-i; // 更新前一次出现字符数量            i=j-1;  // 将 i 赋值为 j-1，跳过上一次出现的连续字符，开始统计下一段连续字符。        }        System.out.println(ans*2);//返回最大的连续0或1的长度的两倍，由于cur取的是较小的值，所以较大的那个一定满足条件。    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq></strong>。(最坏的情况，所有的字符都是相等的)</p><blockquote><ul><li>首先，读入输入数据的时间复杂度为 <em>O</em>(1)。</li><li>接着，循环遍历输入字符串 <code>s</code>，时间复杂度为 <em>O</em>(<em>n</em>)。在每次循环中，内部使用一个 <code>while</code> 循环寻找当前字符连续出现的最长长度。由于 <code>s</code> 的长度为 <em>n</em>，因此 <code>while</code> 循环的时间复杂度为<em>O</em>(<em>n</em>)。在寻找当前字符连续出现的最长长度之后，还需要更新 <code>ans</code> 和 <code>prev</code> 的值，这两个操作可以在常数时间内完成。因此，单次循环的总时间复杂度为 <em>O</em>(<em>n</em>)。</li><li>最后，输出结果的时间复杂度为 <em>O</em>(1)。</li></ul></blockquote></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq></strong></p><p>​</p></li></ul></li></ul><h3 id="1015.t2" tabindex="-1">1015.T2</h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E-1" tabindex="-1">1. 题目说明</h4><p>坐标轴上有<code>n</code>个人,位置分别是<code>a1,a2,... ,an</code>，有n个物资,位置分别是<code>b1,b2,...bn</code>,每个人可以拿走一个物资,每个物资只能被一个人拿走,然后走到终点<code>p</code>,每个人走一步需要花费<code>1</code>的时间,每个人拿走物资的时间为<code>0</code>，问最终每个物资都运送到终点时,每个人所花费时间总和的最小值。</p><p><strong>输入描述：</strong></p><p>一行两个整数<code>n</code>,<code>p</code>,表示人数和终点位置。一行<code>n</code>个整数<code>a1,a2,..,an,</code>表示每个人的位置。一行<code>n</code>个整数<code>b1,b2,...,bn</code>,表示每个物资的位置。</p><p>​<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1\le n \le10^5,1\le p,a_i,b_i \le10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></eq></p><p>​</p><p><strong>输出描述：</strong></p><p>输出一个整数，表示最短时间。</p><p><strong>示例1：</strong></p><pre class="line-numbers language-none"><code class="language-none">// 输入：3 31 4 32 5 6// 输出：11// 说明第一个人拿第一个物品花费时间1,走到终点花费时间1。第二个人拿第三个物品花费时间2,走到终点花费时间3第三个人拿第二个物品花费时间2,走到终点花费时间2。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><h4 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90-1" tabindex="-1">2. 解答分析</h4><ul><li><p>对于个人而言，什么时候的移动次数最小？那当然是排序后，搬运最近的物品到最后的终点即可。</p></li><li><p><strong>所以可以利用贪心算法</strong>，对人和物品的数组进行排序，从左到右依次增大，以此类推，一一对应地搬运肯定是最优的解。</p><p>​</p></li></ul><h4 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81-1" tabindex="-1">3. 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;import java.util.Arrays;import java.util.Scanner;public class title2 {        public static void main(String[] args){        Scanner in=new Scanner(System.in);        int n=in.nextInt();        int p=in.nextInt();        int[] a=new int[n];        int[] b=new int[n];//下面将人和物品的数组填满        for(int i=0;i&lt;n;i++){            a[i]=in.nextInt();        }        for(int i=0;i&lt;n;i++){            b[i]=in.nextInt();        }        //排序        Arrays.sort(a);        Arrays.sort(b);        //贪心计算答案        long ans=0;        for(int i=0;i&lt;n;i++){            ans+=Math.abs(a[i]-b[i])+Math.abs(b[i]-p);//人和货物的距离+货物到终点的距离        }        System.out.println(ans);        in.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong></p></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq></strong></p><p>​</p></li></ul></li></ul><h3 id="1015.t3" tabindex="-1">1015.T3</h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E-2" tabindex="-1">1. 题目说明</h4><p>小红是一名科学家,她正在研究一种植物的叶子。这种植物的叶子有两个特征:颜色和形状。小红一共有<strong>n片叶子</strong>需要研究,她按照顺序依次摘取。然而,小红的研究假设是,研究一片叶子时,如果发现曾经已经研究过<strong>相同颜色和形状的叶子</strong>,那么本次研究的知识减半**(向下取整)**。现在问题是,小红可以自由排序,选择研究的顺序,<strong>最多可以获得多少知识</strong>。</p><p><strong>输入描述：</strong></p><p>第一行一个正整数<code>n</code>,表示叶子的数量。</p><p>第二行<code>n</code>个正整数<code>a1, a2,...,an,</code>表示每片叶子的颜色。</p><p>第三行<code>n</code>个正整数<code>b1,b2,...,bn,</code>表示每片叶子的形状。</p><p>第四行<code>n</code>个正整数<code>c1,c2…,cn</code>,表示第一次研究可以获得知识,如果<strong>之前见过相同颜色和形状的叶子</strong>,则获得的知识是<code>ci/2</code>(向下取整)。</p><p>​                      <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator="true">;</mo><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo separator="true">;</mo><mn>1</mn><mo>≤</mo><msub><mi>c</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">1\le n \le10^5;1\le a_i,b_i \le10^9;1 \le c_i \le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></eq></p><p>​</p><p><strong>输出描述：</strong></p><p>一个整数,表示最多能获得的知识。</p><p><strong>示例1：</strong></p><pre class="line-numbers language-none"><code class="language-none">// 输入：41 2 2 21 2 3 22 3 4 5// 输出：12// 说明：按照1，4，3，2的研究顺序，获得知识2 + 5 + 4 +（3/2）= 12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><h4 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90-2" tabindex="-1">2. 解答分析</h4><ul><li><p>读题，本题需要记录最基础的两组数据：颜色和形状，<strong>再根据颜色和形状是否相同进行知识研究判断。</strong></p></li><li><p>所以我们应该采用一种可以唯一确定两者关系的映射，自然而然想到<code>HashMap</code>。直接根据<code>ai</code>和<code>bi</code>建立哈希，<code>对每一个key生成一个数组，存放ci</code>，然后直接按照题目要求<code>累加</code>即可。</p><p>​</p></li></ul><h4 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81-2" tabindex="-1">3. 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.*;public class title3 {        public static void main(String[] args){        Scanner in=new Scanner(System.in);        //首先读入输入的数据        int n=in.nextInt();        int[] color=new int[n];        int[] shape=new int[n];        int[] a=new int[n];        for(int i=0;i&lt;n;i++){            color[i]=in.nextInt();        }        for(int i=0;i&lt;n;i++){            shape[i]=in.nextInt();        }        for (int i=0;i&lt;n;i++){            a[i]=in.nextInt();        }        //计算答案        long ans=0;        HashMap&lt;Long, List&lt;Integer&gt;&gt;mp=new HashMap&lt;&gt;();        for(int i=0;i&lt;n;i++){            long key=((long)color[i]*(long)(1e9+1))+shape[i];            mp.computeIfAbsent(key,k-&gt;new ArrayList&lt;&gt;()).add(a[i]);//使用将研究知识添加到对应的列表中。        }        for(Map.Entry&lt;Long,List&lt;Integer&gt;&gt; entry:mp.entrySet()){//转化为集合            List&lt;Integer&gt; v = entry.getValue();//获取列表的值            v.sort(Collections.reverseOrder());//列表中的降序排列            long cur = v.get(0);            for (int i = 1; i &lt; v.size(); i++) {                cur += v.get(i) / 2;//遍历列表的其他元素，将其除以2并累加到 cur 中            }            ans += cur;//变量 ans 存储了小红能获得的累计的最大知识        }        // 输出答案        System.out.println(ans);        in.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*(m*logm+m))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">))</span></span></span></span></eq></strong></p><blockquote><ol><li>读入输入数据：需要遍历<code>n</code>个叶子，时间复杂度为<code>O(n)</code>。</li><li>构建哈希表：遍历<code>n</code>个叶子，在哈希表中插入或更新<code>n</code>个元素，每次插入/更新的时间复杂度为<code>O(1)</code>，因此总的时间复杂度为<code>O(n)</code>。</li><li>遍历哈希表条目：最坏情况下，哈希表中有<code>n</code>个不同的键，对于每个键，需要对其对应的列表进行排序和累积计算，假设列表的平均长度为<code>m</code>，则对每个键的操作的时间复杂度为<code>O(m*logm+m)</code>，因此遍历所有的键的时间复杂度为<code>O(n*(m*logm+m))</code>。</li><li>输出答案：时间复杂度为<code>O(1)</code>。</li></ol></blockquote></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq></strong></p><blockquote><ol><li>输入数据的存储：需要用到三个整型数组 <code>color[]</code>、<code>shape[]</code> 和 <code>a[]</code>，它们的长度均为<code>n</code>，因此空间复杂度为<code>O(n)</code>。</li><li>哈希表和列表的存储：哈希表 <code>mp</code> 存储了每种颜色和形状组合对应的研究知识列表。最坏情况下，哈希表有<code>n</code>个不同的键，每个键对应的列表长度为<code>n</code>，因此哈希表和列表的总体空间复杂度为<code>O(n^2)</code>。</li></ol></blockquote><p>​</p></li></ul></li></ul><h3 id="1015.t4" tabindex="-1">1015.T4</h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E-3" tabindex="-1">1. 题目说明</h4><p>小红准备卖<code>n</code>个西瓜,已知每个西瓜的品质为<code>ai</code>。小红可以设置一个品质标准品质<code>x</code>，不小于<code>x</code>的西瓜为优质品。小红希望设置完品质标准<code>x</code>后,当顾客从左到右依次买瓜时，每个人买到优质品的概率都不小于<code>P</code>(顾客不知道哪个瓜是优质品,只知道剩下的瓜数量以及剩下的优质品数量)。小红想知道,<code>x</code>的最大值是多少?</p><p>​</p><p><strong>输入描述：</strong></p><p>第一行输入一个正整数<code>n</code>和一个正实数<code>p</code>,含义如题意所述。</p><p>第二行输入<code>n</code>个正整数<code>ai</code>,分别代表每个瓜的品质。</p><p>​<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2000001</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo separator="true">;</mo><mn>0</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\le n \le2000001\le a_i\le10^9; 0\le q\le 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">2000001</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></eq></p><p>​</p><p><strong>输出描述：</strong></p><p>一个正整数,代表x的最大值。</p><p><strong>示例1：</strong></p><pre class="line-numbers language-none"><code class="language-none">// 输入4 0.55 3 9 6// 输出：6// 说明：当优质品标准设置为6时,第三个和第四个瓜是优质品：第一个顾客买瓜时,买到优质品的概率是0.5。第二个顾客买瓜时,买到优质品的概率是0.6666666。第三个顾客买瓜时,买到优质品的概率是1。第四个顾客买瓜时,买到优质品的概率是1。可以证明,6为品质标准设置的最大值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><h4 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90-3" tabindex="-1">2. 解答分析</h4><ul><li><p>其实只看题目并没有清楚具体含义，通过示例可以看出，顾客从左往右买瓜时，是按照次序买的，即第一个人只能买第一个瓜，那么就比较直观了；</p></li><li><p><strong>可以使用二分</strong>，枚举品质标准的设置值<code>mid</code>，再计算当品质标准为<code>x</code>时，<strong>是否满足买到优质品的概率不低于</strong><code>p</code>。</p></li><li><p>这时候需要设定哨兵<code>ok</code>用于不断计算剩余的，取到优质瓜的概率<code>cur</code>。</p><ul><li><p>一旦此时的概率<code>cur</code>比设定的<code>p</code>小的时候，说明此时的<code>good</code>值小了，<strong>需要降低阈值，增加<code>good</code>的数量</strong>。更新此时的<code>mid</code>值，将右边界左移（<strong>mid=r-1;</strong>）</p></li><li><p>一旦此时的概率<code>cur</code>比设定的<code>p</code>大的时候，说明此时的<code>good</code>值大了，<strong>需要增大阈值，减少<code>good</code>的数量</strong>。需要更新此时的<code>mid</code>值，将左边界右移（<strong>mid=l+1;</strong>）</p><p>​</p></li></ul></li></ul><h4 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81-3" tabindex="-1">3. 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class title4 {        public static void main(String[]args){        Scanner in=new Scanner(System.in);        int n=in.nextInt();        double p=in.nextDouble();        int[] a=new int[n];        for(int i=0;i&lt;n;i++){            a[i]=in.nextInt();        }        int l=1,r=1000000000;        while(l&lt;=r){//显然不可能取到相等            int mid=l+(r-l)/2;//下面开始二分查找            boolean ok=true;//设置哨兵,判断顾客买到优质瓜的概率不小于给定的p。            int good=0;            for(int i=n-1;i&gt;=0&amp;&amp;ok;i--){                if(a[i]&gt;=mid){                    good++;                }                double cur=good*1.0/(n-i);                if(cur&lt;p){                    ok=false;//此时的概率比最小设定的概率还小，说明不满足要求，此时的哨兵为错误，说明此时的good数量要增大，也就是mid的值需要向左小一些                }            }            if(ok){//符合条件，直接指向mid的下一个                l=mid+1;            }else{// 不符合要求，右边界左移                r=mid-1;            }        }        System.out.println(l);//返回符合条件的时候的左边界，l和r相等        in.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong>，其中<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></eq>为瓜的个数。</p><blockquote><ol><li>输入部分：读取n和p的时间复杂度为O(1)，读取数组a的时间复杂度为O(n)，总计O(n)。</li><li>二分查找部分：由于二分查找的次数最多为O(logN)，其中N为品质值的范围（这里为10^9），每次查找需要O(n)的遍历数组a的时间复杂度，所以总计时间复杂度为O(n*logN)。</li><li>输出部分：打印结果的时间复杂度为O(1)。</li></ol></blockquote></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong></p><blockquote><p>​整型数组a占用了O(n)的空间，用于存储每个瓜的品质。</p></blockquote><p>​</p></li></ul></li></ul><hr><center><span style="color:lightblue;font-size:30px;text-align:center;">END~</span></center><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 笔试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023大厂秋招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周赛367</title>
      <link href="/2023/10/15/zhou-sai-367/"/>
      <url>/2023/10/15/zhou-sai-367/</url>
      
        <content type="html"><![CDATA[<h3 id="%E5%91%A8%E8%B5%9B367" tabindex="-1">周赛367</h3><blockquote><p>好久没看周赛了，今天来试试做题。</p></blockquote><p>​</p><h3 id="t1-2.-100096.-%E6%89%BE%E5%87%BA%E6%BB%A1%E8%B6%B3%E5%B7%AE%E5%80%BC%E6%9D%A1%E4%BB%B6%E7%9A%84%E4%B8%8B%E6%A0%87-i" tabindex="-1">T1-2. <a href="https://leetcode.cn/problems/find-indices-with-index-and-value-difference-i/description/">100096. 找出满足差值条件的下标 I </a></h3><ul><li><a href="https://leetcode.cn/problems/find-indices-with-index-and-value-difference-ii/description/">100101. 找出满足差值条件的下标 II </a>：和这道题思路一样，只是数据量规模不一样而已。</li></ul><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h4><p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> ，以及整数 <code>indexDifference</code> 和整数 <code>valueDifference</code> 。</p><p>你的任务是从范围 <code>[0, n - 1]</code> 内找出 <strong>2</strong> 个满足下述所有条件的下标 <code>i</code> 和 <code>j</code> ：</p><ul><li><code>abs(i - j) &gt;= indexDifference</code> 且</li><li><code>abs(nums[i] - nums[j]) &gt;= valueDifference</code></li></ul><p>返回整数数组 <code>answer</code>。如果存在满足题目要求的两个下标，则 <code>answer = [i, j]</code> ；否则，<code>answer = [-1, -1]</code> 。如果存在多组可供选择的下标对，只需要返回其中任意一组即可。</p><p><strong>注意：</strong><code>i</code> 和 <code>j</code> 可能 <strong>相等</strong> 。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [5,1,4,1], indexDifference = 2, valueDifference = 4输出：[0,3]解释：在示例中，可以选择 i = 0 和 j = 3 。abs(0 - 3) &gt;= 2 且 abs(nums[0] - nums[3]) &gt;= 4 。因此，[0,3] 是一个符合题目要求的答案。[3,0] 也是符合题目要求的答案。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= n == nums.length &lt;= 100</code></p></li><li><p><code>0 &lt;= nums[i] &lt;= 50</code></p></li><li><p><code>0 &lt;= indexDifference &lt;= 100</code></p></li><li><p><code>0 &lt;= valueDifference &lt;= 50</code></p><p>​</p></li></ul><hr><h4 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h4><ul><li><p>无脑暴力解答，这里用到的是嵌套两个循环进行判断。（当然这里需要考虑到<code>n</code>的长度和<code>nums[i]</code>的大小关系）</p></li><li><p>当然如果考虑到<code>nums[i]</code>的长度关系，我们还可以利用双指针进行判断。</p></li><li><p><strong>还有一种方法是红黑树，但是这种方法之前没试过，后续准备一份HashMap和TreeMap的区别文章总结一下，这里就直接贴代码解释</strong></p><p>​</p></li></ul><hr><h4 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3. 具体代码</h4><h5 id="%EF%BC%881%EF%BC%89%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95" tabindex="-1">（1）暴力解法</h5><ul><li>适用于数组的长度较小的情况，而且对于当前的两层循环注意前后顺序</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int[] findIndices(int[] nums, int indexDifference, int valueDifference) {        int[] ans=new int[2];        int n=nums.length;        for(int i=0;i&lt;n-indexDifference;i++){            for(int j=i+indexDifference;j&lt;n;j++){                if(Math.abs(nums[i]-nums[j])&gt;=valueDifference){                    ans[0]=i;                    ans[1]=j;                    return ans;                }            }        }        ans[0]=-1;        ans[1]=-1;        return ans;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq></strong>，两层嵌套循环</p></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq></strong>，只用到了数组的数据结构</p><p>​</p></li></ul></li></ul><h5 id="%EF%BC%882%EF%BC%89%E5%8F%8C%E6%8C%87%E9%92%88%E4%BC%98%E5%8C%96" tabindex="-1">（2）双指针优化</h5><ul><li>不用全部元素都循环遍历，而是考虑两个指针之间的差值关系就行。</li><li>枚举<code>indexDifference</code>的同时，开始进行<code>nums[i]</code>的最大值和最小值的维护判断。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int[] findIndices(int[] nums, int indexDifference, int valueDifference) {        int maxIdx = 0, minIdx = 0;        for (int j = indexDifference; j &lt; nums.length; j++) {            int i = j - indexDifference;            if (nums[i] &gt; nums[maxIdx]) {                maxIdx = i;            } else if (nums[i] &lt; nums[minIdx]) {                minIdx = i;            }            if (nums[maxIdx] - nums[j] &gt;= valueDifference) {                return new int[]{maxIdx, j};            }            if (nums[j] - nums[minIdx] &gt;= valueDifference) {                return new int[]{minIdx, j};            }        }        return new int[]{-1, -1};    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析</strong></p><ul><li><p><strong>时间复杂度</strong>：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>，其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></eq> 为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></eq> 的长度。</p></li><li><p><strong>空间复杂度</strong>：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq>。</p><p>​</p></li></ul></li></ul><h5 id="%EF%BC%883%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91treemap" tabindex="-1">（3）红黑树TreeMap</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution{//使用TreeMap将数组中的元素与下标映射关联起来，然后依次遍历数组中的元素，判断是否存在满足条件的两个元素。    public int[] findIndices(int[] nums, int indexDifference, int valueDifference) {    // 创建一个TreeMap对象    TreeMap&lt;Integer,Integer&gt; map = new TreeMap&lt;&gt;();    int n = nums.length;    // 遍历数组    for(int i = indexDifference; i &lt; n; i++) {        // 将元素作为key，下标作为value，添加到map中去        map.put(nums[i - indexDifference], i - indexDifference);        // 判断当前元素与最小的元素的差的绝对值是否大于等于valueDifference        if(Math.abs(map.firstKey() - nums[i]) &gt;= valueDifference) {            return new int[] {map.get(map.firstKey()), i};        }        // 判断当前元素与最大的元素的差的绝对值是否大于等于valueDifference        if(Math.abs(map.lastKey() - nums[i]) &gt;= valueDifference) {            return new int[] {map.get(map.lastKey()), i};        }    }    // 如果找不到满足条件的两个元素，则返回[-1, -1]    return new int[] {-1, -1};      }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong>，在<code>for</code>循环中需要遍历全部数组元素，复杂度为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>；在寻找最大/最小值的时候查找的复杂度为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>。综上所述：时间复杂度为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p></li><li><p><strong>空间复杂度</strong>：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>，因为需要使用大小为n-indexDifference+1的TreeMap来存储数据。</p><p>​</p><p>​</p></li></ul></li></ul><h3 id="t3.-100084.-%E6%9C%80%E7%9F%AD%E4%B8%94%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E7%BE%8E%E4%B8%BD%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2" tabindex="-1">T3. <a href="https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/">100084. 最短且字典序最小的美丽子字符串 </a></h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E-1" tabindex="-1">1. 题目说明</h4><p>给你一个二进制字符串 <code>s</code> 和一个正整数 <code>k</code> 。</p><p>如果 <code>s</code> 的某个子字符串中 <code>1</code> 的个数恰好等于 <code>k</code> ，则称这个子字符串是一个 <strong>美丽子字符串</strong> 。</p><p>令 <code>len</code> 等于 <strong>最短</strong> 美丽子字符串的长度。</p><p>返回长度等于 <code>len</code> 且字典序 <strong>最小</strong> 的美丽子字符串。如果 <code>s</code> 中不含美丽子字符串，则返回一个 <strong>空</strong> 字符串。</p><p>对于相同长度的两个字符串 <code>a</code> 和 <code>b</code> ，如果在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置上，<code>a</code> 中该位置上的字符严格大于 <code>b</code> 中的对应字符，则认为字符串 <code>a</code> 字典序 <strong>大于</strong> 字符串 <code>b</code> 。</p><ul><li>例如，<code>"abcd"</code> 的字典序大于 <code>"abcc"</code> ，因为两个字符串出现不同的第一个位置对应第四个字符，而 <code>d</code> 大于 <code>c</code> 。</li></ul><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：s = "100011001", k = 3输出："11001"解释：示例中共有 7 个美丽子字符串：1. 子字符串 "/100011/001" 。2. 子字符串 "/1000110/01" 。3. 子字符串 "/100011001/" 。4. 子字符串 "1/00011001/" 。5. 子字符串 "10/0011001/" 。6. 子字符串 "100/011001/" 。7. 子字符串 "1000/11001/" 。最短美丽子字符串的长度是 5 。长度为 5 且字典序最小的美丽子字符串是子字符串 "11001" 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= s.length &lt;= 100</code></p></li><li><p><code>1 &lt;= k &lt;= s.length</code></p><p>​</p></li></ul><h4 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90-1" tabindex="-1">2. 解答分析</h4><ul><li><p>可以看出当前的字符串的长度较短，可以直接利用暴力解答。利用双指针就行,确定好具体的范围关系。</p><p>​</p></li></ul><h4 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81-1" tabindex="-1">3. 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution{    public String shortestBeautifulSubstring(String s,int k){        String result="";//返回字符串        for(int i=0;i&lt;s.length();i++){            for(int j=i;j&lt;s.length();j++){                String sub=s.substring(i,j+1);//返回前后指针构造成的字符串                if(isValid(sub,k)){                    if(result.length()==0){                        result=sub;                    }else if(result.length()&gt;sub.length()){                        result=sub;                    }else if(result.length()==sub.length() &amp;&amp; result.compareTo(sub) &gt; 0){  //如果"result"的字典序大于"sub"的字典序，那么返回值就会大于0；否则返回-1或0                        result=sub;                    }                }            }        }        return result;    }        private boolean isValid(String sub,int k){        int count=0;        for(int i=0;i&lt;sub.length();i++){            if(sub.charAt(i)=='1'){                count++;            }        }        return count==k;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq></strong></p></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq></strong></p><p>​</p></li></ul></li></ul><hr><center><span style="color:orange;font-size:30px;">END~</span><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css"></center>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈模板和应用例题</title>
      <link href="/2023/10/14/dan-diao-zhan-mo-ban-he-ying-yong-li-ti/"/>
      <url>/2023/10/14/dan-diao-zhan-mo-ban-he-ying-yong-li-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="%E5%8D%95%E8%B0%83%E6%A0%88%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%BA%94%E7%94%A8%E4%BE%8B%E9%A2%98" tabindex="-1">单调栈模板和应用例题</h3><blockquote><p>栈的特征是先进后出，单调栈说明是按照大小顺序进行排序等，下面就来详细说说这类问题的解法。得出一个清晰地模板。</p></blockquote><blockquote><p>单调栈模板就一句话：<strong>Next Greater Number</strong></p></blockquote><p>既然是下一个更大的元素，那从数组尾部逆序遍历，这样结合入栈出栈的顺序，会带来极大的方便，代码统一，更加接近所谓的单调栈模板。</p><h3 id="%E5%8D%95%E8%B0%83%E6%A0%88%E6%A8%A1%E6%9D%BF" tabindex="-1">单调栈模板</h3><ol><li>从后到前逆序遍历目标数组</li><li>利用单调栈的单调递减性来决定栈顶元素是否需要出栈。</li><li>重点：以栈是否为空来作为是否满足题目条件的依据进行处理。不为空说明符合条件，为空说明栈里之前没有一个元素满足条件。比如，由于是逆序，说明当前元素之后没有任何元素大于它。</li><li>入栈。</li></ol><ul><li><strong>何时出栈</strong>：如果此时的新元素大于栈顶元素，那么此时如果新元素入栈，就不符合单调递减性了。此时需要将栈顶元素循环弹出，直到符合单调递减性为止。从栈底到栈顶可以是：<code>4,3,2,1</code>这类。</li><li><strong>何时入栈</strong>：满足单调递减性就可以入栈。</li></ul><p>这里满足单调递减性存在两种情况，栈被清空，或栈顶元素大于新元素。此时新元素入栈，满足单调递减性。</p><p>​</p><hr><h3 id="%E5%BA%94%E7%94%A8%E4%BE%8B%E9%A2%981%EF%BC%9A739.-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6" tabindex="-1">应用例题1：<a href="https://leetcode.cn/problems/daily-temperatures/description/">739. 每日温度 </a></h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h4><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p><strong>示例 1:</strong></p><pre class="line-numbers language-none"><code class="language-none">输入: temperatures = [73,74,75,71,69,72,76,73]输出: [1,1,4,2,1,1,0,0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2:</strong></p><pre class="line-numbers language-none"><code class="language-none">输入: temperatures = [30,40,50,60]输出: [1,1,1,0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 3:</strong></p><pre class="line-numbers language-none"><code class="language-none">输入: temperatures = [30,60,90]输出: [1,1,0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= temperatures.length &lt;= 105</code></p></li><li><p><code>30 &lt;= temperatures[i] &lt;= 100</code></p><p>​</p></li></ul><hr><h4 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h4><ul><li><p>利用单调栈进行解答，逆序遍历数组，判断栈是否为空来作为当前元素是否有下一个更大元素的依据。</p></li><li><p>本题中是<code>从小到大</code>对数组进行排序，最后的答案数组返回的是<code>栈顶元素位置与当前元素i</code>的差值。</p><p>​</p></li></ul><hr><h4 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3. 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {       //《单调栈模板方法》：逆序遍历数组，然后判断栈是否为空来作为当前元素是否有下一个更大元素的依据。    public int[] dailyTemperatures(int[] temperatures) {        int n = temperatures.length;        int[] res = new int[n];        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        for (int i = n - 1; i &gt;= 0; i--) {            while (!stack.isEmpty() &amp;&amp; temperatures[stack.peek()] &lt;= temperatures[i]) {                stack.pop();            }            //只有这一步会变，其他步骤是相对固定的。但也是以栈是否为空来作为判断是否满足题目要求的条件            res[i] = stack.isEmpty() ? 0 : stack.peek() - i;            stack.push(i);//如果当前的栈为空，或者说是此时的元素较栈顶元素小        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong></p><blockquote><p>这段代码的时间复杂度为O(n)，其中n是温度数组的长度。 在循环中，我们逆序遍历温度数组，每个元素最多入栈一次，出栈一次。入栈和出栈的时间复杂度都是O(1)。因此，整个算法的时间复杂度是O(n)。</p></blockquote></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong></p><blockquote><p>n即为温度数组的长度，引入栈来存储元素的索引。</p></blockquote><p>​</p></li></ul></li></ul><hr><h3 id="%E5%BA%94%E7%94%A8%E4%BE%8B%E9%A2%982%EF%BC%9A496.-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-i" tabindex="-1">应用例题2：<a href="https://leetcode.cn/problems/next-greater-element-i/description/">496. 下一个更大元素 I </a></h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E-1" tabindex="-1">1. 题目说明</h4><p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。</p><p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p><p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p><p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <strong>下一个更大元素</strong> 。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums1 = [4,1,2], nums2 = [1,3,4,2].输出：[-1,3,-1]解释：nums1 中每个值的下一个更大元素如下所述：- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></p></li><li><p><code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></p></li><li><p><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></p></li><li><p><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</p><p>​</p></li></ul><hr><h4 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90-1" tabindex="-1">2. 解答分析</h4><ul><li><p>还是一样的套路，在单调栈的基础上借助额外的数据结构<code>HashMap</code>,可以存错遍历过程中所有元素的下一个更大值。最后在遍历子数组从 <code>HashMap</code> 里以 <code>O(1)</code> 时间复杂度获取目标值。</p></li><li><p>还是一样注意从后向前对数组进行遍历，每次都需要记录当前元素的值和下一位较大的值。注意查找的数组是<code>num2</code>中的元素。</p><p>​</p></li></ul><hr><h4 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81-1" tabindex="-1">3. 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution{    //单调栈目标    public int[] nextGreaterElement(int[] nums1,int[]nums2){        int n=nums2.length;        Stack&lt;Integer&gt; stack=new Stack&lt;&gt;();        HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();        for(int i=n-1;i&gt;=0;i--){            while(!stack.isEmpty() &amp;&amp; nums2[i]&gt;stack.peek()){                stack.pop();            }            int next=stack.isEmpty()?-1:stack.peek();//因为是从数组尾部遍历入栈的，因此栈顶肯定是位于当前元素之后            map.put(nums2[i],next);            stack.push(nums2[i]);        }        int[] res = new int[nums1.length];        for (int i = 0; i &lt; nums1.length; i++) {            res[i] = map.get(nums1[i]);//借助 Map 很方便        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong></p><blockquote><p>这段代码的时间复杂度为O(n)，其中n是nums2数组的长度。 在循环中，我们逆序遍历nums2数组，每个元素最多入栈一次，出栈一次。入栈和出栈的时间复杂度都是O(1)。同时，我们还通过HashMap构建了nums2数组中每个元素的下一个更大元素的映射关系，构建映射的时间复杂度也是O(n)。因此，整个算法的时间复杂度是O(n)。</p></blockquote></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong></p><blockquote><p>这段代码的空间复杂度为O(n)，其中n是nums2数组的长度。 代码中使用了一个栈来存储元素和一个哈希表来存储下一个更大元素的映射关系。栈的最大容量取决于nums2数组的长度n，而哈希表的大小也最多是n。因此，该算法的空间复杂度是O(n)。</p></blockquote><p>​</p></li></ul></li><li><p>还有个更简单的版本：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    //《单调栈模板方法》    public int[] nextGreaterElement(int[] nums) {        int[] res = new int[nums.length];        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        for(int i = nums.length; i &gt;= 0; i--) {            //不满足单调递减，弹出直到满足了下面才入栈            while (!stack.isEmpty() &amp;&amp; nums[i] &gt; stack.peek()) stack.pop();            //所有元素都会得到结果            res[i] = stack.isEmpty() ? -1 : stack.peek();            //所有元素最终都会入栈            stack.push(nums[i]);        }        return res;    }}//这个算法的复杂度只有O(n)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>单调栈的思想还是挺重要的，继续努力吧。多去练习~</p></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题连更3Day</title>
      <link href="/2023/10/11/mei-ri-yi-ti-lian-geng-3day/"/>
      <url>/2023/10/11/mei-ri-yi-ti-lian-geng-3day/</url>
      
        <content type="html"><![CDATA[<h3 id="%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E8%BF%9E%E6%9B%B43day" tabindex="-1">每日一题连更3Day</h3><blockquote><p>最近真的太忙碌啦！每日一题也停了，现在重新写三道这样的题，看看里面用到了什么算法，学习学习。</p></blockquote><h3 id="10.09-%E6%89%93%E5%8D%A1" tabindex="-1">10.09 打卡</h3><h4 id="1.%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1.题目说明</h4><ul><li><a href="https://leetcode.cn/problems/determine-if-two-events-have-conflict/description/?envType=daily-question&amp;envId=2023-10-11">2446. 判断两个事件是否存在冲突 </a></li></ul><p>给你两个字符串数组 <code>event1</code> 和 <code>event2</code> ，表示发生在同一天的两个闭区间时间段事件，其中：</p><ul><li><code>event1 = [startTime1, endTime1]</code> 且</li><li><code>event2 = [startTime2, endTime2]</code></li></ul><p>事件的时间为有效的 24 小时制且按 <code>HH:MM</code> 格式给出。</p><p>当两个事件存在某个非空的交集时（即，某些时刻是两个事件都包含的），则认为出现 <strong>冲突</strong> 。</p><p>如果两个事件之间存在冲突，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：event1 = ["01:15","02:00"], event2 = ["02:00","03:00"]输出：true解释：两个事件在 2:00 出现交集。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​</p><h4 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h4><ul><li><p>写成 <code>event1[0] &lt;= event2[1] and event2[0] &lt;= event1[1]</code></p><ul><li>第一个事件的开始时间不晚于第二个事件的结束时间</li><li>第二个事件的开始时间不晚于第一个事件的结束时间</li></ul></li><li><p>只用取交集就行，由于最后返回的是布尔值，判断<code>true or false</code>即可。</p><p>​</p></li></ul><h4 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3. 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public boolean haveConflict(String[] event1, String[] event2) {        return event1[0].compareTo(event2[1]) &lt;= 0 &amp;&amp; event1[1].compareTo(event2[0]) &gt;= 0;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq></strong></p></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq></strong></p><p>​</p></li></ul></li></ul><hr><h3 id="10.08-%E6%89%93%E5%8D%A1" tabindex="-1">10.08 打卡</h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h4><ul><li><a href="https://leetcode.cn/problems/adding-two-negabinary-numbers/description/?envType=daily-question&amp;envId=2023-10-11">1073. 负二进制数相加 - 力扣（LeetCode）</a></li></ul><p>给出基数为 <strong>-2</strong> 的两个数 <code>arr1</code> 和 <code>arr2</code>，返回两数相加的结果。</p><p>数字以 <em>数组形式</em> 给出：数组由若干 0 和 1 组成，按最高有效位到最低有效位的顺序排列。例如，<code>arr = [1,1,0,1]</code> 表示数字 <code>(-2)^3 + (-2)^2 + (-2)^0 = -3</code>。<em>数组形式</em> 中的数字 <code>arr</code> 也同样不含前导零：即 <code>arr == [0]</code> 或 <code>arr[0] == 1</code>。</p><p>返回相同表示形式的 <code>arr1</code> 和 <code>arr2</code> 相加的结果。两数的表示形式为：不含前导零、由若干 0 和 1 组成的数组。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：arr1 = [1,1,1,1,1], arr2 = [1,0,1]输出：[1,0,0,0,0]解释：arr1 表示 11，arr2 表示 5，输出表示 16 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：arr1 = [0], arr2 = [0]输出：[0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：arr1 = [0], arr2 = [1]输出：[1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= arr1.length, arr2.length &lt;= 1000</code></p></li><li><p><code>arr1[i]</code> 和 <code>arr2[i]</code> 都是 <code>0</code> 或 <code>1</code></p></li><li><p><code>arr1</code> 和 <code>arr2</code> 都没有前导0</p><p>​</p></li></ul><h4 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90-1" tabindex="-1">2. 解答分析</h4><ul><li>直接就想到模拟做法。我们可以遍历两个数组，从最低位开始，记两个数组当前位的数字为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></eq>和<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></eq>，进位为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span></eq>,三个组相加的结果为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq>。<ul><li>先将进位<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span></eq>置为0</li><li>如果此时<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">x\ge2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></eq>，那么此时将<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq>减去<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></eq>，并向高位进位-1。即为逢<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></eq>进负<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></eq>.</li><li>如果此时的<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x=-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span></eq>，由于<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mo stretchy="false">(</mo><mo>−</mo><mn>2</mn><msup><mo stretchy="false">)</mo><mi>i</mi></msup><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mn>2</mn><msup><mo stretchy="false">)</mo><mi>i</mi></msup><mo>+</mo><mo stretchy="false">(</mo><mo>−</mo><mn>2</mn><msup><mo stretchy="false">)</mo><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">-(-2)^i=(-2)^i+(-2)^{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0747em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord">−</span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0747em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0747em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></eq></li></ul></li><li>然后，我们将<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq>加入到答案数组中去，继续处理下一位。</li><li>遍历结束后，去除答案数组中末尾的<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></eq>，并将数组反转，即可得到最终的答案。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int[] addNegabinary(int[] arr1, int[] arr2) {        int i = arr1.length - 1, j = arr2.length - 1;        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        for (int c = 0; i &gt;= 0 || j &gt;= 0 || c != 0; --i, --j) {            int a = i &lt; 0 ? 0 : arr1[i];            int b = j &lt; 0 ? 0 : arr2[j];            int x = a + b + c;            c = 0;            if (x &gt;= 2) {                x -= 2;                c -= 1;            } else if (x == -1) {                x = 1;                c += 1;            }            ans.add(x);        }        while (ans.size() &gt; 1 &amp;&amp; ans.get(ans.size() - 1) == 0) {            ans.remove(ans.size() - 1);        }        Collections.reverse(ans);        return ans.stream().mapToInt(x -&gt; x).toArray();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析</strong>：</p><p>时间复杂度 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mtext>⁡</mtext><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(max⁡(n,m))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mord">⁡</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">))</span></span></span></span></eq>，其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></eq>和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></eq>分别是两个数组的长度。</p><p>忽略答案的空间消耗，空间复杂度 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq></p><p>​</p></li><li><p><strong>还有另外一种思路：</strong></p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int[] addNegabinary(int[] arr1, int[] arr2) {        int n1 = arr1.length,n2 = arr2.length;        ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();        //方法中使用了一个双端队列 q 存储计算结果，从低位开始逐位相加。        //按照-2进制相加的思路，每一位有-1,0,1,2,3五种情况        for (int i = n1-1,j = n2-1,add = 0;i &gt;= 0 || j &gt;= 0 || add != 0;i--,j--) {            int cur = (i&gt;=0 ? arr1[i] : 0) + (j&gt;=0 ? arr2[j] : 0) + add;            if (cur == 0 || cur == 1) {//不进位                add = 0;                q.addFirst(cur);            }            else if (cur == 2) {//进位-1，当前位为0                add = -1;                q.addFirst(0);            }            else if (cur == -1) {//从前一位借1，等价于进位1，当前位为1                add = 1;                q.addFirst(1);            }            else if (cur == 3) {//进位-1，当前位为1                add = -1;                q.addFirst(1);            }        }        //如果不是[0]的情况，则去掉前导零        while (q.size() &gt; 1 &amp;&amp; q.peek() == 0) q.pollFirst();        int sz = q.size();        int[] res = new int[sz];        for (int i = 0; i &lt; sz; i++) {            res[i] = q.pollFirst();        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><hr><h3 id="10.07-%E6%89%93%E5%8D%A1" tabindex="-1">10.07 打卡</h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E-1" tabindex="-1">1. 题目说明</h4><ul><li><a href="https://leetcode.cn/problems/letter-tile-possibilities/?envType=daily-question&amp;envId=2023-10-11">1079. 活字印刷 </a></li></ul><p>你有一套活字字模 <code>tiles</code>，其中每个字模上都刻有一个字母 <code>tiles[i]</code>。返回你可以印出的非空字母序列的数目。</p><p>**注意：**本题中，每个活字字模只能使用一次。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入："AAB"输出：8解释：可能的序列为 "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA"。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入："AAABBC"输出：188<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入："V"输出：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= tiles.length &lt;= 7</code></p></li><li><p><code>tiles</code> 由大写英文字母组成</p><p>​</p></li></ul><h4 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90-2" tabindex="-1">2. 解答分析</h4><ul><li><p>有点像排列组合，思路是先将给出的<code>tiles</code>字符串中统计单个字符出现的次数，最后再次将对应个数的字符进行排列组何起来即可。</p><p>​</p></li></ul><h4 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81-1" tabindex="-1">3. 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Solution {    public int numTilePossibilities(String tiles) {        int[] count = new int[26]; //count表示英文字符        char[] charArray = tiles.toCharArray();        for (char c : charArray) {            count[c - 'A']++;        }        // tiles 里所有的信息都存在 count 里，对 count 执行深度优先遍历即可        return dfs(count);    }    /**     * 设计递归函数的返回值     *     * 在当前的频数数组下，可以产生的排列数     */    private int dfs(int[] count) {        // 递归终止条件是：当前没有可以用的字符（没有显示递归终止条件）        int res=0;        for (int i = 0; i &lt; 26; i++) {            if (count[i] == 0) {                continue;            }            res++;            count[i]--;            res += dfs(count);            // 只需要重置字符频数数组            count[i]++;        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>26</mn><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(26*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">26</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong></p><blockquote><ol><li><p>首先，代码中使用一个长度为26的整型数组<code>count</code>来统计字符串中各个字母出现的频次，这需要遍历字符串一次，时间复杂度为O(n)。</p></li><li><p>接着，通过深度优先搜索（DFS）的方式遍历频次数组<code>count</code>，对每个非零频次的字母进行递归调用。在DFS过程中，每个字母会被加入结果一次，并产生一个新的递归分支。</p></li><li><p>假设字符串<code>tiles</code>中有k个不同的字母，且这k个字母的总频次为m。那么，在DFS的过程中，每个字母最多会被使用m次（递归的深度），而且每个字母的频次会减少1，直到频次为0。</p></li><li><p>因此，DFS过程的递归深度最多为m，每层DFS都需要遍历26个字母的频次数组，时间复杂度为O(26)。</p></li></ol><p>综上所述，整个代码的时间复杂度为O(n) * O(26^m) = O(26^n)</p></blockquote></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong></p><blockquote><p>代码只使用了一个长度为26的整型数组<code>count</code>，和一个字符数组<code>charArray</code>。因此，空间复杂度为O(26+ n) = O(n)。</p></blockquote><p>​</p></li></ul></li></ul><hr><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS的三种遍历方式</title>
      <link href="/2023/10/07/dfs-de-san-chong-bian-li-fang-shi/"/>
      <url>/2023/10/07/dfs-de-san-chong-bian-li-fang-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="dfs%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F" tabindex="-1">DFS的三种遍历方式</h3><blockquote><p>之前写过有关BFS和DFS的优先遍历方式的区别和联系。其中对BFS总结稍微详细一些，用到队列的数据结构，还有对层序遍历的用法分析。这次详细说说DFS的3种基础的遍历方式，可以将两者进行归纳总结一起来复习。</p></blockquote><p>​</p><h3 id="%E4%BA%8C%E5%8F%89%E6%A0%91" tabindex="-1">二叉树</h3><ul><li><p><code>树</code>是一种比较常见的数据结构，其中核心是包括<code>根</code>和<code>叶子</code>，这些节点都是具有一定联系。而其中，最具有代表性的是<code>二叉树</code>。</p></li><li><p><code>二叉树</code>。顾名思义，指的是树的分支最多存在两个流向。二叉树的根节点可能存在子节点，子节点又是对应子树的根节点。更为详尽地，子节点包含两个方向，一左一右。<strong>因此最好的处理方法是利用递归对二叉树各个节点流向进行遍历</strong></p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/10/07/dfs-de-san-chong-bian-li-fang-shi/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%BE%E4%BE%8B.png" alt="二叉树举例" style="zoom:67%;"></li><li><p>数据结构类型定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TreeNode{    int val;//节点的值    TreeNode left;//左节点    TreeNode right;//右节点        TreeNode(int x){        val=x;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p></li></ul><hr><h3 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84dfs" tabindex="-1">二叉树的DFS</h3><ul><li><p>本文探讨的是有关深度优先搜索的算法关系，<code>DFS</code>按照遍历的顺序可分为三类：</p><ul><li>中序遍历（左、根、右）</li><li>前序遍历（根、左、右）</li><li>后序遍历（左、右、根）</li></ul></li><li><p>对于<code>深度优先搜索</code>的遍历而言，由于是<code>在一条路上走到头，再进行回溯重新走</code>，所以一方面可以利用<code>递归思想</code>进行操作，另外一方面也可以用到<code>迭代思想</code>，利用<code>栈</code>的基本数据结构实现。本质上都相同，但是在代码量方面就存在很大的差异了。下面讨论的处理方式也分别用这两种方法进行实现。</p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/10/07/dfs-de-san-chong-bian-li-fang-shi/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%BE%E4%BE%8B.png" alt="二叉树举例" style="zoom:67%;"><p>​</p></li></ul><hr><h4 id="1.-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86" tabindex="-1">1. 中序遍历</h4><ul><li><p>按照中序遍历的顺序，先遍历二叉树的左子树，然后遍历二叉树的根节点，最后是二叉树的右子树。对于上图子树的遍历而言，依次的顺序是:<code>[4,2,5,1,6,3,7]</code></p><ol><li><strong>递归操作代码实现</strong>：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public List&lt;Integer&gt;inOrderTraversal(TreeNode root){    List&lt;Integer&gt; nodes=new LinkedList&lt;&gt;();//由于最后返回的是列表[,,,],所以需要用到LinkedList    dfs(root,nodes);    return nodes;}public void dfs(TreeNode root,List&lt;Integer&gt;nodes){    if(root!=null){        dfs(root.left,nodes);        nodes.add(root.val);        dfs(root.right,nodes);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可以看出上述的代码逻辑比较清晰，按照左、根、右的套路进行操作，但是如果二叉树的深度比较大（根节点到叶节点的最长路径的长度），我们进行<code>左操作</code>的次数太多的话，会导致栈溢出的问题，对空间浪费较为严重。</li><li>我们如果将<code>递归</code>换成<code>迭代</code>操作的话，需要引入<code>栈</code>的数据结构。对于中序遍历而言，我们在到达<code>根节点</code>的时候不进行遍历写入值的操作，而是进一步顺着左子节点找到叶节点，再进行回溯寻找父节点。这要求我们每次遍历二叉树的时候将遇到的每个节点都存储在栈中，方便查询。</li></ul><ol start="2"><li><strong>迭代操作代码实现</strong>：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public List&lt;Integer&gt; inOrderTraversal(TreeNode root){    List&lt;Integer&gt; nodes=new LinkedList&lt;&gt;();    Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();//引入栈的数据结构    TreeNode cur=root;//cur表示当前的节点，位置位于root    while(cur!=null || !stack.isEmpty()){//当前节点不为空，并且栈中存在元素值得时候        while(cur!=null){            stack.push(cur);//根元素入栈            cur=cur.left;//指针向左        }        //当左遍历完成之后        cur=stack.pop();//栈顶元素出栈，也就是最远的左子节点的位置元素出栈        nodes.add(cur.val);//遍历，添加节点值        cur=cur.right;//指针向右    }    return nodes;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>这里有个思考：左子节点遍历完之后为什么指针就指向右节点了？之前理解存在误区，所谓的<code>根节点</code>，其实是对应这上一层的<code>左节点</code>。二叉树中实际只有左右两个分支和最初的<code>root</code>节点，只是我们按层进行划分的时候存在<code>根和子</code>的区别。</p><p>​</p></li></ul></li></ul><hr><h4 id="2.-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86" tabindex="-1">2. 前序遍历</h4><ul><li><p>按照前序遍历的顺序，先遍历二叉树的根节点，然后遍历二叉树的左子树，最后是二叉树的右子树。对于上图子树的遍历而言，依次的顺序是:<code>[1,2,4,5,3,6,7]</code>。</p></li><li><p><strong>由于前序遍历和中序遍历的代码思考逻辑很像，这里就直接贴出两种方式的对应代码，进行比较即可。</strong></p><ol><li><strong>递归操作代码实现</strong>：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public List&lt;Integer&gt;PreOrderTraversal(TreeNode root){    List&lt;Integer&gt; nodes=new LinkedList&lt;&gt;();//由于最后返回的是列表[,,,],所以需要用到LinkedList    dfs(root,nodes);    return nodes;}public void dfs(TreeNode root,List&lt;Integer&gt;nodes){    if(root!=null){        nodes.add(root.val);//记录当前（根）节点的值        dfs(root.left,nodes);        dfs(root.right,nodes);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><ol start="2"><li><strong>迭代操作代码实现</strong>：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public List&lt;Integer&gt; inOrderTraversal(TreeNode root){    List&lt;Integer&gt; nodes=new LinkedList&lt;&gt;();    Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();//引入栈的数据结构    TreeNode cur=root;//cur表示当前的节点，位置位于root    while(cur!=null || !stack.isEmpty()){//当前节点不为空，并且栈中存在元素值得时候        while(cur!=null){            nodes.add(cur.val);//遍历，添加节点值            stack.push(cur);//根元素入栈            cur=cur.left;//指针向左        }        //当左遍历完成之后        cur=stack.pop();//栈顶元素出栈，也就是最远的左子节点的位置元素出栈        cur=cur.right;//指针向右    }    return nodes;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p></li></ul><hr><h4 id="3.-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86" tabindex="-1">3. 后序遍历</h4><ul><li><p>按照后序遍历的顺序，先遍历二叉树的左子树，然后遍历二叉树的右子树，最后是二叉树的根节点。对于上图子树的遍历而言，依次的顺序是:<code>[4,5,2,6,7,3,1]</code>。</p><ol><li><strong>递归操作代码实现</strong>：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public List&lt;Integer&gt;PreOrderTraversal(TreeNode root){    List&lt;Integer&gt; nodes=new LinkedList&lt;&gt;();//由于最后返回的是列表[,,,],所以需要用到LinkedList    dfs(root,nodes);    return nodes;}public void dfs(TreeNode root,List&lt;Integer&gt;nodes){    if(root!=null){        dfs(root.left,nodes);        dfs(root.right,nodes);        nodes.add(root.val);//记录当前（根）节点的值    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p></li><li><p>和中序、前序遍历方法相比，后序遍历的迭代方法复杂一些。当到达某个节点时，如果之前没遍历过它的右子树就得遍历一下，遍历过了才可以遍历此节点。</p></li><li><p>如果此前右子树已经遍历过了，那么在右子树中最后一个遍历的节点应该是右子树的根节点，也就是当前节点的右子节点。</p><ol start="2"><li><strong>迭代操作代码实现：</strong></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public List&lt;Integer&gt; inOrderTraversal(TreeNode root){      List&lt;Integer&gt; nodes=new LinkedList&lt;&gt;();      Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();//引入栈的数据结构      TreeNode cur=root;//cur表示当前的节点，位置位于root            TreeNode prev=null;//遍历过的前一个节点            while(cur!=null || !stack.isEmpty()){//当前节点不为空，并且栈中存在元素值得时候          while(cur!=null){              stack.push(cur);//根元素入栈              cur=cur.left;//指针向左          }          //当左遍历完成之后          cur=stack.peek();//返回栈顶元素，但是并不出栈                    if(cur.right!=null &amp;&amp; cur.right!=prev){//有右子树但是没遍历过              cur=cur.right;//指针向右                        }else{//没有右子树或者右子树已经遍历过                            stack.pop();//栈顶元素出栈，也就是最远的左子节点的位置元素出栈              nodes.add(cur.val);//遍历当前的值              prev=cur;//指向当前的父节点              cur=null;//cur清空          }           }      return nodes;  }  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p></li></ul><hr><h3 id="%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" tabindex="-1">复杂度分析</h3><h4 id="%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" tabindex="-1">时间复杂度</h4><ul><li>无论是哪种遍历算法，还是递归或迭代，如果此时的二叉树的节点个数为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></eq>，那么此时的时间复杂度为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>。因为总共需要遍历<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></eq>个节点。</li></ul><h4 id="%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" tabindex="-1">空间复杂度</h4><ul><li><p>如果二叉树的深度为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></eq>，那么空间复杂度为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></eq>。</p></li><li><p>在二叉树中，深度<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span></eq>的取值范围是<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>+</mo><mn>1</mn><mtext>，</mtext><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[log_2 n+1，n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span></eq>。也就是最小值为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">log_2 n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></eq>,最大值为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></eq>。</p><ul><li><p>举个简单的例子：</p><p>包含7个节点的二叉树最少为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span></eq>层（每层分别为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mtext>，</mtext><mn>2</mn><mtext>，</mtext><mn>4</mn></mrow><annotation encoding="application/x-tex">1，2，4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord">2</span><span class="mord cjk_fallback">，</span><span class="mord">4</span></span></span></span></eq>）；最多可能有<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span></eq>层（每层都是<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></eq>）。</p><p>​</p></li></ul></li></ul><hr><center><span style="color:lightblue;font-size:30px;">继续努力😊</span></center><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优先搜索 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.买卖股票的最佳时机(系列)</title>
      <link href="/2023/10/05/leetcode-mai-mai-gu-piao-de-zui-jia-shi-ji-xi-lie/"/>
      <url>/2023/10/05/leetcode-mai-mai-gu-piao-de-zui-jia-shi-ji-xi-lie/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA(%E7%B3%BB%E5%88%97)" tabindex="-1">Leetcode.买卖股票的最佳时机(系列)</h3><blockquote><p>Leetcode的打卡题目这个系列挺有意思的，现在自己复盘一轮，学习里面的思考算法，做点总结。</p></blockquote><p>​</p><h3 id="level-1.-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA" tabindex="-1">Level 1. <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/"> 买卖股票的最佳时机 </a></h3><h4 id="1.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1.1 题目说明</h4><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。（注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= prices.length &lt;= 105</code></p></li><li><p><code>0 &lt;= prices[i] &lt;= 104</code></p><p>​</p></li></ul><hr><h4 id="1.2-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">1.2 解答分析</h4><ul><li><p>获得最大的利润，想的就是最低买入，最高卖出即可。若是在前<code>i</code>天选择买入，想要达到最高的利润，**则一定会选择价格最低的交易日买入。**这里可以用到算法的思想是：<strong>贪心算法</strong>。遍历价格列表<code>prices</code>并执行两步：</p><blockquote><p>由于初始值<code>i</code>=0 ，为了序号对应，本文设从第 <code>0</code> 天开始；</p></blockquote><ol><li>更新前<code>i</code>天的最低价格，即最低买入成本 <code>cost</code>；</li><li>更新前<code>i</code>天的最高利润 profit ，即选择「前 <code>i−1</code>天最高利润 <code>profit</code> 」和「第 <code>i</code>天卖出的最高利润 <code>price - cost</code> 」中的最大值 ；</li></ol></li><li><p>用到<code>for</code>循环就行，找到最大值和最小值，接着和前一个状态比较利润的大小即可。</p><p>​</p></li></ul><hr><h4 id="1.3-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">1.3 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int maxProfit(int[] prices) {        int cost=Integer.MAX_VALUE,profit=0;        for(int price:prices){            cost=Math.min(cost,price);//找到最小的买入值            profit=Math.max(profit,price-cost);//不断更新利润的最大值        }        return profit;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong>，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></eq>的长度即为数组的长度。</p></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq></strong>，未引入新的存储空间。</p><p>​</p></li></ul></li></ul><hr><h3 id="level-2.-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii" tabindex="-1">Level 2. <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/"> 买卖股票的最佳时机 II </a></h3><h4 id="2.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">2.1 题目说明</h4><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 你能获得的 <strong>最大</strong> 利润 。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。     总利润为 4 + 3 = 7 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。     总利润为 4 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= prices.length &lt;= 3 * 104</code></p></li><li><p><code>0 &lt;= prices[i] &lt;= 104</code></p><p>​</p></li></ul><hr><h4 id="2.2-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2.2 解答分析</h4><ul><li><p>遍历整个股票交易日价格列表<code>price</code>，并执行贪心策略：所有上涨交易日都买卖（赚到所有利润），所有下降交易日都不买卖（永不亏钱）。</p></li><li><p>设 <code>tmp</code>为第 <code>i-1</code> 日买入与第 <code>i</code> 日卖出赚取的利润，即 <code>tmp = prices[i] - prices[i - 1];</code><br>当该天利润为正 <code>tmp</code> &gt;<code> 0</code>，则将利润加入总利润 <code>profit</code>；当利润为 <code>0</code> 或为负，则直接跳过；<br>遍历完成后，返回总利润 <code>profit</code>。</p></li><li><p>由于最多只能有一股股票，也就是每天都是买或不买。但是如果第i天买入，那么后续天只能选择卖出，从而赚取差值作为利润。</p></li><li><p><strong>和Level1的区别：本题是总天数的累计总利润最大，而不是全部天数计算差值最大的<code>2</code>天</strong></p><p>​</p></li></ul><hr><h4 id="2.3-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">2.3 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//思路1：class Solution {    public int maxProfit(int[] prices) {        int profit = 0;        for (int i = 1; i &lt; prices.length; i++) {            int tmp = prices[i] - prices[i - 1];//计算相邻两天的差值            if (tmp &gt; 0) profit += tmp;        }        return profit;    }}//思路2：和思路1雷同，但是代码可能好理解一些class Solution {    public int maxProfit(int[] prices) {        int min=prices[0],max=prices[0],ans=0;        for(int i=0;i&lt;prices.length;i++){            if(max&gt;prices[i]){//不断找到较大的值                ans+=max-min;                max=prices[i];                min=prices[i];            }else{//相等的时候左指针不动，右指针右移                max=prices[i];            }        }         ans+=max-min;//包含最后一位的卖出可能存在的差值，如[1,2,3,4,5]，最后max等于5，此时min等于1，最后需要做差        return ans;    }}//思路3：动态规划,这里做简单地处理，给出状态转移方程，分为持有和不持有的两种状态class Solution {    public int maxProfit(int[] prices) {        int n = prices.length;        int[][] dp = new int[n][2];        dp[0][0] = 0;//不持有（第0天）        dp[0][1] = -prices[0];//持有（第0天）        for (int i = 1; i &lt; n; i++) {            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); //对于今天不持有，可以从两个状态转移过来：1. 昨天也不持有；2. 昨天持有，今天卖出。两者取较大值。            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);//对于今天持有，可以从两个状态转移过来：1. 昨天也持有；2. 昨天不持有，今天买入。两者取较大值。        }        return dp[n - 1][0];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p></li><li><p><strong>空间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq></p><p>​</p></li></ul></li></ul><hr><h3 id="level-3.-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-iii" tabindex="-1">Level 3. <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/"> 买卖股票的最佳时机 III </a></h3><h4 id="3.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">3.1 题目说明</h4><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：prices = [3,3,5,0,0,3,1,4]输出：6解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。        注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。        因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 4：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：prices = [1]输出：0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= prices.length &lt;= 105</code></p></li><li><p><code>0 &lt;= prices[i] &lt;= 105</code></p><p>​</p></li></ul><hr><h4 id="3.2-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">3.2 解答分析</h4><ul><li><p><strong>动态规划</strong>，前两个级别都是可以用暴力和贪心进行解答，<strong>但是本阶段开始就需要利用到动态规划了</strong></p></li><li><p>一般的动态规划题目思路三步走：</p><ol><li>定义状态转移方程</li><li>给定转移方程初始值</li><li>写代码递推实现转移方程</li></ol></li><li><p>状态定义：<code>dp[i][j][k]</code> 表示在 <code>[0, i]</code> 区间里（状态具有前缀性质），交易进行了 <code>j</code> 次，并且状态为 <code>k </code>时我们拥有的现金数。其中 <code>j </code>和<code>k</code>的含义如下：</p><ul><li><p><code>j = 0 </code>表示没有交易发生；<code>j = 1</code>表示此时已经发生了<code> 111</code> 次买入股票的行为； <code>j = 2 </code>表示此时已经发生了 <code>222</code> 次买入股票的行为。即我们 人为规定 记录一次交易产生是在 买入股票 的时候。</p></li><li><p><code>k = 0</code> 表示当前不持股； <code>k = 1 </code>表示当前持股。</p></li></ul></li><li><p>思考初始化：</p><ul><li>下标为 0这一天，交易次数为 0、1、2并且状态为 0 和 1的初值应该如下设置：</li><li><code>dp[0][0][0] = 0</code>：这是显然的；</li><li><code>dp[0][0][1]</code>：表示一次交易都没有发生，但是持股，这是不可能的，也不会有后序的决策要用到这个状态值，可以不用管；</li><li><code>dp[0][1][0] = 0</code>：表示发生了 1次交易，但是不持股，这是不可能的。虽然没有意义，但是设置成 0 不会影响最优值；</li><li><code>dp[0][1][1] = -prices[0]：</code>表示发生了一次交易，并且持股，所以我们持有的现金数就是当天股价的相反数；</li><li><code>dp[0][2][0] = 0：</code>表示发生了 2次交易，但是不持股，这是不可能的。虽然没有意义，但是设置成 0不会影响最优值；</li><li><code>dp[0][2][1] = 负无穷：</code>表示发生了 2次交易，并且持股，这是不可能的。注意：虽然没有意义，但是不能设置成 0，这是因为交易还没有发生，必须规定当天 k 状态为 1（持股），需要参考以往的状态转移，一种很有可能的情况是没有交易是最好的情况。</li><li><strong>说明</strong>：<code>dp[0][2][1]</code> 设置成为负无穷这件事情我可能没有说清楚。大家可以通过特殊测试用例 [1, 2, 3, 4, 5]，对比 <code>dp[0][2][1] = 0 与 dp[0][2][1] = 负无穷</code> 的状态转移的差异去理解。</li></ul></li><li><p><strong>注意</strong>：只有在之前的状态有被赋值的时候，才可能有当前状态。</p></li><li><p><strong>思考输出</strong>：最后一天不持股的状态都可能成为最大利润。</p><p>​</p></li></ul><hr><h4 id="3.3-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3.3 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Solution {    public int maxProfit(int[] prices) {        int len = prices.length;        if (len &lt; 2) {            return 0;        }        // 第 2 维的 0 没有意义，1 表示交易进行了 1 次，2 表示交易进行了 2 次        // 为了使得第 2 维的数值 1 和 2 有意义，这里将第 2 维的长度设置为 3        int[][][] dp = new int[len][3][2];        // 理解如下初始化        // 第 3 维规定了必须持股，因此是 -prices[0]        dp[0][1][1] = -prices[0];        // 还没发生的交易，持股的时候应该初始化为负无穷        dp[0][2][1] = Integer.MIN_VALUE;        for(int i=1;i&lt;len;i++){            //如果今天要持有股票，应该比较继续持有昨天的股票好，还是今天才开始买股票好            //(此时只交易了一次，所以是今天才买入的)            dp[i][1][1]=Math.max(dp[i-1][1][1],-prices[i]);                        //如果今天持有现金，应该比较昨天持有现金好，还是昨天持有股票加上今天的股价好            dp[i][1][0]=Math.max(dp[i-1][1][0],dp[i-1][1][1]+prices[i]);                        //如果今天要持有股票，应该比较继续持有昨天股票好，还是今天才开始买股票好            //(此时交易了两次，所以用昨天的现金买股票)            dp[i][2][1]=Math.max(dp[i-1][2][1],dp[i-1][1][0]-prices[i]);                        //如果今天要持有现金，应该比较昨天持有现金好，还是昨天持有股票加上今天的股价好            dp[i][2][0]=Math.max(dp[i-1][2][0],dp[i-1][2][1]+prices[i]);        }        return Math.max(dp[len - 1][1][0], dp[len - 1][2][0]);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong>，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></eq>为股票价格数组的长度</p></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong>，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></eq>为股票价格数组的长度</p><p>​</p></li></ul></li></ul><hr><blockquote><p>先更新这么多，后续再补上~</p></blockquote><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS和DFS优先搜索算法</title>
      <link href="/2023/10/05/bfs-he-dfs-you-xian-sou-suo-suan-fa/"/>
      <url>/2023/10/05/bfs-he-dfs-you-xian-sou-suo-suan-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="bfs%E5%92%8Cdfs%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95" tabindex="-1">BFS和DFS优先搜索算法</h3><blockquote><p>前几天做了两道二叉树的问题，现在回头想想还是觉得不太熟练。二叉树是典型的搜索算法，常见的有BFS（层级遍历，但有区别）和DFS两种，下面就写一点自己的总结和看法</p></blockquote><p>​</p><h3 id="bfs(%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95)" tabindex="-1">BFS(广度优先算法)</h3><p><code>BFS</code>（广度优先搜索）是一种图遍历算法，它从一个起始点开始，逐层扩展搜索范围，直到找到目标节点为止。</p><ul><li><p>这种算法通常用于解决“最短路径”问题，比如在迷宫中找到从起点到终点的最短路径。</p><ol><li>首先，你会从起点开始，检查所有与它相邻的位置，也就是距离起点为1的位置。</li><li>然后，你会继续向外扩展，检查所有距离起点为2的位置，以此类推，直到找到出口。</li></ol></li><li><p>在<code>BFS</code>中，你可以<strong>使用队列来存储待搜索的节点</strong>。起始点首先加入队列中，然后不断从队列中取出节点，检查它是否是目标节点。如果不是，就将它的所有未被访问过的邻居加入队列中。这样，队列中的节点总是按照它们距离起点的距离排序，先加入队列的节点总是先被取出来搜索。</p></li><li><p>通过这种方式，<code>BFS</code>可以找到起点到目标节点的<strong>最短路径</strong>。在实际应用中，BFS还可以用于拓<strong>扑排序、连通性检测等问题</strong>的解决。</p></li><li><p>遍历过程如下图：</p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/10/05/bfs-he-dfs-you-xian-sou-suo-suan-fa/bfs.png" alt="bfs" style="zoom:50%;"><p>​</p></li></ul><h4 id="%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86" tabindex="-1">层序遍历</h4><p>层序遍历和广度优先算法还是存在区别的，虽然都是扁平进行搜索，同样是每层按顺序进行排列，但是他们的返回值不一样。</p><ul><li>BFS 遍历使用队列数据结构,BFS 的遍历结果是一个一维数组，无法区分每一层。</li><li>层序遍历要求我们区分每一层，也就是返回一个二维数组。</li></ul><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/10/05/bfs-he-dfs-you-xian-sou-suo-suan-fa/bfs%E5%92%8C%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="bfs和层序遍历" style="zoom:50%;"><p>​</p><h4 id="%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;import java.util.LinkedList;import java.util.List;public class BFSTraversal {    //二叉树的层序遍历    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();        if (root == null) return result;        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root);        while (!queue.isEmpty()) {            int levelSize = queue.size();             //在每一层遍历开始前，先记录队列中的结点数量n（也就是这一层的结点数量），然后一口气处理完这一层的n个结点。将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。            List&lt;Integer&gt; levelNodes = new ArrayList&lt;&gt;();//每一层一个List数组                       for (int i = 0; i &lt; levelSize; i++) {                TreeNode node = queue.poll();                levelNodes.add(node.val);                if (node.left != null)                    queue.offer(node.left);                if (node.right != null)                    queue.offer(node.right);            }            result.add(levelNodes);//[[,]]        }        return result;    }    // 二叉树的广度遍历    public List&lt;Integer&gt; BfsBinary(TreeNode root){        List&lt;Integer&gt; resultList = new ArrayList&lt;&gt;();        if (root == null) return result;                LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.add(root);//offer()比add()稍好，可以对异常处理有所调控,但一般刷题都行        while (!queue.isEmpty()){            TreeNode node = queue.poll();            resultList.add(node.val);            if(node.left != null){                queue.add(node.left);            }            if(node.right != null){                queue.add(node.right);            }        }        return resultList;    }    public static void main(String[] args) {        // 创建一棵二叉树示例        TreeNode root = new TreeNode(1);        root.left = new TreeNode(2);        root.right = new TreeNode(3);        root.left.left = new TreeNode(4);        root.left.right = new TreeNode(5);        // 实例化BFSTraversal对象        BFSTraversal traversal = new BFSTraversal();        // 调用levelOrder方法进行广度优先遍历(但是是层序遍历)，区分每一层，返回二维数组        List&lt;List&lt;Integer&gt;&gt; result = traversal.levelOrder(root);        // 输出结果        System.out.println("层序遍历输出："+result);        //广度优先搜索，BFS 的遍历结果是一个一维数组，无法区分每一层        BFSTraversal t=new BFSTraversal();        List&lt;Integer&gt; result1=t.BfsBinary(root);        System.out.println("Bfs遍历输出："+result1);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>运行结果如图所示</strong>：</p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/10/05/bfs-he-dfs-you-xian-sou-suo-suan-fa/result.jpg" alt="result" style="zoom:50%;"><p>​</p></li></ul><h3 id="dfs(%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95)" tabindex="-1">DFS(深度优先搜索算法)</h3><p><code>DFS</code>（深度优先搜索）是一种图遍历算法，它从一个起始点开始，一直往下走直到不能再走为止，然后返回到前一个节点，继续探索它的其他分支，直到找到目标节点为止。</p><ul><li><p>这种算法通常用于解决“遍历”问题，比如在树中查找所有的叶子节点。要理解DFS，也还可以想象自己在迷宫中寻找所有可行的路径。</p><ol><li>首先，你会从起点开始，顺着一条路一直走，直到你走到一个死胡同</li><li>再返回到前一个节点，继续探索其他分支</li><li>在探索过程中，你可以<strong>使用栈来存储已经访问过的节点，以便后续回溯</strong>。</li></ol></li><li><p>在<code>DFS</code>中，你可以使用递归或栈来实现深度优先搜索。通过这种方式，<code>DFS</code>可以找到所有可行的路径，或者在树中查找所有的叶子节点。</p></li><li><p>在实际应用中，<code>DFS</code>还可以用于拓扑排序、连通性检测等问题的解决。与<code>BFS</code>相比，<code>DFS</code>通常更适合处理深度优先的问题，而<code>BFS</code>更适合处理广度优先的问题。</p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/10/05/bfs-he-dfs-you-xian-sou-suo-suan-fa/dfs.png" alt="dfs" style="zoom:50%;"><p>​</p></li></ul><h4 id="%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81-1" tabindex="-1">具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.*;//dfs深度优先,以二叉树的前序遍历为例class TreeNode {    int val;    TreeNode left;    TreeNode right;    TreeNode(int val) {        this.val = val;    }}class PreorderTraversal {    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        if (root == null) return result;        dfs(root, result);        return result;    }    private void dfs(TreeNode root, List&lt;Integer&gt; result) {//递归，隐含地调用系统的栈，递归地调用左右子树，最后将值存储在result序列中。        if (root == null) return;        result.add(root.val);        dfs(root.left, result);        dfs(root.right, result);    }    public static void main(String[] args) {        // 创建一棵二叉树示例        TreeNode root = new TreeNode(1);        root.left = new TreeNode(2);        root.right = new TreeNode(3);        root.left.left = new TreeNode(4);        root.left.right = new TreeNode(5);        // 实例化PreorderTraversal对象        PreorderTraversal traversal = new PreorderTraversal();        // 调用preorderTraversal方法进行前序遍历（dfs）        List&lt;Integer&gt; result = traversal.preorderTraversal(root);        // 输出结果        System.out.println("DFS遍历输出："+result);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>运行结果如图所示</strong>：</li></ul><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/10/05/bfs-he-dfs-you-xian-sou-suo-suan-fa/result2.jpg" alt="result2" style="zoom:50%;"><p>​</p><h4 id="dfs%E4%B8%80%E9%81%93%E4%BE%8B%E9%A2%98%EF%BC%9A" tabindex="-1">DFS一道例题：</h4><ul><li><p><a href="https://leetcode.cn/problems/3Etpl5/description/">LCR 049. 求根节点到叶节点数字之和 </a></p><p>​</p></li></ul><h5 id="%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E%EF%BC%9A" tabindex="-1">题目说明：</h5><p>给定一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p><p>每条从根节点到叶节点的路径都代表一个数字：</p><ul><li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</li></ul><p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p><p><strong>叶节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/10/05/bfs-he-dfs-you-xian-sou-suo-suan-fa/num1tree.jpg" alt="num1tree" style="zoom:50%;"><pre class="line-numbers language-none"><code class="language-none">输入：root = [1,2,3]输出：25解释：从根到叶子节点路径 1-&gt;2 代表数字 12从根到叶子节点路径 1-&gt;3 代表数字 13因此，数字总和 = 12 + 13 = 25<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><h5 id="%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">解答分析</h5><ul><li><p>该如何计算路径中表示的数字呢？顺着子节点的指针路径向下遍历二叉树，每达到一个节点，相当于在路径表示的数字末尾添加一位数字。</p></li><li><p>对于每次遍历都是<code>path=path*10+root.val;</code>仔细观察可以看出应该是典型的二叉树前序遍历，每个得出的数字都是计算当前节点的路径到头，最后再计算子节点的路径表示的数字。</p></li><li><p>利用<code>dfs</code>实现的是递归调用，这里注意<strong>三部曲</strong>：</p><ul><li><strong>找到最后递归的终止条件</strong></li><li><strong>找到上一次递归的返回值</strong></li><li><strong>找到本次递归的具体操作</strong></li></ul><p>​</p></li></ul><h5 id="%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81-2" tabindex="-1">具体代码</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution{public int sumNumbers(TreeNode root){   return dfs(root,0);//输入的数和数字结果}private int dfs(){//每一次遍历到当前路径尽头 if(root==null){//终止条件            return 0;        }        //本次递归级的具体操作        path=path*10+root.val;//当前递归中的每次数字的统计        if(root.left==null &amp;&amp; root.right==null){            return path;        }        return dfs(root.left,path)+dfs(root.right,path);//上一级返回值}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><p>​</p><hr><h3 id="bfs%E5%92%8Cdfs%E7%9A%84%E5%8A%A8%E5%9B%BE%E6%AF%94%E5%AF%B9" tabindex="-1">BFS和DFS的动图比对</h3><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/10/05/bfs-he-dfs-you-xian-sou-suo-suan-fa/DFS%20AND%20BFS.gif" alt="DFS AND BFS" style="zoom:50%;"><hr><center><span style="color:orange;font-size:30px;">End~</span></center><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优先搜索 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双周赛114</title>
      <link href="/2023/10/04/shuang-zhou-sai-114/"/>
      <url>/2023/10/04/shuang-zhou-sai-114/</url>
      
        <content type="html"><![CDATA[<h3 id="%E5%8F%8C%E5%91%A8%E8%B5%9B114" tabindex="-1">双周赛114</h3><blockquote><p>本次双周赛没参加，刚好碰上中秋国庆双假期，出去玩了一趟。今天写点博客，把本次周赛的题目研究研究。</p></blockquote><h3 id="t1.%E6%94%B6%E9%9B%86%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0" tabindex="-1">T1.<a href="https://leetcode.cn/problems/minimum-operations-to-collect-elements/">收集元素的最少操作次数</a></h3><h4 id="1.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1.1 题目说明</h4><p>给你一个正整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p><p>一次操作中，你可以将数组的最后一个元素删除，将该元素添加到一个集合中。</p><p>请你返回收集元素 <code>1, 2, ..., k</code> 需要的 <strong>最少操作次数</strong> 。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [3,1,5,4,2], k = 2输出：4解释：4 次操作后，集合中的元素依次添加了 2 ，4 ，5 和 1 。此时集合中包含元素 1 和 2 ，所以答案为 4 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= nums.length &lt;= 50</code></p></li><li><p><code>1 &lt;= nums[i] &lt;= nums.length</code></p></li><li><p><code>1 &lt;= k &lt;= nums.length</code></p></li><li><p>输入保证你可以收集到元素 <code>1, 2, ..., k</code> 。</p><p>​</p></li></ul><hr><h4 id="1.2-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">1.2 解答分析</h4><ul><li><p>需要找到最小的操作次数，从后向前遍历数组中的元素即可</p></li><li><p>注意需要记录两部分</p><ul><li>遍历过的元素。设置<code>flag</code>进行记录</li><li>元素值不超过<code>k</code>的元素，如<code>k==3</code>,则需要记录<code>1,2,3</code></li></ul><p>​</p></li></ul><hr><h4 id="1.3-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">1.3 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int minOperations(List&lt;Integer&gt; nums, int k) {        int n=nums.size();        int[] arr=new int[n];        int offset=0;        for(int p :nums){            arr[offset++]=p;//将num中的每个元素进行遍历记录        }        boolean[] isUsed=new boolean[k+1];//判断当前的元素是否被遍历到了，长度是k+1,包含值为k的元素        int time=0;//判断需要遍历的次数        for(int i=n-1;i&gt;=0;i--){            time++;            if(arr[i]&lt;isUsed.length &amp;&amp; !isUsed[arr[i]]){//如果当前的元素没有被遍历过，并且值小于等于k                isUsed[arr[i]]=true;//标记                k--;                if(k==0){//说明已经对k操作完成了                    return time;//返回需要这样操作的次数                }            }        }        return -1;//否则返回错误值：-1    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>复杂度分析：</strong><ul><li><strong>时间复杂度：</strong> <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>，仅遍历了<code>nums</code>数组，为其长度</li><li><strong>空间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></eq>，其中k为给定的参数。主要占用空间的是两个数组：<code>arr</code>和<code>isUsed</code>。数组<code>arr</code>的长度为n，而数组<code>isUsed</code>的长度为k+1。因此，整体空间复杂度可以视为O(k)。</li></ul></li></ul><p>​</p><hr><h3 id="t2.%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E5%89%B2%E6%88%90%E6%9C%80%E5%A4%9A%E6%95%B0%E7%9B%AE%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84" tabindex="-1">T2.<a href="https://leetcode.cn/problems/split-array-into-maximum-number-of-subarrays/">将数组分割成最多数目的子数组</a></h3><h4 id="2.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">2.1 题目说明</h4><p>给你一个只包含 <strong>非负</strong> 整数的数组 <code>nums</code> 。</p><p>我们定义满足 <code>l &lt;= r</code> 的子数组 <code>nums[l..r]</code> 的分数为 <code>nums[l] AND nums[l + 1] AND ... AND nums[r]</code> ，其中 <strong>AND</strong> 是按位与运算。</p><p>请你将数组分割成一个或者更多子数组，满足：</p><ul><li><strong>每个</strong> 元素都 <strong>只</strong> 属于一个子数组。</li><li>子数组分数之和尽可能 <strong>小</strong> 。</li></ul><p>请你在满足以上要求的条件下，返回 <strong>最多</strong> 可以得到多少个子数组。</p><p>一个 <strong>子数组</strong> 是一个数组中一段连续的元素。</p><p>​</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,0,2,0,1,2]输出：3解释：我们可以将数组分割成以下子数组：- [1,0] 。子数组分数为 1 AND 0 = 0 。- [2,0] 。子数组分数为 2 AND 0 = 0 。- [1,2] 。子数组分数为 1 AND 2 = 0 。分数之和为 0 + 0 + 0 = 0 ，是我们可以得到的最小分数之和。在分数之和为 0 的前提下，最多可以将数组分割成 3 个子数组。所以返回 3 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [5,7,1,3]输出：1解释：我们可以将数组分割成一个子数组：[5,7,1,3] ，分数为 1 ，这是可以得到的最小总分数。在总分数为 1 的前提下，最多可以将数组分割成 1 个子数组。所以返回 1 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i] &lt;= 106</code></li></ul><p>​</p><hr><h4 id="2.2-%E5%88%86%E6%9E%90%E8%A7%A3%E7%AD%94" tabindex="-1">2.2 分析解答</h4><ul><li><p>显然需要利用到<code>贪心</code>算法操作，由于是<code>与</code>的操作，所以一方面是要找到<code>0</code>,另外一方面是需要尽可能地延长子数组的长度，子数组越长，取到<code>AND</code>为<code>0</code>的概率就会越大。</p><ul><li>如果整个数组取<code>AND</code>结果不为<code>0</code>，那么返回<code>1</code> （按照<code>AND</code>的要求，更短的子数组是没办法获取比最后结果更小的结果）。</li><li>如果是<code>0</code>，那么从队尾开始遍历数组，寻找到第一个能使得后缀数组取<code>AND</code>为<code>0</code>的位置。</li><li>最后从头开始遍历数组，并且贪婪地（<code>AND</code>性质，子数组越长，那么取<code>AND</code>结果是<code>0</code>的可能越大。）寻找最大可能情况。</li></ul></li><li><p><strong>注意需要返回的是子数组的个数</strong></p><p>​</p></li></ul><hr><h4 id="2.3-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">2.3 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int maxSubarrays(int[] nums) {        int sumAnd=nums[0];        for(int n:nums){            sumAnd &amp;=n;//计算全部元素相与的结果        }        if(sumAnd!=0){//如果此时全部元素相与都不为0，那么说明此时只能分为1个子数组            return 1;        }        //如果说存在0的情况        int m=nums.length;        sumAnd=nums[m-1];//sumAnd为最后一个元素值        int LastZero=m-1;//最后一个元素的位置        for(int i=m-1;i&gt;=0;i--){            sumAnd&amp;=nums[i];            if(sumAnd==0){                LastZero=i;//更新，找到最后的0的位置                break;            }        }        //从数组头元素重新开始        sumAnd=nums[0];        int res=0;        for(int i=0;i&lt;nums.length;i++){//注意需要讨论最后一个元素，每次循环都要将当前元素与sumAnd进行按位与操作。            sumAnd&amp;=nums[i];            if(sumAnd==0){                res++;                if(i+1&lt;=LastZero){//此时i不大于LastZero前一个位置时，继续更新sumAnd                    sumAnd=nums[i+1];                }else{                    break;                }            }        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>复杂度分析：</strong><ul><li><p><strong>时间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>，都是遍历数组，进行循环的操作，自然是数组的长度<code>n</code>。</p></li><li><p><strong>空间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq>，并没有引入额外的存储空间。</p><p>​</p></li></ul></li></ul><hr><h3 id="t3.-%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%BA%E7%A9%BA%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0" tabindex="-1">T3. <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-empty/">使数组为空的最少操作次数</a></h3><h4 id="3.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">3.1 题目说明</h4><p>给你一个下标从 <strong>0</strong> 开始的正整数数组 <code>nums</code> 。</p><p>你可以对数组执行以下两种操作 <strong>任意次</strong> ：</p><ul><li>从数组中选择 <strong>两个</strong> 值 <strong>相等</strong> 的元素，并将它们从数组中 <strong>删除</strong> 。</li><li>从数组中选择 <strong>三个</strong> 值 <strong>相等</strong> 的元素，并将它们从数组中 <strong>删除</strong> 。</li></ul><p>请你返回使数组为空的 <strong>最少</strong> 操作次数，如果无法达成，请返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [2,3,3,2,2,4,2,3,4]输出：4解释：我们可以执行以下操作使数组为空：- 对下标为 0 和 3 的元素执行第一种操作，得到 nums = [3,3,2,4,2,3,4] 。- 对下标为 2 和 4 的元素执行第一种操作，得到 nums = [3,3,4,3,4] 。- 对下标为 0 ，1 和 3 的元素执行第二种操作，得到 nums = [4,4] 。- 对下标为 0 和 1 的元素执行第一种操作，得到 nums = [] 。至少需要 4 步操作使数组为空。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [2,1,2,2,3,3]输出：-1解释：无法使数组为空。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><p><code>2 &lt;= nums.length &lt;= 105</code></p></li><li><p><code>1 &lt;= nums[i] &lt;= 106</code></p><p>​</p></li></ul><hr><h4 id="3.2-%E5%88%86%E6%9E%90%E8%A7%A3%E7%AD%94" tabindex="-1">3.2 分析解答</h4><ul><li><p>想法是先统计每个元素的值出现的次数，此时需要用到的是<code>HashMap</code>的数据结构。</p></li><li><p>再通过遍历每个元素值出现的次数进行讨论，如果为1则直接返回-1，如果不是1，根据贪心思想，最后求出结果。（从3开始，2即可）</p><p>​</p></li></ul><hr><h4 id="3.3-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3.3 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int minOperations(int[] nums) {        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int num : nums) {            map.put(num, map.getOrDefault(num, 0) + 1);        }        int ans = 0;        for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {//返回一个Set集合，其中包含了Map中所有的键值对。每个键值对都是一个Map.Entry对象            int num = entry.getValue();//可以获取到该值            if (num == 1) {//出现1次                return -1;            } else {                while (num % 3 != 0) {                    num -= 2;                    ans++;                }                ans += num / 3;            }        }        return ans;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：</strong> <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><ol><li>遍历nums数组并构建HashMap：O(n)，其中n为数组的长度。</li><li>遍历map.entrySet()，即遍历map中的键值对：O(m)，其中m为map中不同元素的个数，最坏情况下为n（每个元素都不同）。</li><li>在循环体内执行一些常数时间的操作，包括判断、减法、除法等：O(1)。</li><li>总体时间复杂度为O(n + m)。</li></ol></blockquote></li><li><p><strong>空间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><ol><li>使用了一个HashMap存储元素出现次数：最坏情况下空间复杂度为O(n)，即所有元素都不同。</li><li>使用了常数级别的额外空间：O(1)。</li><li>总体空间复杂度为O(n)。</li></ol></blockquote><p>​</p></li></ul></li></ul><hr><h3 id="t4.-%E5%8F%AF%E4%BB%A5%E8%A2%AB-k-%E6%95%B4%E9%99%A4%E8%BF%9E%E9%80%9A%E5%9D%97%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE" tabindex="-1">T4. <a href="https://leetcode.cn/problems/maximum-number-of-k-divisible-components/description/">可以被 K 整除连通块的最大数目</a></h3><h4 id="4.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">4.1 题目说明</h4><p>给你一棵 <code>n</code> 个节点的无向树，节点编号为 <code>0</code> 到 <code>n - 1</code> 。给你整数 <code>n</code> 和一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 有一条边。</p><p>同时给你一个下标从 <strong>0</strong> 开始长度为 <code>n</code> 的整数数组 <code>values</code> ，其中 <code>values[i]</code> 是第 <code>i</code> 个节点的 <strong>值</strong> 。再给你一个整数 <code>k</code> 。</p><p>你可以从树中删除一些边，也可以一条边也不删，得到若干连通块。一个 <strong>连通块的值</strong> 定义为连通块中所有节点值之和。如果所有连通块的值都可以被 <code>k</code> 整除，那么我们说这是一个 <strong>合法分割</strong> 。</p><p>请你返回所有合法分割中，<strong>连通块数目的最大值</strong> 。</p><p><strong>示例 1：</strong></p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/10/04/shuang-zhou-sai-114/4.1.jpg" alt="4.1" style="zoom:67%;"><pre class="line-numbers language-none"><code class="language-none">输入：n = 5, edges = [[0,2],[1,2],[1,3],[2,4]], values = [1,8,1,4,4], k = 6输出：2解释：我们删除节点 1 和 2 之间的边。这是一个合法分割，因为：- 节点 1 和 3 所在连通块的值为 values[1] + values[3] = 12 。- 节点 0 ，2 和 4 所在连通块的值为 values[0] + values[2] + values[4] = 6 。最多可以得到 2 个连通块的合法分割。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><hr><h4 id="4.2-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">4.2 解答分析</h4><ul><li><p>我们其实需要寻找的是一些边，去除这些边之后，分裂的左右两侧子树仍然被k整除。</p><ul><li>n：表示树的大小；</li><li>_edges：表示树中的边，其中_edges[i] = [u, v]表示树中存在一条连接u和v的边；</li><li>values：一个长度为n的数组，values[i]表示第i个节点的整数值；</li><li>k：一个整数，表示需要被整除的值。</li></ul><p>​</p></li></ul><hr><h4 id="4.3-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">4.3 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    private List&lt;Integer&gt;[] edges;    private int[] values;    private int k;    public int maxKDivisibleComponents(int n, int[][] _edges, int[] values, int k) {        edges = new List[n];        for (int i = 0; i &lt; n; ++i) {            edges[i] = new ArrayList&lt;&gt;();        }        for (int[] e : _edges) {            edges[e[0]].add(e[1]);            edges[e[1]].add(e[0]);        }        this.values = values;        this.k = k;        int[] res = {0};        dfs(0, -1, res);        return res[0];    }    //该函数的实现使用了DFS搜索，定义了一个辅助函数dfs，dfs(cur, pre, res)表示在以cur为根节点、pre为cur的父节点时，子树中所有节点值之和对k取余数的结果。在dfs遍历时，若当前节点的值可以和子树中某个节点值之和整除k，则累加答案res[0]。    private int dfs(int cur, int pre, int[] res) {        int sum = values[cur] % k;        for (int n : edges[cur]) {            if (n != pre) {                sum = (sum + dfs(n, cur, res)) % k;            }        }        if (sum == 0) {            res[0] += 1;        }        return sum;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>复杂度分析：</strong><ul><li><p><strong>时间复杂度：</strong> <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>，其中<code>n</code>为树的大小</p></li><li><p><strong>空间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>，我们需要存储整棵树的边和每个节点的值</p><p>​</p></li></ul></li></ul><blockquote><p>后续需要继续加强算法思想的体会。当前的主要任务还是把常见的算法都多熟悉，如dfs、bfs、dp、贪心等，这些都是解题思路的关键。</p></blockquote><center><span style="color:orange;font-size:20px;">加油！奥力给😘~</span></center><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>京东0923秋招笔试</title>
      <link href="/2023/09/28/jing-dong-0923-qiu-zhao-bi-shi/"/>
      <url>/2023/09/28/jing-dong-0923-qiu-zhao-bi-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="%E4%BA%AC%E4%B8%9C0923%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95" tabindex="-1">京东0923秋招笔试</h3><blockquote><p>最近挺忙的，一方面是学业方面的实验任务；另一方面是实习任务加重了，Leader休年假，在放假之前布置了很多任务。这两天干了挺多的。现在接着看看秋招笔记，把真题做一下。</p></blockquote><h3 id="0923.t1" tabindex="-1">0923.T1</h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h4><p>小红需要n个不同的魔法药剂，她可以从商店以ai的价格购买第i种红色版本魔法药剂，也可以用两种其他的红色版本药剂配置蓝色版本 小红想知道，她最少需要花多少钱才能得到1到n个不同的魔法药剂，蓝色或者红色都可以。</p><p><strong>输入描述</strong></p><p>第一行输入一个整数n，表示魔法药剂数量。</p><p>第二行输入n个整数ai，表示第i种红色版本魔法药剂的价格。</p><p>接下来n行，每行两个整数bi和ci，表示用第 bi 种和第 ci 种红色版本魔法药剂配置第 i 种蓝色版本魔法药剂。</p><p>1&lt;= n &lt;=1e5</p><p>1&lt;= ai &lt;=1e4</p><p>1&lt;= bi,ci &lt;= n</p><p><strong>输出描述</strong></p><p>输出一个整数，表示最少需要花多少钱才能得到1到n个不同的魔法药剂，蓝色或者红色都可以。</p><p><strong>示例1</strong></p><p><strong>输入</strong></p><pre class="line-numbers language-none"><code class="language-none">52 4 10 1 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>输出</strong></p><pre class="line-numbers language-none"><code class="language-none">16<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>说明</strong></p><p>红色药剂的价格分别为[2, 4, 10, 1, 3]。</p><p>蓝色药剂的价格分别为[14, 4, 6, 7, 3]。<code>这里注意蓝色药剂合成用到的红色试剂的种类，给定的顺序即可</code></p><p>配置第三种蓝色药剂，其他都购买红色药剂花费 16</p><h4 id="2.-%E5%88%86%E6%9E%90%E8%A7%A3%E7%AD%94" tabindex="-1">2. 分析解答</h4><ul><li>其中，<code>n</code>表示魔法药剂数量，<code>ai</code>表示第<code>i</code>种红色版本魔法药剂的价格，<code>bi</code>和<code>ci</code>表示用第<code>bi</code>种和第<code>ci</code>种红色版本魔法药剂配置第i种蓝色版本魔法药剂。在运行代码后，它将输出最少花费的结果。</li><li>思路是简单的模拟，哪种做法便宜用哪个。</li><li>处理思路是使用贪心算法，首先将红色药剂价格和蓝色药剂价格分别存储在两个List中。接着，遍历每一个蓝色药剂，计算用哪两种红色药剂来组合可以得到最小价格，将该价格存储在price List中。最后，遍历price List，将各个价格累加起来，即为最终的答案。</li></ul><h4 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3. 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.*;public class title1 {        public static void main(String[] args) {            Scanner scanner=new Scanner(System.in);            int n = scanner.nextInt();            List&lt;Long&gt; red = new ArrayList&lt;&gt;();            List&lt;Long&gt; price = new ArrayList&lt;&gt;();            for (int i = 0; i &lt; n; i++) {                red.add(scanner.nextLong());                price.add(1000005L);            }            List&lt;List&lt;Long&gt;&gt; blue = new ArrayList&lt;&gt;();            for (int i = 0; i &lt; n; i++) {                List&lt;Long&gt; temp = new ArrayList&lt;&gt;();                temp.add(scanner.nextLong());                temp.add(scanner.nextLong());                temp.set(0, temp.get(0) - 1);                temp.set(1, temp.get(1) - 1);                blue.add(temp);            }            for (int i = 0; i &lt; n; i++) {                long minPrice = Math.min(red.get(i), red.get(blue.get(i).get(0).intValue()) + red.get(blue.get(i).get(1).intValue()));                price.set(i, minPrice);            }            long ans = 0;            for (long x : price) {                ans += x;            }            System.out.println(ans);        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p></li><li><p><strong>空间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><p>因为需要用List来存储红色药剂价格、蓝色药剂价格和最小价格。但是由于n的范围比较小，所以空间复杂度不会是问题。</p></blockquote></li></ul></li></ul><h3 id="0923.t2" tabindex="-1">0923.T2</h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E-1" tabindex="-1">1. 题目说明</h4><p>小红有一个长度为n的数组。如果存在一个长度为3的子数组，使得a_i &lt;= a_i+1 &lt;= a_i+2，那么这个数组就是有趣的。每次操作可以修改数组的一个值，请问最少需要几次操作才能使得这个数组变得不有趣</p><p><strong>输入描述</strong></p><p>第一行输入一个整数n，表示数组的长度。第二行输入几个整数a1, a2，···，an，表示数组的初始值。</p><p>1&lt;= n &lt;=1e5   1&lt;= ai &lt;= 1e9</p><p><strong>输出描述</strong></p><p>输出一个整数，表示答案</p><p><strong>示例</strong></p><p><strong>输入</strong></p><pre class="line-numbers language-none"><code class="language-none">56 2 4 5 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>输出</strong></p><pre class="line-numbers language-none"><code class="language-none">1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h4><ul><li><p>贪心+找规律</p></li><li><p>首先找出所有连续的有趣子数组，记录其长度；</p></li><li><p>对于递增子数组，可以通过将其中间的数改为一个较大值进行破坏，可以证明破坏边缘不如破坏中间；</p><blockquote><p>长度为3，需要1次；</p><p>长度为4，需要1次；</p><p>长度为5，相当于破坏1次+长度为3；</p><p>长度为6，相当于破坏一次+长度为4；</p><p>找规律为 破坏次数 = （(连续递增子数组长度 - 1 ) / 2），累加就行了</p></blockquote></li></ul><h4 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81-1" tabindex="-1">3. 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;import java.util.Scanner;import java.util.List;public class title2 {    public static void main(String[] args){        Scanner in=new Scanner(System.in);        int n=in.nextInt();        List&lt;Integer&gt; arr=new ArrayList&lt;&gt;();        for(int i=0;i&lt;n;i++){            arr.add(in.nextInt());        }        List&lt;Integer&gt;nums=new ArrayList&lt;&gt;();        int len=1,ans=0;        for(int i=1;i&lt;n;i++) {//从第二个元素开始迭代            if (arr.get(i) &gt;= arr.get(i - 1)) {                len++;//记录最长的子数组的长度            } else {//遇到非递增子数组时，判断此时的子数组的长度大于3即可                if (len &gt;= 3) {                    nums.add(len);                    len = 0;                }            }        }            if(len&gt;=3){                nums.add(len);//检查最后的序列            }            for(int x:nums){//遍历每个满足的子数组的长度，从中间的元素开始进行替换                ans+=(x-1)/2;//3个改一个，4个改中间1个，5个改1个+3个的情况...            }        System.out.println(ans);        in.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>复杂度分析：</strong><ul><li><strong>时间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq> 两个<code>for</code>循环，其中<code>n</code>是数组的长度。</li><li><strong>空间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq> 因为需要用到<code>List</code>存储数组元素和子数组长度。</li></ul></li></ul><blockquote><p>写这么多吧，准备睡觉了hhh~</p></blockquote><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 笔试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023大厂秋招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 376.摆动序列</title>
      <link href="/2023/09/24/leetcode-376-bai-dong-xu-lie/"/>
      <url>/2023/09/24/leetcode-376-bai-dong-xu-lie/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-376.-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97" tabindex="-1"><a href="https://leetcode.cn/problems/wiggle-subsequence/">Leetcode 376. 摆动序列</a></h3><blockquote><p>以后就分类进行刷题，包含课程和代码随想录中的部分题目。形成一定的大纲和刷题的思路。</p></blockquote><p>​</p><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为<strong>摆动序列</strong>。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li><li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li></ul><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,7,4,9,2,5]输出：6解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,17,5,10,13,15,10,5,16,8]输出：7解释：这个序列包含几个长度为 7 摆动序列。其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,2,3,4,5,6,7,8,9]输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​</p><hr><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><h4 id="2.1-%E6%80%9D%E8%B7%AF1%EF%BC%88%E8%B4%AA%E5%BF%83%E8%A7%A3%E6%B3%95%EF%BC%89" tabindex="-1">2.1 思路1（贪心解法）</h4><ul><li><p>对题目要求的分析就是通过从原始序列中删除（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序，其实要求就是下图所示即可。</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124174327597.png" alt="376.摆动序列"></p><blockquote><p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。</p><p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong>。</p><p>局部最优可以推出全局最优，并无法举出反例，那么可以试试贪心。</p></blockquote></li><li><p>实际上的操作并不用删除元素，而是统计峰值的数量就行。定义两个指针<code>prediff(nums[i]-nums[i-1])</code>和<code>curdiff(nums[i+1]-nums[i])</code>.</p><p>这里可能会出现3中情况，如下：</p><ul><li><p>上下坡中有平坡</p><blockquote><p>前一个指针可能为0，比如[1,2,2,2,1]的情况，需要将中间的3个2进行判断比较。</p></blockquote></li><li><p>数组首尾两端</p><blockquote><p>统计峰值的时候，数组最左边和最右边可能是波峰或者波谷。</p></blockquote></li><li><p>单调坡度有平坡</p><blockquote><p>如果在一个单调坡度上有平坡，例如[1,2,2,2,3,4]。可以看出，如果是在前后变化的时候进行峰值的记录，那么会在第3个2的地方进行记录，但是此时并不是最长的峰值，所以我们需要另外更新<code>preDiff</code>的变化位置。需要在摆动进行变化的时候进行更新。</p></blockquote></li></ul></li><li><h4 id="2.2-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89" tabindex="-1">2.2 具体代码（贪心）</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int wiggleMaxLength(int[] nums) {        if (nums.length &lt;= 1) {            return nums.length;        }        //当前差值        int curDiff = 0;        //上一个差值        int preDiff = 0;        int count = 1; //峰值的个数，序列默认序列的最右边有一个峰值        for (int i = 1; i &lt; nums.length; i++) {            //得到当前差值            curDiff = nums[i] - nums[i - 1];            //如果当前差值和上一个差值为一正一负            //等于0的情况表示初始时的preDiff            if ((curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0) || (curDiff &lt; 0 &amp;&amp; preDiff &gt;= 0)) {                count++;                preDiff = curDiff;// 注意这里，只在摆动变化的时候更新prediff            }        }        return count;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq></strong>,由于对数组进行遍历，数组的长度为<code>N</code>.</p></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq></strong>,并未引入额外的存储空间。</p></li></ul></li></ul><hr><h4 id="2.3-%E6%80%9D%E8%B7%AF2%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89" tabindex="-1">2.3 思路2（动态规划）</h4><ul><li><p>本题之所以可以想到动态规划，实际上是由于每一处的峰值都需要和前面的状态进行比较，如果是需要考虑个数。要么作为山峰(即<code>nums[i]&gt;nums[i-1]</code>)，要么作为山谷(即<code>nums[i]&lt;nums[i-1]</code>)</p><ul><li>设 dp 状态<code>dp[i][0]</code>，表示考虑前 i 个数，第 i 个数作为山峰的摆动子序列的最长长度</li><li>设 dp 状态<code>dp[i][1]</code>，表示考虑前 i 个数，第 i 个数作为山谷的摆动子序列的最长长度</li></ul><p>则转移方程为：</p><ul><li><code>dp[i][0] = max(dp[i][0], dp[j][1] + 1)</code>，其中<code>0 &lt; j &lt; i</code>且<code>nums[j] &lt; nums[i]</code>，表示将 nums[i]接到前面某个山谷后面，作为山峰。</li><li><code>dp[i][1] = max(dp[i][1], dp[j][0] + 1)</code>，其中<code>0 &lt; j &lt; i</code>且<code>nums[j] &gt; nums[i]</code>，表示将 nums[i]接到前面某个山峰后面，作为山谷。</li></ul></li><li><p><strong>初始状态</strong></p><ul><li>由于一个属可以接到前面的某个数后面，也可以自身为子序列的期典，所以初始的状态为：<code>dp[0][0]=dp[0][1]=1</code></li></ul></li></ul><p>​</p><h4 id="2.4-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%EF%BC%88dp%EF%BC%89" tabindex="-1">2.4 具体代码（dp）</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">// DPclass Solution {    public int wiggleMaxLength(int[] nums) {        // 0 i 作为波峰的最大长度        // 1 i 作为波谷的最大长度        int dp[][] = new int[nums.length][2];        dp[0][0] = dp[0][1] = 1;        for (int i = 1; i &lt; nums.length; i++){            //i 自己可以成为波峰或者波谷            dp[i][0] = dp[i][1] = 1;            for (int j = 0; j &lt; i; j++){                if (nums[j] &gt; nums[i]){                    // i 是波谷                    dp[i][1] = Math.max(dp[i][1], dp[j][0] + 1);                }                if (nums[j] &lt; nums[i]){                    // i 是波峰                    dp[i][0] = Math.max(dp[i][0], dp[j][1] + 1);                }            }        }        return Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析：</strong></p></li><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq></strong> 两个<code>for</code>循环，总共进行力<code>n(n-1)/2</code>次比较操作。</p></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong> 二维数组保存每个位置。</p></li></ul><blockquote><center><span style="color:#e324;font-size:2em;">END~</span></center></blockquote><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为0920/0923秋招笔试</title>
      <link href="/2023/09/23/hua-wei-0920-0923-qiu-zhao-bi-shi/"/>
      <url>/2023/09/23/hua-wei-0920-0923-qiu-zhao-bi-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="%E5%8D%8E%E4%B8%BA0920%2F0923%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95" tabindex="-1">华为0920/0923秋招笔试</h3><blockquote><p>开启这个系列，主要是对大厂的笔试的刷题模式进行熟悉，每次的摘录会选择自己理解并有所思考的题目，也算是一种总结思考。</p></blockquote><p>​</p><h3 id="0920.t1-%E4%B8%A2%E5%A4%B1%E6%8A%A5%E6%96%87%E7%9A%84%E4%BD%8D%E7%BD%AE" tabindex="-1">0920.T1 丢失报文的位置</h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h4><p>某通信系统持续向外发送报文，使用数组<code>nums</code>保存<code>n</code>个最近发送的报文，用于在报文未达到对端的情况下重发。报文使用序号<code>sn</code>表示，序号<code>sn</code>按照报文发送顺序从小到大排序，相邻报文<code>sn</code>不完全连续且有可能相同。报文使用循环覆盖的方式保存，即<code>nums</code>数组填满后，从头开始保存新的报文。假设需要重发序号为<code>sn</code>的报文。请找出序号为<code>sn</code>的报文在数组中的开始位置和结束位置。</p><p><strong>解答要求</strong></p><p>时间限制:C/C<ins>1000ms,其他语言: 2000ms内存限制: C/C</ins>256MB其他语言:512MB</p><p><strong>输入</strong></p><pre class="line-numbers language-none"><code class="language-none">第一行输入:数组nums的大小n，取值范围[0,10000]第二行输入:数组中的所有报文的序号sn，sn取值范围[0,100000]。第三行输入:需要重发的报文序号sn，取值范围[0,100000]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>输出</strong></p><pre class="line-numbers language-none"><code class="language-none">start end<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>说明:</strong></p><p><code>start</code>和<code>end</code>代表需要重发的报文序号<code>sn</code>在数组中的起始下标和结束下标</p><p><strong>样例1</strong></p><p><strong>输入:</strong></p><pre class="line-numbers language-none"><code class="language-none">70 0 1 2 2 5 61<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>输出:</strong></p><pre class="line-numbers language-none"><code class="language-none">2 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>解释</strong>：</p><pre class="line-numbers language-none"><code class="language-none">nums数组大小为7保存了7个报文，sn分别是0 0 1 2 2 5 6sn为1的报文在数组中仅有1个，下标是2，因此输出22<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​</p><h4 id="2.-%E5%88%86%E6%9E%90%E8%A7%A3%E7%AD%94" tabindex="-1">2. 分析解答</h4><ul><li><p>找到特定的元素的下标，返回其在数组中的特定位置，也就是最初出现的位置和最后出现的位置。不难想到是从最小值开始进行遍历，以数组的大小为窗口，不断进行取余的运算(确保最后的元素可以连续不断填充)。</p><p>​</p></li></ul><h4 id="3.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" tabindex="-1">3.完整代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class title1 {    public static void main(String[] arg){        int n,sn;        Scanner in=new Scanner(System.in);        n=in.nextInt();//数组nums的长度        int[] nums=new int[n];        for(int i=0;i&lt;n;i++){            nums[i]=in.nextInt();//输入数组的元素        }        sn=in.nextInt();//确定的元素的值        int minIndex=0,minValue=nums[0];//从最数组最初值开始遍历        for(int i=0;i&lt;n;i++){            if(nums[i]&lt;minValue){                minIndex=i;//最小值下标                minValue=nums[i];//最小值            }        }        int start=-1,end=-1;//记录开始和结束位置        for(int i=0;i&lt;n;i++){            int index=(minIndex+i)%n;//遍历当前的下标            if(nums[index]==sn) {//找到需要的元素值得下标                if (start == -1) {//首次                    start = index;                    end = index;                } else {//不是首次的话，只用返回更新end指针即可                    end = index;                }            }        }        System.out.println(start+ " " + end);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>现实笔试中是需要完整的代码演示的，所以需要更加谨慎认真，对每个限定条件都进行判定。</p><p>​</p></li></ul><h3 id="0920.t2-%E5%BF%AB%E9%80%9F%E4%BC%A0%E7%90%83" tabindex="-1">0920.T2 快速传球</h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E-1" tabindex="-1">1. 题目说明</h4><p>班级组织传球活动，男女同学随机排成m行n列队伍，第一列中的任意一个男同学都可以作为传球的起点，要求最终将球传到最后一列的任意一个男同学手里，求所有能够完成任务的传球路线中的最优路线(传球次数最少的路线)的传球次数。</p><p><strong>传球规则:</strong></p><pre class="line-numbers language-none"><code class="language-none">1.男同学只能将球传给男同学，不能传给女同学。2.球只能传给身边前后左右相邻的同学。3.如果游戏不能完成，返回-1。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>说明</strong></p><pre class="line-numbers language-none"><code class="language-none">1.传球次数最少的路线为最优路线。2最优路线可能不唯一，不同最优路线都为最少传球次数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>解答要求</strong></p><p>时间限制:C/C<ins>100ms其他语言: 200ms内存限制: C/C</ins>256MB,其他语言: 512MB</p><p><strong>输入</strong></p><pre class="line-numbers language-none"><code class="language-none">班级同学随机排成的m行n列队伍，1代表男同学，0代表女同学。输入第一行包含两个用空格分开的整数m[1,30]和n [1,30]，表示m行n列的队伍;接下来是m行每行包含n个用空格分开的整数1或0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>输出</strong></p><p>最优路线的传球次数（最少传球次数）</p><p><strong>样例1</strong></p><p><strong>输入</strong></p><pre class="line-numbers language-none"><code class="language-none">4 41 1 1 01 1 1 00 0 1 00 1 1 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出</strong></p><pre class="line-numbers language-none"><code class="language-none">5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​</p><h4 id="2.-%E5%88%86%E6%9E%90%E8%A7%A3%E7%AD%94-1" tabindex="-1">2. 分析解答</h4><ul><li><p>涉及到最优路线和最短的路线，一般都会想到<code>BFS</code>或者<code>DFS</code>。这里就直接最短路BFS。</p></li><li><p>枚举第一列的所有的点，做一次BFS，判断走到最后一列的最短距离即可。关键在于100ms，其他语言一定要注意输入超时。</p><p>​</p></li></ul><h4 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3. 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//班级组织传球活动，男女同学随机排成m行n列队伍，// 第一列中的任意一个男同学都可以作为传球的起点，要求最终将球传到最后一列的任意一个男同学手里，// 求所有能够完成任务的传球路线中的最优路线(传球次数最少的路线)的传球次数。//班级同学随机排成的m行n列队伍，1代表男同学，0代表女同学。//输入第一行包含两个用空格分开的整数m[1,30]和n [1,30]，表示m行n列的队伍;//接下来是m行每行包含n个用空格分开的整数1或0。//输入：4 4//1 1 1 0//1 1 1 0//0 0 1 0//0 1 1 1//输出：5import java.io.*;import java.util.Deque;import java.util.LinkedList;import java.util.StringTokenizer;public class title2 {     //定义快速读入的类，这里需要学习记录一下：    private static  class FastScanner {        BufferedReader br; //用于按行读取输入数据        StringTokenizer st; //用于将一行数据分割为多个token。               public FastScanner(InputStream stream){            br =  new BufferedReader(new InputStreamReader(stream), 32768); //通过InputStreamReader将输入流转换为字符流，并指定缓冲区大小为32768。            st = null; //初始化为null        }        String next() { //用于获取下一个token（字符串）            while (st == null ||  !st.hasMoreTokens())// 当st为null或者当前行的token已经全部使用完毕时，进入循环                try {                    st=new StringTokenizer(br.readLine());//尝试读取下一行数据并将其分割为多个token                } catch (IOException e) {//异常处理                    e.printStackTrace();                }            return st.nextToken(); //循环结束，返回当前行的下一个token        }        int nextInt() {// nextInt()方法，用于获取下一个整数            return Integer.parseInt(next()); //调用next()方法获取下一个token（字符串），将调用到的token解析为整数并返回        }    }    public static void main(String[] args) {        new title2().solve();// 创建实例（solve()类看下文）    }    int m,n;// 队伍的行和列    int[][] grid; // 储存队伍中同学的性别信息    void solve() {        PrintWriter pwin = new PrintWriter(new OutputStreamWriter(System.out));        FastScanner fsc = new FastScanner(System.in);// 调用类        m = fsc.nextInt();;        n = fsc.nextInt();        grid = new int[m][n];        for (int i = 0; i &lt; m; i++) {            for (int j = 0; j &lt; n; j++) {                grid[i][j] = fsc.nextInt();            }        }        int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};// 定义dirs数组，表示四个方向的移动：右、下、左、上        int res = 10000001; // 初始化变量res为一个较大的数，用于保存最少传球次数        for (int i = 0; i &lt; m; i++) {// 利用广度优先搜索找到传球到最后一列男同学的最短路径。            if (grid[i][0] == 1) { // 判断是否为男同学，grid[i][0]表示第i行、第0列的位置，其中1表示男同学，0表示女同学。                Deque&lt;int[]&gt; dq = new LinkedList&lt;&gt;();// 定义队列，用于广度优先                dq.add(new int[]{0,i,0}); // 表示起点的传球次数、行号和列号                boolean[][] used = new boolean[m][n]; // 用于标记已经遍历过的位置                used[i][0] = true;                while (!dq.isEmpty()) {                    int[] a = dq.poll();// 从dq中取出队首元素a，其中d表示传球次数，x表示行号，y表示列号。                    int d = a[0], x = a[1], y = a[2];                    if (y == n-1) {                        res = Math.min(res, d);//如果当前列号等于n-1（最后一列），则更新最小传球次数res为传球次数d的较小值。                    }                    for (int[] dir : dirs) {                        //遍历四个方向的移动，计算新的行号nx和列号ny。//判断下一个位置是否合法，如果不合法则跳过继续下一次循环。//如果下一个位置合法且未被使用且为男同学，则将该位置标记为已使用，并加入dq，传球次数加1。                        int nx = x + dir[0],  ny = y + dir[1];                        if (nx &lt; 0 || ny &lt; 0 || nx &gt;= m || ny &gt;= n || used[nx][ny] || grid[nx][ny] != 1) continue;                        used[nx][ny] = true;                        dq.add(new int[]{d+1, nx,ny});// 循环结束，得到从当前起点到最后一列男同学的最短传球次数                    }                }            }        }        //如果找到了最短路径，则输出最小传球次数；如果无法找到最短路径，则输出-1。最后，通过刷新打印流pwin，确保结果被立即输出。        if (res != 10000001) pwin.println(res);//如果不等于10000001，表示找到了从起点到最后一列男同学的最短路径。等于的话就是没有找到        else pwin.println(-1);        pwin.flush();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><ul><li><strong>复杂度分析</strong><ul><li><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong>   对于每个男同学，最坏情况下需要遍历整个队伍，所以时间复杂度为O(m * n)，其中m为行数，n为列数。</li><li><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong>  需要使用额外的空间保存队列和标记已访问的位置，所以空间复杂度为O(m * n)。</li></ul></li></ul><blockquote><p>第三题太复杂了，还没弄懂，9.23号的后续接着更新…</p></blockquote><p>​</p><h3 id="0923.t1-%E5%88%86%E9%94%80%E7%B2%AE%E9%A3%9F" tabindex="-1">0923.T1 分销粮食</h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E-2" tabindex="-1">1. 题目说明</h4><p>粮食公司从农场收购了n吨粮食，现在要要平均分配给分销商进行销售(除不尽向下取整)。分销商数量若干，请计算分销商获得的粮食数量有几种可能。</p><p><strong>解答要求</strong></p><p>时间限制: C/C++ 2000ms,其他语言: 4000m内存限制:C/C++256MB,其他语言:512MB</p><p><strong>输入</strong></p><p>n:粮食总量，0&lt;n&lt;=4294967295</p><p><strong>输出</strong></p><p>m:分销商获得的粮食数有几种可能</p><p><strong>样例1</strong></p><pre class="line-numbers language-none"><code class="language-none">输入:5输出:3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​</p><h4 id="2.-%E5%88%86%E6%9E%90%E8%A7%A3%E7%AD%94-2" tabindex="-1">2. 分析解答</h4><ul><li>简单的模拟题，对所求的结果进行遍历即可。比如说粮食数量为<code>5</code>，那么我们假设有<code>m</code>个商家，如果要求商家都要均分到粮食，那么可以对<code>m</code>的数量进行遍历。<ul><li><p>m=1,n/m=5/1=5； 1个经销商分得5份粮食</p></li><li><p>m=2,n/m=2；2个经销商各分得2份粮食</p></li><li><p>m=3,n/m=1; 3个经销商各分得1份粮食（这种情况的时候，后续随着商家的数量变多后，分得的粮食数肯定比1小，但是由于取整，可能还是为1，直到最后的均分数为0舍去）。</p><p>​</p></li></ul></li></ul><h4 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81-1" tabindex="-1">3. 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Hashset;import java.util.Scanner;import java.util.set;public class title1{    public static void main(String[] args){        Scanner in=new Scanner(System.in);        int n=in.nextInt();        Set&lt;Integer&gt; res=new HashSet&lt;&gt;();                int i=1;//初始化商家的个数,其实也是保证后续的除数不为0                while(true){            res.add(n/i);            if(n/i==1){                break;//保证当前的每个商家均分的粮食数目为1的时候即可停止，由于均分的数目不能为0            }            i++;//开始遍历        }        System.out.println(res.size());// 返回hshSet的长度    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq></strong></p><blockquote><p>因为在while循环中，变量i从1遍历到n/i，所以总的迭代次数为n/1 + n/2 + n/3 + … + n/n，这个等价于n * (1/1 + 1/2 + 1/3 + … + 1/n)。 根据调和级数的性质，1/1 + 1/2 + 1/3 + … + 1/n 的和约为ln(n)，所以总的迭代次数约为 n * ln(n)。 因此，该代码的时间复杂度为O(n)。</p></blockquote></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msqrt><mi>n</mi></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\sqrt{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0503em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">n</span></span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq></strong></p><blockquote><p>在while循环中，将n/i的结果存储在一个HashSet集合res中。在最坏的情况下，当i取到sqrt(n)时，HashSet res 中的元素数量达到最大，即sqrt(n)，所以空间复杂度为O(sqrt(n))。</p></blockquote></li></ul></li></ul><p>​</p><h3 id="0923.t2-%E7%B3%96%E6%9E%9C%E8%BF%B7%E5%AE%AB" tabindex="-1">0923.T2 糖果迷宫</h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E-3" tabindex="-1">1. 题目说明</h4><p>小华和小为在一个两个m列的糖果迷宫里，迷宫的每一个位置上都有对应得糖果数目a[i][j],他们只能向右或者向下移动。</p><p>小华和小为都将从左上方a[0[[0]位置出发，向右下角a[1，m-1]走去，每到一个位置都将吃掉这个位置上的糖果。</p><p>假设小华先走，他走完后会吃掉路过的糖果，然后小为才开始走，被小华吃掉的糖果，小为就能再吃了。</p><p>小华希望小为吃掉最少的糖果总数，然后小为也希望在小华走完后自己能吃掉更多的糖果总数。</p><p>请你帮忙计算小为最多可以吃掉多少糖果。</p><p><strong>解答要求</strong></p><p>时间限制:C/C++ 1000ms 其他语言2000ms，内存限制: C/C++ 256MB,其他语言:512MB</p><p><strong>输入</strong></p><p>第一行包含一个整数m(1&lt;=m&lt;=100000),标识迷宫的宽度。</p><p>接下来包含两行，每行包含m个整数，每一个整数a[i]j代表该位置的糖果数目。</p><p><strong>输出</strong></p><p>输出小为最多可以吃到多少糖果。</p><p><strong>样例1</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：3     1 3 7     3 5 1输出：7解释：1 3 7     3 5 1     小为吃掉小华选择吃掉粗体部分的糖果1、3、5、1，小为吃掉7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><h4 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h4><ul><li><p>由于只有两行，可以进行前缀的模拟操作，就是记录下小华需要在第一行的那个位置转弯，这个点记录为<code>i</code>,然后小为可以获得的总价值就是第二行的前<code>i</code>个或者是第一行的后<code>n-i</code>个。</p></li><li><p>具体说明是定义小华的轨迹路线，注意其可走的位置有<code>m+1</code>个，需要注意第<code>2</code>行中的前<code>i</code>个的操作，同第<code>1</code>行中的后<code>n-i</code>个的操作.</p><p>​</p></li></ul><h4 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81-2" tabindex="-1">3. 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class title2 {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int m = sc.nextInt();//m为列的个数        int[][] grid = new int[2][m];        int[][] qzs = new int[2][m+1];//前缀数组，长度为m+1        for (int j = 0; j &lt; m; j++) {//第一行            grid[0][j] = sc.nextInt();            qzs[0][j+1] = qzs[0][j] + grid[0][j];        }        for (int j = 0; j &lt; m; j++) {//第二行            grid[1][j] = sc.nextInt();            qzs[1][j+1] = qzs[1][j] + grid[1][j];        }        long ans = Integer.MAX_VALUE;//确定最后的答案        for (int i = 0; i &lt; m; i++) {            int tmp = Math.max(qzs[1][i], qzs[0][m]-qzs[0][i+1]);//第2行的前i个和第1行的后n-i个            ans = Math.min(ans, tmp);//返回最小值，保证小华的最大值        }        System.out.println(ans);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></eq></strong></p><blockquote><ol><li>输入阶段：读取m个整数值，时间复杂度为O(m)。</li><li>创建二维数组grid和前缀数组qzs：创建二维数组的时间复杂度为O(2m)。创建前缀数组的时间复杂度为O(m)。</li><li>遍历循环：遍历m次，时间复杂度为O(m)。</li><li>内部计算：常数时间操作，时间复杂度为O(1)。</li></ol></blockquote></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></eq></strong></p><blockquote><ol><li>二维数组grid和前缀数组qzs：空间复杂度为O(2m+2m) = O(4m) = O(m)。</li><li>整型变量m和tmp：空间复杂度为O(1)</li></ol></blockquote></li></ul></li></ul><p>​</p><h3 id="0923.t3-%E5%AF%B9%E6%88%98%E6%AF%94%E8%B5%9B" tabindex="-1">0923.T3 对战比赛</h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E-4" tabindex="-1">1. 题目说明</h4><p>小明参加一个在线比赛。需要与n个对手对战。当小明的等级大于等于对手的等级，他就能赢。如果小明赢了，等级提升1级，否则会减少1级。对手的等级固定不变。小明的初始等级是x，小明想把他的等级提高到y（y&gt;x）。</p><p>该比赛有一条规则：每局此赛小明只能选择和对战次数最少的对手进行对战。</p><p>小明想用尽可能少的对站题升到等级y，计算小明为提升到等级y所需的最小可能的对战数。</p><p>注意，对手的等级不会改变，而小明的等级会改变。</p><p><strong>解答要求</strong></p><p>时间限制: C/C++ 2000ms,其他语言：4000ms 内存限制: C/C++ 256MB，其他语言：512MB</p><p><strong>输入</strong></p><p>第一行包含三个整数n、x和y(<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1\le n\le2* 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></eq>,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>x</mi><mo>&lt;</mo><mi>y</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">1\le x&lt;y\le 10^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span></eq>)表示对手个数，小明的初始等级和期望等级。</p><p>第二行包含n个整数a1,a2,a3,…,an(1&lt;=ai&lt;=10^12)表示对手的等级。</p><p><strong>输出</strong></p><p>打印小明为提升到等级y所需的最少对战数，如果不可能，则打印-1.</p><p><strong>样例1</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：7 2 10     3 1 9 2 5 20 8输出：20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90-1" tabindex="-1">2. 解答分析</h4><ul><li>贪心 + 模拟。<ol><li>每一次优先击败小等级的对手</li><li>每一轮可以打败的人数记为<code>cnt</code>，那么每一轮增长的总次数为<code>2*cnt - n</code>。</li><li>每一次可以击败的人的位置记为<code>i</code>，那么从<code>i+1</code>开始就开始打不过了，那么等级增长到<code>i+1</code>对应的等级的时候， 就应该更换策略了，通过这个差值可以算出需要轮询的次数了。</li></ol></li></ul><h4 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81-3" tabindex="-1">3. 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.*;public class title3 {    public static void main(String[] args) {        int n, cnt = 0;        long x,y;        long[] nums ;        Scanner in = new Scanner(System.in);        n = in.nextInt();        x = in.nextLong();        y = in.nextLong();        nums = new long[n];        for (int i = 0; i &lt; n; i++) {            nums[i] = in.nextLong();        }        Arrays.sort(nums);        long[] diff = new long[n];        for (int i = 0; i &lt; n; i++) {            diff[i] = Math.max(0, nums[i] - i);            if (diff[i] &lt;= x) cnt++;        }        if (x+cnt &gt;= y) {            System.out.println(y-x);            return;        }        if (n-cnt &gt;= cnt) {            System.out.println(-1);            return;        }        long ans = 0;        while (x &lt; y) {            int l = 0, r = n-1;            while (l &lt; r) {                int mid = (l + r + 1) &gt;&gt; 1;                if (diff[mid] &lt;= x) l = mid;                else r = mid - 1;            }            if (r == n-1) {                System.out.println(ans + y - x);                return;            }            r++;            int cur = 2*r - n;            long next = Math.min(diff[r], y);            long d = next - x;            if (next == y &amp;&amp; d &lt;= r) {                System.out.println(ans + d);                return;            }            if (cur &lt; 0) {                System.out.println( -1);                return;            }            long time = d / cur;            ans += time * n;            x += cur * time;        }        System.out.println(ans);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>时间复杂度：</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong></p><blockquote><ol><li>输入阶段：读取n、x、y和n个长整型数值，时间复杂度为O(n)。</li><li>数组排序：使用Arrays.sort进行排序，时间复杂度为O(nlogn)。</li><li>创建并初始化diff数组：循环n次，时间复杂度为O(n)。</li><li>计算cnt：循环n次，时间复杂度为O(n)。</li><li>判断条件和计算ans：while循环的次数不超过n次，每次循环的时间复杂度为O(logn)。</li></ol></blockquote></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong></p><blockquote><ol><li>整型变量n、cnt。</li><li>长整型变量x、y。</li><li>长整型数组nums和diff。</li></ol></blockquote></li></ul></li></ul><hr><blockquote><center><span style="font-size:2em;color:lightblue;">End~</span></center><center><span style="color:red;font-size:2em;">继续努力！😊</span></center></blockquote><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 笔试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023大厂秋招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西门子远程办公 Day1</title>
      <link href="/2023/09/20/xi-men-zi-yuan-cheng-ban-gong-day1/"/>
      <url>/2023/09/20/xi-men-zi-yuan-cheng-ban-gong-day1/</url>
      
        <content type="html"><![CDATA[<h3 id="%E8%A5%BF%E9%97%A8%E5%AD%90%E8%BF%9C%E7%A8%8B%E5%AE%9E%E4%B9%A0day1" tabindex="-1">西门子远程实习Day1</h3><ul><li><p><strong>时间安排？</strong></p><blockquote><p>今天有个早八的软件工程基础，老师还是一如既往地PPT讲解。8:30开始等Leader的邮件，结果差不多10:30才等到。从10:30一直工作到下午6:00，中间花了20分钟吃午饭。</p></blockquote></li><li><p><strong>任务分配？</strong></p><blockquote><p>今天主要是认识熟悉测试开发的平台<code>AEM Editor</code>,Leader下发的任务是完成19个文档网页的上传和测试。平台好多功能组件都不是很熟，也的确花费了大量时间进行复盘和尝试。最后只完整发布了<code>4</code>份测试报告，不过Leader说不着急，明天可以继续做。</p></blockquote></li><li><p><strong>后续安排？</strong></p><blockquote><ul><li>特意问了Leader明天是否需要到公司实地办公，她的回答是先不用。由于入职手续还没办理完成(我的招商银行工资卡还在申请制作当中),实习ID卡也没有办理好，所以目前还是远程办公。</li><li>远程实习是节约了大量的通勤时间，但是感觉询问和交流的效率稍低。希望在中秋、国庆假期之前可以实际去趟公司吧。</li></ul></blockquote></li><li><p><strong>收获感想</strong></p><blockquote><ol><li>工作遇到不会的不要着急，要多问多想多记录，比如今天的数据库上传的时候出现问题。通过询问之后才得知需要<code>Assets</code>保存<code>Properties</code>才可以成功上链。不同的公司要求不一样，实习作为一种特殊的工作经历，试错成本相对比较低了，对新人比较友好。</li><li>实习的时间相对比较轻松，远程实习就更是了。所以要好好利用空余时间抓紧学习知识。最近几天比较忙，<code>Leetcode</code>刷得较少。争取今年把里面的所有算法知识点学完，多练习、多理解、多举一反三。为明年的暑期实习和秋招做准备吧，加油！</li></ol></blockquote><p>​</p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/09/20/xi-men-zi-yuan-cheng-ban-gong-day1/%E6%A8%A1%E7%BB%84%E5%88%B6%E4%BD%9C.jpg" alt="模组制作" style="zoom:50%;"><blockquote><p>放一张今天解决的页面排版模板，认识组件太重要了😭~</p></blockquote><blockquote><p>对了，插播一句题外话，从本周末开始会开始更新2023.大厂秋招算法题目，也是自己思考过的题目类型，希望不会拖更哈哈，别到时候忙忘了😂~</p></blockquote></li></ul><center><span style="color:green;font-size:20px;">不断前进！😊</span></center><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双周赛113: 前3题</title>
      <link href="/2023/09/17/shuang-zhou-sai-113-qian-3-ti/"/>
      <url>/2023/09/17/shuang-zhou-sai-113-qian-3-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="%E5%8F%8C%E5%91%A8%E8%B5%9B113%EF%BC%9A%E5%89%8D3%E9%A2%98" tabindex="-1">双周赛113：前3题</h3><blockquote><p>本次双周赛的前3题难度适中，比较适合自己的学习。由于接了实习，最近也同样在学习有关的开发知识，力扣刷得不多。现在开始刷题学习之旅吧~</p></blockquote><p>​</p><h3 id="t1.-%E4%BD%BF%E6%95%B0%E7%BB%84%E6%88%90%E4%B8%BA%E9%80%92%E5%A2%9E%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%91%E5%8F%B3%E7%A7%BB%E6%AC%A1%E6%95%B0" tabindex="-1">T1. <a href="https://leetcode.cn/problems/minimum-right-shifts-to-sort-the-array/">使数组成为递增数组的最少右移次数</a></h3><h4 id="1.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1.1 题目说明</h4><p>给你一个长度为 <code>n</code> 下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组中的元素为 <strong>互不相同</strong> 的正整数。请你返回让 <code>nums</code> 成为递增数组的 <strong>最少右移</strong> 次数，如果无法得到递增数组，返回 <code>-1</code> 。</p><p>一次 <strong>右移</strong> 指的是同时对所有下标进行操作，将下标为 <code>i</code> 的元素移动到下标 <code>(i + 1) % n</code> 处。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [3,4,5,1,2]输出：2解释：第一次右移后，nums = [2,3,4,5,1] 。第二次右移后，nums = [1,2,3,4,5] 。现在 nums 是递增数组了，所以答案为 2 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [2,1,4]输出：-1解释：无法将数组变为递增数组。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= nums.length &lt;= 100</code></p></li><li><p><code>1 &lt;= nums[i] &lt;= 100</code></p></li><li><p><code>nums</code> 中的整数互不相同。</p><p>​</p></li></ul><hr><h4 id="1.2-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">1.2 解答分析</h4><ul><li><p>读题之后可以简单地分析需求：</p><ol><li>递增数组</li><li>最少右移次数</li><li><code>x</code>次右移是将下标<code>i</code>的元素移动到下标<code>(i+x)%n</code>处即可</li></ol></li><li><p>如何满足上述的三个需求？</p><ol><li><p>先将数组元素从小到大排序，得到最后的递增数组<code>a[]</code></p></li><li><p>最少移动次数用数组<code>遍历即可，x++;满足条件返回当前的x值即可</code>。在移动一次后的当前答案后判断此时的数组元素是否和数组<code>a[]</code>每一位的元素相同即可。</p></li><li><p>判断此时移动后的数组元素和下标为<code>(i+x)%n</code>处的元素是否相同即可</p></li></ol><p>​</p></li></ul><hr><h4 id="1.3-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">1.3 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution{    public int minimumRightShift(List&lt;Integer&gt;nums){        //注意题干给出恶的是List列表，此时获取nums中的元素用到get方法，长度用size()函数方法        int n=nums.size();        //a[]是当前排序好的结果元素，作为标准        int[] a=new int[n];        for(int i=0;i&lt;n;i++){            a[i]=nums.get(i);        }        Arrays.sort(a);        //枚举需要右移的次数，同时开始每一位的判定        for(int x=0;x&lt;n;x++){//x若移动n次和0次的效果相同            boolean flag=true;//用于判断每一次移动后的数组元素和标准数组的每一位是否相同，作为判断哨兵            for(int i=0;i&lt;n;i++){                if(nums.get(i)!=a[(i+x)%n]){                    f=false;                    break;                }            }            if(f){                return x;//返回当前右移统计的次数            }        }        return -1;//特例，没有则返回-1    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq></p><blockquote><p>Arrays.sort(a)的时间复杂度为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>,接下来两层循环的复杂度为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>。综上所述，时间复杂度为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq></p></blockquote></li><li><p><strong>空间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><p>在代码中，创建了一个长度为n的整型数组a来存储排好序的nums列表。由于nums列表和a数组的大小相同，因此需要额外的O(n)的空间。</p></blockquote></li></ul></li></ul><hr><p>​</p><h3 id="t2.-%E5%88%A0%E9%99%A4%E6%95%B0%E5%AF%B9%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6" tabindex="-1">T2. <a href="https://leetcode.cn/problems/minimum-array-length-after-pair-removals/">删除数对后的最小数组长度</a></h3><h4 id="2.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">2.1 题目说明</h4><p>给你一个下标从 <strong>0</strong> 开始的 <strong>非递减</strong> 整数数组 <code>nums</code> 。</p><p>你可以执行以下操作任意次：</p><ul><li>选择 <strong>两个</strong> 下标 <code>i</code> 和 <code>j</code> ，满足 <code>i &lt; j</code> 且 <code>nums[i] &lt; nums[j]</code> 。</li><li>将 <code>nums</code> 中下标在 <code>i</code> 和 <code>j</code> 处的元素删除。剩余元素按照原来的顺序组成新的数组，下标也重新从 <strong>0</strong> 开始编号。</li></ul><p>请你返回一个整数，表示执行以上操作任意次后（可以执行 <strong>0</strong> 次），<code>nums</code> 数组的 <strong>最小</strong> 数组长度。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,3,4,9]输出：0解释：一开始，nums = [1, 3, 4, 9] 。第一次操作，我们选择下标 0 和 1 ，满足 nums[0] &lt; nums[1] &lt;=&gt; 1 &lt; 3 。删除下标 0 和 1 处的元素，nums 变成 [4, 9] 。下一次操作，我们选择下标 0 和 1 ，满足 nums[0] &lt; nums[1] &lt;=&gt; 4 &lt; 9 。删除下标 0 和 1 处的元素，nums 变成空数组 [] 。所以，可以得到的最小数组长度为 0 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="2.2-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2.2 解答分析</h4><ul><li><p>注意审题，<strong>非递减数组说明可以存在相同的元素，比如数组[1,2,2,2,2,3,4,5,6]就满足条件</strong></p></li><li><p>简化题干就是每次都需要删除一组的<code>2</code>个数，满足下标和数值不同，满足递增即可。其实就是寻找出现次数最多的数字，并记录它出现的次数。如果它出现的次数大于总数的一半，那么它一定无法被完全消去；否则判断数组长度的奇偶性，因为偶数可以一一匹配，消除掉，奇数则会存在一个剩余。</p></li></ul><hr><h4 id="2.3-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">2.3 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution{    public int minLengthAfterRemovals(List&lt;Integer&gt; nums){        //统计数组中相同元素出现的次数，找出出现次数最多的元素；首先判断是否可以被消除(也就是次数小于等于总数的一半)。如果行，则直接判断奇偶性即可；如果不行，计算最后剩余的次数        HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();        int max=0;        for(int n:nums){            int curcount=mao.getOrDefault(n,0)+1;            max=Math.max(max,curcount);            map.put(n,curcount);//每次遇到新的键、值都更新        }        int len=nums.size();        if(2*max&lt;=len){            return len%2;//判断数组长度的奇偶性        }else{            return max-(len-max);////计算的是出现次数最多的数比其他数多的次数,也是最后多出来的次数}    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><p>代码首先使用HashMap来统计每个数字出现的次数。在遍历nums列表时，对于每个数字n，将其出现次数记录在map中，并更新当前最大次数max。这个过程的时间复杂度是O(n)，因为需要遍历整个nums列表。根据出现次数max和数组长度len进行判断，得出最小长度的结果。这部分操作只涉及简单的数学运算和条件判断，时间复杂度为O(1)。</p></blockquote></li><li><p><strong>空间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)/O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><p>对于空间复杂度，代码中使用了一个HashMap来存储数字和出现次数的映射关系，所占用的空间取决于nums列表中不同数字的个数，即O(k)，其中k是不同数字的数量。最坏的情况是O(n)，但是一般k会远小于n，随着n的不断增大。</p></blockquote></li></ul></li></ul><p>​</p><hr><h3 id="t3.-%E7%BB%9F%E8%AE%A1%E8%B7%9D%E7%A6%BB%E4%B8%BA-k-%E7%9A%84%E7%82%B9%E5%AF%B9" tabindex="-1">T3. <a href="https://leetcode.cn/problems/count-pairs-of-points-with-distance-k/">统计距离为 k 的点对</a></h3><h4 id="3.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">3.1 题目说明</h4><p>给你一个 <strong>二维</strong> 整数数组 <code>coordinates</code> 和一个整数 <code>k</code> ，其中 <code>coordinates[i] = [xi, yi]</code> 是第 <code>i</code> 个点在二维平面里的坐标。</p><p>我们定义两个点 <code>(x1, y1)</code> 和 <code>(x2, y2)</code> 的 <strong>距离</strong> 为 <code>(x1 XOR x2) + (y1 XOR y2)</code> ，<code>XOR</code> 指的是按位异或运算。</p><p>请你返回满足 <code>i &lt; j</code> 且点 <code>i</code> 和点 <code>j</code>之间距离为 <code>k</code> 的点对数目。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：coordinates = [[1,2],[4,2],[1,3],[5,2]], k = 5输出：2解释：以下点对距离为 k ：- (0, 1)：(1 XOR 4) + (2 XOR 2) = 5 。- (2, 3)：(1 XOR 5) + (3 XOR 2) = 5 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：coordinates = [[1,3],[1,3],[1,3],[1,3],[1,3]], k = 0输出：10解释：任何两个点之间的距离都为 0 ，所以总共有 10 组点对。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= coordinates.length &lt;= 50000</code></li><li><code>0 &lt;= xi, yi &lt;= 10^6</code></li><li><code>0 &lt;= k &lt;= 100</code></li></ul><p>​</p><hr><h4 id="3.2-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">3.2 解答分析</h4><ul><li><p>看到这个求和为k，想到的是<code>两数之和</code>，也就是要利用到HashMap进行遍历匹配。同时注意到提示条件中有<code>0&lt;=k&lt;=100</code>,说明此时可以枚举全部的<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>x</mi><mn>1</mn></msub><mi>X</mi><mi>O</mi><mi>R</mi><msub><mi>x</mi><mn>2</mn></msub><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">0\le x_1XORx_2\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.00773em;">XOR</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span></eq>情况即可。</p></li><li><p>如何将对应的二维数组唯一确定呢？需要利用<code>HashMap</code>进行存储计算，记录每个坐标出现的次数。使用乘法因子<code>mul</code>对<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>t</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_t,y_t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>转坏为唯一的<code>find</code>值，过查询<code>count</code>HashMap来获取<code>find</code>对应的值，并将其累加到<code>res</code>上。</p></li><li><p>将当前坐标（x, y）转换为唯一的<code>key</code>值，同样使用乘法因子<code>mul</code>，然后将<code>key</code>更新到<code>count</code>HashMap中，如果<code>key</code>已经存在，则将其对应值加1；如果<code>key</code>不存在，则初始化为1</p></li><li><p>本题是如何唯一确认二维坐标<code>(xi</code>, <code>yi)</code>的呢？这里设置比较大的乘法因子<code>mul</code>，设置成最大的值10^6,保证不会出现哈希碰撞导致键值对不唯一，确保生成的唯一数值范围足够广，以避免哈希冲突。。</p><blockquote><p>当有两个不同的二维坐标（<code>xi1</code>, <code>yi1</code>）和（<code>xi2</code>, <code>yi2</code>）满足<code>xi1 + yi1 = xi2 + yi2</code>时就会发生哈希冲突。</p></blockquote></li><li><p><strong>根据异或的性质，有 x ^ (i ^ x) = i, y ^ ((k - i) &amp; y) = k - i，因此与 坐标 (x, y) 可以匹配的坐标是 (i ^ x, (k - i) ^ y)，其中 i 的取值范围是 0 ~ k。</strong></p></li></ul><p>​</p><hr><h4 id="3.3-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3.3 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution{    private static final long mul=1000000;    public int countPairs(List&lt;List&lt;Integer&gt;&gt; coordinates,int k){        HashMap&lt;Long,Integer&gt;count =new HashMap&lt;&gt;();        int res=0;        for(List&lt;Integer&gt;coor:coordinates){            int x=coor.get(0),y=coor.get(1);//获取当前点对的x和y的值                        for(int i=0;i&lt;=k;i++){                int xt=i^x,yt=(k-i)^y;//异或操作                long find=xt*mul+yt;//乘法计算转化为唯一的find值                res+=count.getOrDefault(find,0);//统计出现和为k的数对的次数            }                        long key=x*mul+y;            count.put(key,count.getOrDefault(key,0)+1);//将当前坐标出现的次数更新到HashMapcount中。如果key已存在，则将其对应的值加1；若不存在，则初始化为1。        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>∗</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><ul><li>首先，遍历二维坐标列表需要花费O(N)的时间，其中N是坐标的数量。</li><li>内部嵌套循环的时间复杂度是O(k)，因为它迭代了从0到k的i的所有可能取值。</li><li>在内层循环中，通过HashMap的getOrDefault方法进行查询和更新操作，其时间复杂度是O(1)。</li><li>因此，总体时间复杂度为O(N * k)。</li></ul></blockquote></li><li><p><strong>空间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><p>创建一个HashMap<code>count</code>用于记录每个坐标出现的次数，需要的空间是O(n)，其余地方并没有使用到额外的数据结构。</p></blockquote></li></ul></li></ul><p>​</p><center><span style="color:red;font-size:30px;font-weight:bolder;">END~</span><p style="color:lightblue;font-size:20px;">继续努力！</p></center><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 138.复制带随机指针的链表</title>
      <link href="/2023/09/14/leetcode-138-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/"/>
      <url>/2023/09/14/leetcode-138-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-138.-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8" tabindex="-1"><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">Leetcode 138. 复制带随机指针的链表</a></h3><blockquote><p>最近的编译原理课程的lab1进行了链表的基本操作，这下回来想着如果链表的指针并不唯一指定的话，需要怎么进行复制，或者说是链接。刚好在力扣找到了这道题，所以拿来试试手…</p></blockquote><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a></strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p><p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p><p>返回复制链表的头节点。</p><p>用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p><ul><li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li><li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code> 。</li></ul><p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​</p><hr><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><ul><li><p>本题的基本操作是将链表进行复制，但是对于每个链表的节点而言都存在随机的指针<code>random</code>，其实在不考虑<code>random</code>指针的情况下，只需要将原先的链表进行拷贝，这里引入两个指针，一个用于遍历原链表，一个用于构造新链表（始终指向新链表的尾部）。</p><blockquote><p>这个过程实际上就是创建节点+构建<code>next</code>的指针关系</p></blockquote></li><li><p>所以现在就是在原先的基础上添加特定的<code>random</code>指针，我们可以将<code>next</code>指针和<code>random</code>指针进行关系的构建，从输入的格式中可以强烈看出应该是要用到<code>哈希表</code>的数据结构，<code>key</code>为原节点，对应的<code>value</code>是新节点。</p><ul><li>先不考虑<code>random</code>指针的关系，和原本链表复制一样，创建新节点，并构造出<code>next</code>的指针关系，<strong>同时使用的是哈希表记录原节点和新节点的映射关系</strong></li><li>对原链表和新链表进行同时遍历，对于原链表的每个节点上的<code>random</code>都利用<strong>哈希表</strong>的找到新<code>random</code>节点，并在新链表上构造<code>random</code>关系。<strong>也就是总共两条链表，其中的每个节点都是利用HashMap构造的对应映射关系</strong></li></ul></li></ul><hr><h3 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3. 具体代码</h3><ul><li><p><code>Java</code>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution{    public Node copyRandomList(Node head){        Node t=head;        Node dummy=new Node(-10010),cur=dummy;//dummy是空节点，cur是对应的指针        Map&lt;Node,Node&gt;map=new HashMap&lt;&gt;();        //第一次遍历原链表：遍历每个原节点 head，创建一个新节点 node 并保存到哈希表中，同时将新节点连接到复制链表中。(存HashMap)        while(head!=null){            Node node=new Node(head.val);            map.put(head,node);            cur.next=node;            cur=cur.next;            head=head.next;        }                cur=dummy.next;//重置指针        head=t;//为第二次遍历做准备        //第二次遍历原链表：遍历每个原节点 head，从哈希表中获取对应的复制节点，并将其赋值给复制链表当前节点的 random 指针。（进行链表复制）        while(head!=null){            cur.random=map.get(head.random);            cur=cur.next;            head=head.next;        }        return dummy.next;//返回复制指针的头节点    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>复杂度分析</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq></strong></p><blockquote><p>两次遍历原链表：需要遍历整个链表，时间复杂度为 O(N)，其中 N 是原链表的长度。 综上所述，总的时间复杂度为 O(N)。</p></blockquote></li><li><p><strong>空间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><p>创建了一个哈希表 <code>map</code>，存储了原节点和对应的复制节点，因此需要额外的空间来存储哈希表中的键值对。哈希表的空间复杂度为 O(N)。同时为了复制链表，创建了哨兵节点<code>dummy</code>和指针<code>cur</code>,但是他们的数量和键值对数量一样为N，综上所述：空间复杂度为O(N)。</p></blockquote></li></ul></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西门子实习面试经验帖</title>
      <link href="/2023/09/13/xi-men-zi-shi-xi-mian-shi-jing-yan-tie/"/>
      <url>/2023/09/13/xi-men-zi-shi-xi-mian-shi-jing-yan-tie/</url>
      
        <content type="html"><![CDATA[<h3 id="%E8%A5%BF%E9%97%A8%E5%AD%90%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E5%B8%96" tabindex="-1">西门子实习面试经验帖</h3><h3 id="1.-%E9%80%89%E6%8B%A9%E5%8E%9F%E5%9B%A0" tabindex="-1">1. 选择原因</h3><blockquote><p>始终认为：学会认知自我，并作出改变是大学的必修课；面向就业，并为社会国家做出一定贡献是大学生的必拿学分。</p></blockquote><ul><li><p>大三上学期排课不是很多，工作日几乎可凑出三天的时间</p></li><li><p>西门子作为<code>TOP500</code>企业，想从实习岗位中大致进行职位的体验，不断职业规划，有所进步</p></li><li><p>对岗位感兴趣，尤其是网站开发的职位，一直都想有机会得到技术提升</p><p>​</p></li></ul><hr><h3 id="2.-%E6%8A%95%E6%94%BE%E8%BF%87%E7%A8%8B" tabindex="-1">2. 投放过程</h3><ul><li><p>首先是在<code>北邮人论坛</code>上找到了内推实习，实习的工作是进行网站维护和开发，需要用到的语言有<code>HTML/CSS/Javascipt</code>，以及部分的后端J<code>Java</code>代码对接处理。</p></li><li><p>直接做好简历进行投递，办理入职的过程如下：（</p><blockquote><p>听说外企的办理还是挺麻烦了，这里就一直记录下来，直到结束办理）</p></blockquote><ul><li><p>9.8晚上简历投递；</p></li><li><p>9.11号上午通知简历通过，准备面试和技术面；</p></li><li><p>9.12下午进行面试，和hr与技术组组长沟通洽谈</p></li><li><p>9.13 上午面试通过，收到交接通知，进行线上培训</p></li><li><p>9.14 加上Leader微信，沟通时间安排</p></li><li><p>9.18 开始进行办公，第一天任务是SMART网站资料更新，比较友好，但是还是花了一上午。下午收到"Welcome to Siemens"的offer邮件。</p></li><li><p>9.19 - 9.20 提交实习生资料（9.23号才办理好银行卡，收到网上合同和准测预览）</p></li><li><p>9.20-至今(9.24)  开始大任务，进行案例文章的发布和新闻修改上传，任务多多…</p></li></ul><p>​</p></li></ul><hr><h3 id="3.-%E9%9D%A2%E8%AF%95%E8%BF%87%E7%A8%8B(%E7%BA%BF%E4%B8%8A)" tabindex="-1">3. 面试过程(线上)</h3><blockquote><p>本次面试的体验感觉很棒，面试官很有亲和力，在具体技术面试的时候<code>Leader</code>也会有所提示，对于存在的问题客观评价，这点对于像我这样成长期中的实习生来说是一次很宝贵、难得的学习机会。</p></blockquote><h4 id="%E9%83%A8%E5%88%86%E6%B5%81%E7%A8%8B%E5%A6%82%E4%B8%8B%EF%BC%9A" tabindex="-1">部分流程如下：</h4><ul><li>打招呼，问候</li></ul><p><strong>Q1</strong>：进行简单的自我介绍？</p><blockquote><p>介绍自己的学历、项目经历、以及选择该岗位的对应技能要求</p></blockquote><p><strong>Q2</strong>：为什么选择西门子公司？</p><blockquote><p>这里我分为了两个部分，一个是对实习企业平台的考虑，主要介绍西门子公司的经营业务(体现出对公司的了解)，以及对拓展个人视野的阐述；另外一个是对自身技能提升的考虑，说明自身对相关实习经历的需求，我结合了参与的竞赛、项目，希望可以把握好本次机会得到锻炼。</p></blockquote><p><strong>Q3</strong>： 简单介绍一次影响深刻的小组合作项目？</p><blockquote><p>我的介绍分为以下三步：</p><ol><li>项目目的与需求</li><li>项目分工与配合（这里说了很多）</li><li>项目收获</li></ol></blockquote><ul><li>接下来是技术面，技术组<code>Leader</code>打开word文档，里面包含前后端的代码分析，具体的大概有网页<code>HTML/CS/JavaScript</code>的组件分析，<code>数据库</code>后端的适配和应用，以及基于<code>Java</code>的功能分析实践。很多都是常见的八股文分析，同时包含性能优化与提升，这些我都一一回答，唯一遗憾的是有个<code>Java</code>问题回答得仓促，再加上周围环境有些嘈杂，回答了三次才让面试官点头满意，回答问题不要急，要全面分析后得出自己得理解，娓娓道来。</li></ul><p><strong>Q4：</strong> 具体实习的时间和薪资预期？</p><blockquote><p>当问到这个问题的时候，我知道大概率是通过了，但是也不敢打包票保证。</p><ol><li>实习时间：由于我需要上课，先开始说的是周三、周四两天可以去实习；后续hr说希望可以工作2.5天，需要至少1天到公司。我个人的安排是周四到司，剩余一天半远程实习。</li><li>薪资：hr提问得十分谨慎，估计是有很多本科生由于薪资拒绝了吧。对我而言，权衡薪资和经历，我更偏向于后者，真诚回答即可。</li></ol></blockquote><ul><li><p>接着是被面试者的提问环节，就不细说了。</p></li><li><p>最后致谢，礼貌告别</p><p>​</p></li></ul><hr><h3 id="4.-%E6%84%9F%E6%82%9F" tabindex="-1">4. 感悟</h3><ol><li><p>终究需要走出这一步，走出去了后面会越来越好的！尤其是面试的时候，一直不断做积极的心理暗示为紧张的自己鼓励加油😂</p></li><li><p>入职后要多看多学多用，不浪费机会，将自己所学实际应用出来😁</p></li><li><p>北邮人论坛太棒了！感谢学校平台和学长学姐们的职位推荐，我也会努力学习，做出成绩，为后来的学弟学妹们树立榜样👍</p></li></ol><p>​</p><center><span style="font-size:25px;color:lightblue;">Successful interview experience😄</span></center><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 企业面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML/CSS知识准备</title>
      <link href="/2023/09/11/html-css-zhi-shi-zhun-bei/"/>
      <url>/2023/09/11/html-css-zhi-shi-zhun-bei/</url>
      
        <content type="html"><![CDATA[<h3 id="html%2Fcss%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87" tabindex="-1">HTML/CSS知识储备</h3><blockquote><p>bg：前几天在论坛里找到了<code>西门子</code>的内推，本想试一试就把简历制作发过去了。没想到回复邮件通知面试，面试的岗位是：内网/外网技术支持实习生,主要负责网页的运行维护、新闻推送页面制作等。我觉得挺好的，虽然平时也会主动去学习相关的web开发的工作，但是真正面试还是第一次，要好好准备，希望这次可以有学习体验的机会。明天下午进行面试，主要考察网页相关的知识，现在把HTML/CSS知识重新梳理复习一遍，明天加油！！！</p></blockquote><h2 id="html" tabindex="-1">HTML</h2><ul><li><p>HTML的定义：<strong>是一种超文本标记语言</strong>，不是编程语言，<strong>利用标记标签来描述网页。</strong></p></li><li><p>HTML的标签：利用尖括号包围、成对出现、有开始有结束的标签、开放标签和闭合标签</p></li><li><p><strong>HTML的元素</strong>：</p><ul><li>标题是通过<code>&lt;h1&gt;--&gt;&lt;h6&gt;</code>的标签进行定义，按重要级从小到大</li><li>段落是通过<code>&lt;p&gt;</code>的标签进行定义，分行</li><li>链接是通过<code>&lt;a&gt;</code>标签进行定义的，主要还有<code>href</code>的属性值，后面接的是链接的对应的网页地址</li><li>图像是利用<code>&lt;img&gt;</code>标签进行定义，注意<code>src</code>属性值表示对应图片的存储位置</li><li>空的html元素：虽然没有实际的内容，但是还是需要返回和关闭标签，注意<code>&lt;br /&gt;</code>的用法，在开始标签中添加斜杠</li><li>html中的标签对大小写不敏感，但是大多数网站都可以实现大写的<code>HTML</code>标签.</li></ul></li></ul><p>​</p><ul><li><p><strong>HTML的属性</strong></p><ul><li>这里的属性太多了，挑选一些常见的属性实例<ul><li><code>align="center"</code> 直接写在开始标签中，用于将文本对齐居中</li><li><code>body</code>主体中的属性，比如改变颜色，可以设置为<code>background-color:yellow;</code>同样也可以设置为<code>&lt;body bgcolor="yellow"&gt;</code>来表示</li><li><code>&lt;table&gt;</code>定义为HTML的表格样式</li><li>同样的在HTML中，对属性和属性值大小写并不敏感</li><li><strong>属性值（也就是具体的选值）需要被包含在双引号之中</strong></li></ul></li></ul></li></ul><p>​</p><ul><li><strong>HTML的标题</strong></li><li>需要根据具体的样式选取标签，也就是前文所说的<code>&lt;h1&gt;...&lt;h6&gt;</code>等，其中都是根据标题文字的重要性进行的排列，依次降低<ul><li>默认情况下，浏览器会自动地在标题的前后添加空行</li><li><code>HTML</code>的水平线，例如<code>&lt;hr /&gt;</code>,直接在当前界面中添加水平分割线</li></ul></li></ul><p>​</p><ul><li><p><strong>HTML段落</strong></p><ul><li>浏览器会自动地在段落前后添加空行（<code>&lt;p&gt;是块级元素</code>）</li></ul></li></ul><p>​</p><ul><li><p><strong>HTML样式（这个是重点！）</strong></p><ol><li><p><strong>直接style用法</strong></p><blockquote><p>比如说是:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">background-color</span><span class="token punctuation">:</span>green<span class="token punctuation">;</span><span class="token property">font-size</span><span class="token punctuation">:</span>20px<span class="token punctuation">;</span><span class="token property">text-align</span><span class="token punctuation">:</span>center</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>This is an apple!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote></li><li><p><strong>附加文件CSS</strong></p></li></ol><ul><li><p><code>&lt;em&gt;和&lt;i&gt;的区别：</code></p><ul><li><p><code>&lt;em&gt;</code>表示的是浏览器中的文本为强调的内容，但是最后</p></li><li><p><code>&lt;i&gt;</code>本身就是斜体字符的样式</p></li><li><p><code>&lt;strong&gt;</code>，这个标签也同样是强调文本的意思，但是它强调的程度更强一些，直接加粗字体的用法</p></li></ul></li></ul></li></ul><p>​</p><ul><li><p><strong>HTML引用</strong></p><ul><li><p><code>&lt;q&gt;</code>，元素是简短的引用，浏览器通常会直接对<code>&lt;q&gt;</code>元素包围引号</p></li><li><p><code>&lt;blockquote&gt;</code> ,通常是对元素定义被引用的节</p></li><li><p><code>cite</code>,表示引用的数据的地址与来源</p></li><li><p><code>abbr</code>,元素定义缩写或首字母缩略语</p><p>对缩写进行标记能够成为为浏览器、翻译系统以及搜索引擎提供有用的信息。比如</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>abbr</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>World Health Organization<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>WHO<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>abbr</span><span class="token punctuation">&gt;</span></span> 成立于 1948 年。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>输出就是：WHO....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>dfn</code>，元素定义项目或缩写</p></li><li><p><code>address</code>元素定义文档或者文章的联系信息（作者/拥有者）,此元素通常以斜体进行表示</p></li><li><p><code>cite</code>，该元素是著作的标题，通常会以斜体显示<code>&lt;cite&gt;</code>的元素</p></li></ul></li></ul><p>​</p><ul><li><p><strong>HTML CSS</strong></p><blockquote><p>上述的html的样式引入比较浅显，这里具体分类分析一下：</p></blockquote><ol><li><p><strong>外部样式表</strong></p><blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mystyle.css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--上述代码中的rel表示当前引入的是外部样式表，type样式表示当前被链接文件的类型，href指定文件的存储路径和位置--&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote></li><li><p><strong>内部样式表</strong></p><blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css"><span class="token selector">body</span> <span class="token punctuation">{</span><span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">}</span><span class="token selector">p</span> <span class="token punctuation">{</span><span class="token property">margin-left</span><span class="token punctuation">:</span> 20px<span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--注意是直接在head内部定义css样式--&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote></li><li><p><strong>内联样式</strong></p><blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span> <span class="token property">margin-left</span><span class="token punctuation">:</span> 20px</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>This is a paragraph<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--注意是在标签头内部直接进行样式style的书写--&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote></li></ol><ul><li><code>&lt;span&gt;</code>表示的是定义文档中的行内较小的一块或者是区域。</li><li><code>&lt;div&gt;</code>定义文档中的节或者是区域（块级）</li></ul></li></ul><p>​</p><ul><li><p><strong>HTML超链接</strong></p><ol><li><p>通过使用 href 属性 - 创建指向另一个文档的链接，<strong>也就是规定链接的目标</strong></p></li><li><p>通过使用 name 属性 - 创建文档内的书签，也就是给</p></li><li><p>其中的<code>target</code>属性：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3school.com.cn/<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Visit W3School!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--上述的代码表示会将新创建的超链接窗口定义为一个新的网页窗口--&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p>​</p></li><li><p><strong>HTML图像</strong></p></li><li><p><code>&lt;img&gt;</code>标签，使用的是<code>src</code>源属性，指的是图像的<code>URL</code>地址关系，<code>&lt;img src="url" /&gt;</code></p></li><li><p>替换文本属性<code>&lt;Alt&gt;</code>,表示的是为图像定义一串预备的可替换的文本，替换文本属性的值是用户自己定义的。</p><ul><li><p><code>&lt;area&gt;标签的coords属性规定了客户端图像映射到鼠标敏感的区域的坐标</code></p><ul><li>如下面代码：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>circle<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>180,139,14<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>venus.htm<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Venus<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token comment">&lt;!--这里的 x 和 y 定义了圆心的位置（"0,0" 是图像左上角的坐标），r 是以像素为单位的圆形半径。--&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>​</p></li><li><p><strong>HTML表格</strong></p><ul><li><p>表格是由<code>&lt;table&gt;</code>标签进行定义，每个表格都有若干行<code>&lt;tr&gt;</code>，每行是会被分割为若干个单元格<code>&lt;td&gt;</code>。数据单元格的内容，包含文本、图片、列表、段落、表单、水平线、表格等等。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!--border="1"表示1个像素，也就是1px--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>row 1, cell 1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>row 1, cell 2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>row 2, cell 2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--tr是行，td是列--&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>*<strong>表格跨行、跨列操作</strong></p><p><code>&lt;colspan&gt;</code>实现单元格的跨列操作，使用<code>&lt;rowspan&gt;</code>实现单元格的跨行操作。</p><blockquote><p>其中的colspan="0"表示浏览器横跨到列的最后一列，对应rowspan也是一样,其余的直接数字就表示跨的列/行。</p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">&gt;</span></span>星期一<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">&gt;</span></span>星期二<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">colspan</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>星期天<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/09/11/html-css-zhi-shi-zhun-bei/%E8%B7%A8%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA.jpg" alt="跨列表展示"></p><p>​</p></li></ul></li><li><p><strong>HTML列表</strong></p><ul><li><strong>无序列表</strong><code>&lt;ul&gt;,每个列表项始于&lt;li&gt;</code></li><li><strong>有序列表</strong><code>&lt;ol&gt;</code>，每个列表项始于<code>&lt;li&gt;标签</code></li></ul></li></ul><p>​</p><ul><li><p><strong>HTML的块</strong></p><ul><li><p>大多数的HTML元素被定义为块级元素或者是内联元素，对于<strong>HTML块级元素</strong>来说，其在浏览器显示的时候，通常会以新行来开始或者结束。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>HTML的内联元素</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">常见的有：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span><span class="token punctuation">&gt;</span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span><span class="token punctuation">&gt;</span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>HTML<code>&lt;span&gt;</code>元素</strong></p><blockquote><p><code>&lt;span&gt;</code>元素可用于部分文本设置样式属性</p></blockquote><p>​</p></li></ul></li><li><p><strong>HTML的id属性</strong></p><ul><li><p>id属性指定HTML元素中唯一id，属性的值在HTML文档中国也必须是唯一的。</p><blockquote><p>这点和类名不一样，一个类名可以由多个元素共同使用，但是一个id属性只能由一个元素使用</p></blockquote></li></ul></li></ul><p>​</p><ul><li><p><strong>HTML Iframe</strong></p><ul><li><p><code>Iframe</code>通常用于在网页内显示网页，主要是用于嵌套网页</p><p><code>&lt;iframe src="https://shakej96.github.io/"&gt;&lt;/iframe&gt;,&lt;!--URL 指向隔离页面的位置。--&gt;</code></p></li><li><pre class="line-numbers language-language-html"><code class="language-language-html"><iframe src="https://shakej96.github.io/"></iframe><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>同样是可以设置高度和宽度</p></li><li><p><code>Iframe</code> :<code>frameborder</code>的属性规定是否显示周围的边框。</p></li></ul><p>​</p><p style="color:red;font-size:20px;" align="center">先写这么多吧，基本的HTML操作应该都复习到了，后续再添加上常用的CSS。</p><center>明天面试加油😊</center></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端准备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 394.字符串解码</title>
      <link href="/2023/09/09/leetcode-394-zi-fu-chuan-jie-ma/"/>
      <url>/2023/09/09/leetcode-394-zi-fu-chuan-jie-ma/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-394.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81" tabindex="-1"><a href="https://leetcode.cn/problems/decode-string/">Leetcode 394. 字符串解码</a></h3><blockquote><p>摘要：本题名为字符串的解码，实际上分为两部分，一部分是字符串出现的次数；另外一部分是子字符串。本题引入数据结构是栈，通过对"[ ]"括号的分类，判断入栈出栈的时机，对全部的字符串进行解码。</p></blockquote><p>​</p><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><ul><li><p>给定一个经过编码的字符串，返回它解码后的字符串。</p></li><li><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p></li><li><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p></li><li><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：s = "3[a]2[bc]"输出："aaabcbc"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：s = "3[a2[c]]"输出："accaccacc"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><hr><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><ul><li><p>一看到题目想到的是对数字和字符进行分类，但是后来考虑到这是通过<code>字符串</code>的形式进行的解码，而且对数字和字符串的匹配关系存在==“[ ]“<mark>的要求，所以这里就对</mark>”[ ]”==进行讨论，<strong>将引入辅助栈对数字和字符串进行匹配</strong>，算法的流程如下：</p><ol><li><p>构建辅助栈 <code>stack</code>， 遍历字符串 <code>s</code> 中每个字符 c；</p><ul><li><p>当 c 为数字时，将数字字符转化为数字 <code>multi</code>，用于后续倍数计算；</p></li><li><p>当 c 为字母时，在<code> res</code> 尾部添加 c；</p></li><li><p>当 c 为 <code>[</code> 时，将当前 <code>multi </code>和 <code>res</code> 入栈，并分别置空置 0：</p><ul><li>记录此 <code>[</code> 前的临时结果<code> res</code> 至栈，用于发现对应 <code>]</code> 后的拼接操作；</li><li>记录此 <code>[</code> 前的倍数 <code>multi</code> 至栈，用于发现对应 <code>] </code>后，获取 <code>multi × [...]</code> 字符串。</li><li>进入到新<code>[</code>后，<code>res </code>和 <code>multi</code> 重新记录。</li></ul></li><li><p>当 c 为<code>]</code>时，<code>stack</code> 出栈，拼接字符串 <code>res = last_res + cur_multi * res</code>，其中:</p><ul><li><code>last_res</code>是上个 [ 到当前 [ 的字符串，例如 <code>"3[a2[c]]" </code>中的 <code>a</code>；</li><li><code>cur_multi</code>是当前 [ 到 ] 内字符串的重复倍数，例如 <code>"3[a2[c]]"</code> 中的 <code>2</code>。</li></ul></li></ul></li><li><p>返回字符串<code> res</code>。</p></li></ol></li><li><p>其实就是对所有的字符进行划分，引入两个栈空间对数字和字符进行存储，这里要用到的是<code>LinkedList</code>的数据结构链表，对字符串进行拼接。</p></li></ul><hr><h3 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3. 具体代码</h3><ul><li><p><strong>Java代码如下：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public String decodeString(String s) {        //首先需要注意的是对于字符串的拼接和次数的限制.这里还有‘[]’的要求，其实有提示就是需要栈的进出        StringBuffer res=new StringBuffer();        int multi=0;        LinkedList&lt;Integer&gt; stack_multi=new LinkedList&lt;&gt;();        LinkedList&lt;String&gt; stack_res=new LinkedList&lt;&gt;();        for(Character c:s.toCharArray()){            if(c=='['){                stack_multi.addLast(multi);//添加数字的栈                stack_res.addLast(res.toString());//在当前的栈的末尾添加新遍历后的元素                multi=0;//对应的清0                res=new StringBuffer();//res重置为空的字符串，便于后续的存储            }            else if(c==']'){                StringBuffer tmp=new StringBuffer();//添加暂时的中间变量                int cur_multi=stack_multi.removeLast();//弹出最后的元素，并且在弹出后首先清除                for(int i=0;i&lt;cur_multi;i++){                    tmp.append(res);//遍历需要复写的次数                }                res=new StringBuffer(stack_res.removeLast()+tmp);//返回特定的字符串，为下一次遍历做准备            }            else if(c&gt;='0' &amp;&amp; c&lt;='9'){                multi=multi*10+Integer.parseInt(c+"");//先将字符'c'转化为字符串的形式，后来当遇到一个数字字符时，将其转换为整数，并将其累积到乘数中，让多个字符形成字符串的格式            }            else res.append(c);//字符串直接拼接        }        return res.toString();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>复杂度分析：</strong></p><ul><li><p>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>，通过一次遍历<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></eq></p></li><li><p>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>,辅助栈在极端情况下是需要使用线性空间的，也就是调用太多次==”[ ]“==,比如：<code>2[2[2[a]]]</code></p></li></ul></li></ul><hr><blockquote><p>插一句题外话：最近开始投实习了，也希望可以在工作项目中得到提升吧，刷题大多数情况下是有思路，但是写得不规范，导致总是会有小错误。在接下来的日子里，继续学习沉淀，希望可以在大三找到一份实习工作，压力🍐++;</p></blockquote><center><span style="text-align:center;font-size:30px;background-color:lightblue;">我会努力的！👌</span>  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css"></center>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 1921.消灭怪物的最大数量</title>
      <link href="/2023/09/07/leetcode-1921-xiao-mie-guai-wu-de-zui-da-shu-liang/"/>
      <url>/2023/09/07/leetcode-1921-xiao-mie-guai-wu-de-zui-da-shu-liang/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-1921.-%E6%B6%88%E7%81%AD%E6%80%AA%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F" tabindex="-1"><a href="https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/">Leetcode 1921. 消灭怪物的最大数量</a></h3><blockquote><p>概要：本题是在比较孤傲五移动的次数和我们可以走的次数，其中需要判断的是每一次移动之后，怪物移动的距离是否会比人移动的次数多。这里重要的思想是移动的次数问题，需要满足取余的思想</p></blockquote><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><ul><li>你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个 <strong>下标从 0 开始</strong> 且长度为 <code>n</code> 的整数数组 <code>dist</code> ，其中 <code>dist[i]</code> 是第 <code>i</code> 个怪物与城市的 <strong>初始距离</strong>（单位：米）。</li><li>怪物以 <strong>恒定</strong> 的速度走向城市。给你一个长度为 <code>n</code> 的整数数组 <code>speed</code> 表示每个怪物的速度，其中 <code>speed[i]</code> 是第 <code>i</code> 个怪物的速度（单位：米/分）。</li><li>怪物从 <strong>第 0 分钟</strong> 时开始移动。你有一把武器，并可以 <strong>选择</strong> 在每一分钟的开始时使用，包括第 0 分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。</li><li>一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 <strong>恰</strong> 在某一分钟开始时到达城市，这会被视为 <strong>输掉</strong> 游戏，在你可以使用武器之前，游戏就会结束。</li><li>返回在你输掉游戏前可以消灭的怪物的 <strong>最大</strong> 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回 <code>n</code> 。</li></ul><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：dist = [1,3,4], speed = [1,1,1]输出：3解释：第 0 分钟开始时，怪物的距离是 [1,3,4]，你消灭了第一个怪物。第 1 分钟开始时，怪物的距离是 [X,2,3]，你没有消灭任何怪物。第 2 分钟开始时，怪物的距离是 [X,1,2]，你消灭了第二个怪物。第 3 分钟开始时，怪物的距离是 [X,X,1]，你消灭了第三个怪物。所有 3 个怪物都可以被消灭。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><hr><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><ul><li><p><code>dist[]</code>数组表示的距离，<code>speed[]</code>表示的是移动的速度（每次移动的距离），所以可见对于怪物而言，需要计算的就是移动<code>所需的时间</code>，或者说是<code>次数</code>问题</p></li><li><p>那对于人而言，每分钟我们都可以杀一只怪兽，如果怪兽在我们击杀前到达，<strong>也就是<mark>人杀死怪物需要的次数</mark>比<mark>怪物到达城市所需的次数</mark>多</strong>的话，则会输掉比赛。</p></li><li><p>所以返回的是可以杀死多少个这样的怪物，是人可以拥有的移动的次数<code>i</code>（人每移动一次杀死一只怪兽）</p></li></ul><hr><h3 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3. 具体代码</h3><ul><li>首先引入数组<code>arr[]</code>，用于表示每只怪兽到达需要的时间（次数）</li><li>接着遍历所有的怪兽数组<code>dist[]</code>,补充当前的<code>arr[]</code>数组</li><li>接着排序，对<code>arr[]</code>数组进行排序，<strong>其实就是危险性的排序</strong></li><li>遍历当前的<code>arr[]</code>数组，判断当前的人的移动次数和对应的的怪兽次数比较</li></ul><p><strong>java代码如下：</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution {    public int eliminateMaximum(int[] dist, int[] speed) {        //java, 排序        int n = dist.length;        //记录每只怪兽到达需要的时间        int[] arr = new int[n];        for (int i = 0; i &lt; n; i++) {            if (dist[i] == 0) return 0;//如果距离为0.此时怪兽已经到达            arr[i] = dist[i] % speed[i] == 0 ? dist[i] / speed[i] - 1: dist[i] / speed[i];//之所以取余，是因为speed[i]每一次都是以speed[i]的速度增长，而不是单纯地走一步++，            //如果此时的取余为0，说明还可以让它走商减1次（除去最后遇到的那次），也就是剩余商-1次机会            //如果此时的取余不为0，说明还剩下商次机会，不用减1，是因为不会刚好遇到        }        //排序，对所有的arr时间进行排序        Arrays.sort(arr);        //每分钟我们都可以杀一只怪兽，如果怪兽在我们击杀前到达，则会输掉比赛        for (int i = 1; i &lt; n; i++) {//i表示次数问题            if (arr[i] &lt; i) return i;        }        return n;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析</strong></p><ul><li><p><strong>时间复杂度:</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><ol><li>首先，对于遍历数组 <code>dist</code> 和 <code>speed</code> 来计算 <code>arr</code> 数组的时间复杂度是 O(n)，其中 n 是数组的长度。</li><li>接下来，对 <code>arr</code> 数组进行排序的时间复杂度是 O(nlogn)，其中 n 是数组的长度。</li><li>最后，再次遍历 <code>arr</code> 数组进行比较的时间复杂度是 O(n)</li></ol></blockquote></li><li><p><strong>空间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><p>该代码仅仅使用了一个数组的长度来存储每只怪兽会到达的时间，n为数组的长度，在这之后并未使用额外的空间了</p></blockquote><p>​<br>​</p><hr></li></ul></li></ul><center><span style="color:#0f39;font-size:30px;font-weight:bolder">END👌</span></center><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三步走套路递归问题</title>
      <link href="/2023/09/04/san-bu-zou-tao-lu-di-gui-wen-ti/"/>
      <url>/2023/09/04/san-bu-zou-tao-lu-di-gui-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="%E4%B8%89%E6%AD%A5%E8%B5%B0%E5%A5%97%E8%B7%AF%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98" tabindex="-1">三步走套路递归问题</h3><blockquote><p>写递归的题目的时候发现总是不清楚递归的次序和条件，当前的函数做了什么？它调用自身后的下一层又做了什么…这样想还是比较复杂的，思考了很久，在网上学习八股的知识的时候想到了具体的过程，下面就来说说看。</p></blockquote><h3 id="1.-%E4%B8%89%E6%AD%A5%E8%B5%B0%E5%A5%97%E8%B7%AF" tabindex="-1">1. 三步走套路</h3><ul><li><p>先上一张图片，里面清晰地记录了递归的过程和每一层所需要实现的作用。</p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/09/04/san-bu-zou-tao-lu-di-gui-wen-ti/3_step_picture.png" alt="3_step_picture" style="zoom:67%;"></li><li><p><strong>个人理解</strong>：递归，其实就是将一级递归（也就是最开始的那层递归），调用之后需要返回特定的值，一直递归直到找到终止条件。</p></li><li><p><strong>由此可见</strong></p><ol><li><strong>找整个递归的终止条件：递归应该在什么时候结束？</strong></li><li><strong>找返回值：应该给上一级返回什么信息？</strong></li><li><strong>本级递归应该做什么：在这一级递归中，应该完成什么任务？</strong></li></ol></li></ul><hr><h3 id="2.-%E4%B8%BE%E4%BE%8B%E5%AE%9E%E6%88%98" tabindex="-1">2. 举例实战</h3><ul><li><p><strong><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">Leetcode 24. 两两交换链表中的节点</a></strong></p></li><li><p>简单利用三部曲：1. 找到终止条件（也就是特例情况）；2. 找到前一个递归级的返回值；3.在当前的递归中需要什么（具体分析）</p></li></ul><blockquote><p>开始实际操作！</p></blockquote><h4 id="2.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">2.1 题目说明</h4><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：head = [1,2,3,4]输出：[2,1,4,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：head = []输出：[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：head = [1]输出：[1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><p>链表中节点的数目在范围 <code>[0, 100]</code> 内</p></li><li><p><code>0 &lt;= Node.val &lt;= 100</code></p></li></ul><hr><h4 id="2.2-%E5%A5%97%E8%B7%AF%E5%88%86%E6%9E%90" tabindex="-1">2.2 套路分析</h4><ol><li><p><strong>找终止条件。</strong> 什么情况下递归终止？没得交换的时候，递归就终止了，因此当链表只剩一个节点或者没有节点的时候，自然递归就终止了。</p></li><li><p><strong>找返回值。</strong> 我们希望向上一级递归返回什么信息？由于我们的目的是两两交换链表中相邻的节点，因此自然希望交换给上一级递归的是已经完成交换处理，即已经处理好的链表。</p></li><li><p><strong>本级递归应该做什么。</strong> 结合第二步，看下图！由于只考虑本级递归，所以这个链表在我们眼里其实也就三个节点：head、head.next、已处理完的链表部分。而本级递归的任务也就是交换这3个节点中的前两个节点。</p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/09/04/san-bu-zou-tao-lu-di-gui-wen-ti/3.png" alt="3" style="zoom:67%;"></li></ol><hr><h4 id="2.3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" tabindex="-1">2.3 代码实现</h4><p>​</p><ul><li><p><strong>具体的代码如下(java)：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public ListNode swapPairs(ListNode head) {      //终止条件：链表只剩一个节点或者没节点了，无法再次进行交换。返回的是已经处理好的链表        if(head == null || head.next == null){            return head;        }      //一共三个节点:head, next, swapPairs(next.next)      //下面的任务便是交换这3个节点中的前两个节点        ListNode next = head.next;        head.next = swapPairs(next.next);        next.next = head;      //根据第二步：返回给上一级的是当前已经完成交换后，即处理好了的链表部分，需要返回的值        return next;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h3 id="3.%E7%9B%B8%E4%BC%BC%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90" tabindex="-1">3.相似题目分析</h3><ul><li><p><a href="https://leetcode.cn/problems/invert-binary-tree/">Leetcode 226. 翻转二叉树</a></p><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​</p></li><li><p><strong>分析：</strong></p><ul><li><p><strong>终止条件</strong>：无法返回根节点<code>root</code>,也就是根节点此时为空<code>null</code></p></li><li><p><strong>找上一回递归的返回值</strong>：对于每次的翻转，我们希望返回的是对应枝节的根节点<code>root</code>，这里先不用考虑每一层的操作，反正最后返回的是该层的根节点</p></li><li><p><strong>本级递归的操作</strong>：每一层都会进行左右交换，首先确定左子树，接着将左子树的每个子节点依次进行递归左右交换操作，实现每一层的交换，递归从底到顶返回的时候再将原始的左子树和右子树进行交换即可。<strong>也就是要求使用两次递归，一次是左右子树之间的交换，一次是根左右子树之间的交换</strong>，最后返回上一级的递归结果</p></li></ul></li><li><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public TreeNode invertTree(TreeNode root) {        if(root==null){            return root;//终止        }        TreeNode leftafter=root.left;        root.left=invertTree(root.right);        root.right=invertTree(leftafter);                return root;//前一次的返回值    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><blockquote><p>最后：递归的套路还有很多需要实际上手体会，本文只介绍其中一个，希望可以用到以后的刷题实践中去吧</p></blockquote><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 918. 环形子数组的最大和</title>
      <link href="/2023/09/03/leetcode-918-huan-xing-zi-shu-zu-de-zui-da-he/"/>
      <url>/2023/09/03/leetcode-918-huan-xing-zi-shu-zu-de-zui-da-he/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-918.-%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C" tabindex="-1"><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">Leetcode 918. 环形子数组的最大和</a></h3><blockquote><p>概要：子数组的最大和利用的是动态规划/滑动窗口的思想，对于环形子数组，需要考虑的是前后元素之间的大小关系，比如[1,2,3,-4]，在环形数组中即为：[1,2,3,-4,1,2,3,-4…],我们要利用动态规划，找到区间子数组最小值和最大值，分别进行判断操作。</p></blockquote><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><ul><li><p>给定一个长度为 <code>n</code> 的<strong>环形整数数组</strong> <code>nums</code> ，返回 <em><code>nums</code> 的非空 <strong>子数组</strong> 的最大可能和</em> 。</p></li><li><p><strong>环形数组</strong> 意味着数组的末端将会与开头相连呈环状。形式上， <code>nums[i]</code> 的下一个元素是 <code>nums[(i + 1) % n]</code> ， <code>nums[i]</code> 的前一个元素是 <code>nums[(i - 1 + n) % n]</code> 。</p></li><li><p><strong>子数组</strong> 最多只能包含固定缓冲区 <code>nums</code> 中的每个元素一次。形式上，对于子数组 <code>nums[i], nums[i + 1], ..., nums[j]</code> ，不存在 <code>i &lt;= k1, k2 &lt;= j</code> 其中 <code>k1 % n == k2 % n</code> 。</p></li></ul><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,-2,3,-2]输出：3解释：从子数组 [3] 得到最大和 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​</p><hr><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><ul><li><p>首先需要明确的是：<code>环形子数组的最大和</code>包含两种可能性，一是直接动态规划得到子数组的最大和<code>MaxF</code>，二是环形子数组的出现循环，此时需要将元素之和<code>sum</code>减去子数组中的区间最小值<code>minS</code>后的值同<code>MaxS</code>进行比较.</p><ul><li><p>具体而言：由于是循环数组，我们可以选择将某一个区间剔除，计算剩余部分的最大子数组和。剔除的区间就是使得 <code>minS</code>取最小值的那个区间。</p></li><li><p>如果我们将剔除的区间放在数组的开头或结尾，那么剩余的部分即包含了原始数组的循环部分。</p><p>因此，<code>sum - minS</code> 就代表了考虑循环的情况下，剔除特定区间后剩余部分的最大子数组和。</p></li></ul></li><li><p>动态规划包含了对于数组元素的选或不选的问题，这里直接遍历即可.</p></li></ul><hr><h3 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3. 具体代码</h3><ul><li><p>该算法使用了动态规划的思想。通过遍历数组<code>nums</code>，维护以下变量：</p><ul><li><code>maxS</code>：最大子数组和，初值设为<code>负无穷大</code>。</li><li><code>minS</code>：最小子数组和，初值设为<code>0</code>（因为可以为空数组）。</li><li><code>maxF</code>：以当前元素为结尾的最大子数组和。</li><li><code>minF</code>：以当前元素为结尾的最小子数组和。</li><li><code>sum</code>：数组<code>nums</code>的总和。</li></ul></li><li><p><strong>代码如下：</strong></p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution{    public int maxSubarraySumCircular(int[] nums){        int maxS = Integer.MIN_VALUE; // 最大子数组和，不能为空        int minS = 0; // 最小子数组和，可以为空        int maxF = 0, minF = 0, sum = 0;        for (int x : nums) {            // 以 nums[i-1] 结尾的子数组选或不选（取 max）+ x = 以 x 结尾的最大子数组和            maxF = Math.max(maxF, 0) + x;            maxS = Math.max(maxS, maxF);            // 以 nums[i-1] 结尾的子数组选或不选（取 min）+ x = 以 x 结尾的最小子数组和            minF = Math.min(minF, 0) + x;            minS = Math.min(minS, minF);            sum += x;        }        return sum == minS ? maxS : Math.max(maxS, sum - minS);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>,其中的n代表数组<code>nums</code>的长度，代码使用了<strong>1次遍历进行计算最大子数组和最小子数组</strong></li><li><strong>空间复杂度</strong>：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq>,代码中仅使用了若干常数，为开辟新的存储空间</li></ul><p>​</p><hr><center><span style="font-size:30px;color:orange;font-weight:bolder">继续努力✊</span></center></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周赛360 T1与T2</title>
      <link href="/2023/08/27/zhou-sai-360-t1-yu-t2/"/>
      <url>/2023/08/27/zhou-sai-360-t1-yu-t2/</url>
      
        <content type="html"><![CDATA[<h3 id="%E5%91%A8%E8%B5%9B360%EF%BC%9At1%E4%B8%8Et2" tabindex="-1">周赛360：T1与T2</h3><blockquote><p>要说的话：隔了好多天又开始比赛了，还是2题选手，这回的前两题感觉还是比较容易想到的；后续的2题不太熟，所以等掌握了之后再回来补题解。</p></blockquote><h3 id="t1-.%E8%B7%9D%E7%A6%BB%E5%8E%9F%E7%82%B9%E6%9C%80%E8%BF%9C%E7%9A%84%E7%82%B9" tabindex="-1">T1 <a href="https://leetcode.cn/problems/furthest-point-from-origin/">.距离原点最远的点</a></h3><h4 id="1.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1.1 题目说明</h4><p>给你一个长度为 <code>n</code> 的字符串 <code>moves</code> ，该字符串仅由字符 <code>'L'</code>、<code>'R'</code> 和 <code>'_'</code> 组成。字符串表示你在一条原点为 <code>0</code> 的数轴上的若干次移动。</p><p>你的初始位置就在原点（<code>0</code>），第 <code>i</code> 次移动过程中，你可以根据对应字符选择移动方向：</p><ul><li>如果 <code>moves[i] = 'L'</code> 或 <code>moves[i] = '_'</code> ，可以选择向左移动一个单位距离</li><li>如果 <code>moves[i] = 'R'</code> 或 <code>moves[i] = '_'</code> ，可以选择向右移动一个单位距离</li></ul><p>移动 <code>n</code> 次之后，请你找出可以到达的距离原点 <strong>最远</strong> 的点，并返回 <strong>从原点到这一点的距离</strong></p><p>​</p><p><strong>示例1</strong>：</p><pre class="line-numbers language-none"><code class="language-none">输入：moves = "L_RL__R"输出：3解释：可以到达的距离原点 0 最远的点是 -3 ，移动的序列为 "LLRLLLR" 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​</p><hr><h4 id="1.2-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">1.2 解答分析</h4><ul><li><strong>分析</strong>：对于距离原点的距离，<code>_</code>是可以随意替换的（可左可右），此时决定最大的距离的是<code>L</code>与<code>R</code>的个数问题，是否可以抵消？接着加上<code>_</code>的个数即可。下面是具体的代码方法<ul><li>对于字符串的每一位，可以利用<code>charAt()</code>,也可以将字符串转化为字符串数组，利用<code>toCharArray</code>的方法。</li><li><code>L和R的个数的抵消</code>，想到的是利用减法进行，但是需要绝对值<code>Math.abs()</code></li></ul></li></ul><hr><h4 id="1.3-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">1.3 具体代码</h4><ul><li><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int furthestDistanceFromOrigin(String moves) {    int distance=0;    int r=0,l=0;    for(char m:moves.toCharArray()){        if(m=='_'){            distance++;        }        if(m=='L'){            l++;        }        if(m=='R'){            r++;        }    }    distance=distance+Math.abs(r-l);    return distance;            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><ul><li><p>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>，其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></eq>为$ moves$的长度。</p></li><li><p>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq>。仅用到若干额外变量</p></li></ul></li></ul><hr><h3 id="t2-%E6%89%BE%E5%87%BA%E7%BE%8E%E4%B8%BD%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%92%8C" tabindex="-1">T2 <a href="https://leetcode.cn/problems/find-the-minimum-possible-sum-of-a-beautiful-array/">找出美丽数组的最小和</a></h3><h4 id="2.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">2.1 题目说明</h4><p>给你两个正整数：<code>n</code> 和 <code>target</code> 。</p><p>如果数组 <code>nums</code> 满足下述条件，则称其为 <strong>美丽数组</strong> 。</p><ul><li><code>nums.length == n</code>.</li><li><code>nums</code> 由两两互不相同的正整数组成。</li><li>在范围 <code>[0, n-1]</code> 内，<strong>不存在</strong> 两个 <strong>不同</strong> 下标 <code>i</code> 和 <code>j</code> ，使得 <code>nums[i] + nums[j] == target</code> 。</li></ul><p>返回符合条件的美丽数组所可能具备的 <strong>最小</strong> 和。</p><p>​</p><p><strong>示例1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：n = 2, target = 3输出：4解释：nums = [1,3] 是美丽数组。- nums 的长度为 n = 2 。- nums 由两两互不相同的正整数组成。- 不存在两个不同下标 i 和 j ，使得 nums[i] + nums[j] == 3 。可以证明 4 是符合条件的美丽数组所可能具备的最小和。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><hr><h4 id="2.2-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2.2 解答分析</h4><ul><li><p><strong>分析1</strong>:</p><ul><li><p>这道题目需要用到贪心算法。一个简单的思路，假设我们期望加入1，那么 k - 1 就不再符合要求。但是1和k - 1之间，我们肯定选择1，因为很直观的1更小。因为提示给的范围很小1 &lt;= n, k &lt;= 50。暴力计数，只要n能满足。</p></li><li><p>具体这里用到的是<code>HashSet</code>，利用对数据元素（Object）的储存功能进行配对。<code>HashSet</code>的用法中不存在<code>键值对</code>的说法，本题要用到的<code>contains()</code>也仅代表的是值功能</p></li></ul></li><li><p><strong>分析2</strong>：</p><ul><li>数学方法，对元素进行模拟（找规律），将<code>target</code>记作<code>k</code>,对于全体元素而言，比如<code>1和k-1</code>两个只能选一个，因此可以直到<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k//2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">//2</span></span></span></span></eq>(表示向下取整,数学上直接<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">/2</span></span></span></span></eq>)，此时可以假设<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>k</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m=(min(k//2,n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">//2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></eq>,元素和为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(1+m)m/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mord mathnormal">m</span><span class="mord">/2</span></span></span></span></eq></li><li>同时，剩余的<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n-m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></eq>个数，只能从<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></eq>后面开始选，那么第二段就是从<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></eq>到<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k+n-m-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></eq>，元素和这里与上面雷同</li><li>将上述的两段之和相加即可</li></ul></li></ul><hr><h4 id="2.3-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">2.3 具体代码</h4><ul><li><p><strong>代码1：贪心算法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public long minimumPossibleSum(int n, int target) {    long res = 0;    int i = 1;    Set&lt;Integer&gt; set=new HashSet&lt;&gt;();    while(n&gt;0){        if(!(set.contains(i))){            set.add(target-i);            res+=i;            n--;        }        i++;        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><ul><li><p>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></eq></p><blockquote><p>其中的<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>是<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">set.contains()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ain</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span></eq>的时间复杂度</p></blockquote></li><li><p>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><p>HashSet额外开辟的存储空间n</p></blockquote></li></ul></li><li><p><strong>代码2：数学模拟</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public long minimumPossibleSum(int n, int k) {        long m = Math.min(k / 2, n);        return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><ul><li><p>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq></p></li><li><p>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq></p></li></ul></li></ul><hr><h3 id="%E6%80%BB%E7%BB%93" tabindex="-1">总结</h3><blockquote><p>路漫漫其修远兮，吾将上下而求索。刷题的路还很长，开学了要每天坚持学习算法知识，希望可以早日有所突破吧！加油，奥力给！</p><p>😉🤗</p></blockquote><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/08/27/zhou-sai-360-t1-yu-t2/Cyberpunk&amp;Bupt.jpg" alt="Cyberpunk&amp;Bupt" style="zoom:25%;"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 560:和为k的子数组</title>
      <link href="/2023/08/25/leetcode-560-he-wei-k-de-zi-shu-zu/"/>
      <url>/2023/08/25/leetcode-560-he-wei-k-de-zi-shu-zu/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-560%EF%BC%9A%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84" tabindex="-1">Leetcode-560：和为k的子数组</h3><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><ul><li><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 <strong>k</strong> 的<strong>连续的子数组</strong>的个数。</p><blockquote><p>示例 1 :</p><p>输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</p></blockquote></li></ul><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90%EF%BC%88%E5%90%AB%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%89" tabindex="-1">2. 解答分析（含复杂度）</h3><ul><li><p>题目本质上是可以利用暴力解决的，也就是用双重循环进行和为<code>k</code>的子数组的个数统计即可，但是这里我们想利用更多的方法，主要分为3部分：</p><ol><li><p><strong>暴力</strong></p></li><li><p><strong>前缀和</strong></p></li><li><p><strong>前缀和+HashMap</strong></p></li></ol><hr></li></ul><h3 id="%E2%91%A0-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95" tabindex="-1">① 暴力解法</h3><ul><li>直接上代码：</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int subarraySum(int[] nums, int k) {         int len = nums.length;         int sum = 0;         int count = 0;         //双重循环         for (int i = 0; i &lt; len; ++i) {             for (int j = i; j &lt; len; ++j) {                 sum += nums[j];                 //发现符合条件的区间                 if (sum == k) {                     count++;                 }             }             //记得归零，重新遍历             sum = 0;         }         return count;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>复杂度分析</strong>：<ul><li>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>，这里 $N $是数组的长度；</li><li>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq>。</li></ul></li></ul><hr><h3 id="%E2%91%A1-%E5%89%8D%E7%BC%80%E5%92%8C" tabindex="-1">② 前缀和</h3><ul><li>前缀和<code>pre[i]</code>的关键是找到前一个和后一个的关系，这里的连续子数组的元素之和恰好满足前缀求和的关系，所以可以采取。</li><li>需要注意的是：<ol><li>注意偏移，因为我们的<code>nums[2]</code>到<code>nums[4]</code>等于<code>pre[5]-pre[2]</code>，所以这样就可以得到<code>nums[i,j]</code>区间内的和</li><li>前缀和是从<code>pre[1]</code>开始填充的</li></ol></li><li>上代码：</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int subarraySum(int[] nums, int k) {        //前缀和数组        int[] presum = new int[nums.length+1];        for (int i = 0; i &lt; nums.length; i++) {            pre[i+1] = nums[i] + pre[i];        }        //统计个数        int count = 0;        for (int i = 0; i &lt; nums.length; ++i) {            for (int j = i; j &lt; nums.length; ++j) {                              if (pre[j+1] - pre[i] == k) {                    count++;                }            }        }        return count;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析</strong>：</p><ul><li><p>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>，这里 N 是数组的长度；</p></li><li><p>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>。</p></li></ul></li></ul><hr><h3 id="%E2%91%A2-%E5%89%8D%E7%BC%80%E5%92%8C-%2B-hashmap" tabindex="-1">③ 前缀和 + HashMap</h3><ul><li><p>分析上述的前缀和方法不难看出：该代码虽然用到了前缀和数组，但是对比暴力法并没有提升性能，时间复杂度仍为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>，空间复杂度成了 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>。</p></li><li><p>在两数之和的题目中，我们可以看出利用<code>HashMap</code>进行的遍历求解，只用遍历循环数组一次即可，这里我们同样采用的做法是，我们将数组的值和索引存入<code>map</code>中，当我们遍历到某一值 <code>x </code>时，判断 <code>map </code>中是否含有<code> target - x</code>即可。</p></li><li><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int[] twoSum(int[] nums, int target) {        HashMap&lt;Integer,Integer&gt; map  = new HashMap&lt;&gt;();        //一次遍历        for (int i = 0; i &lt; nums.length; ++i) {            //存在时，我们用数组得值为 key，索引为 value            if (map.containsKey(target - nums[i])){                             return new int[]{i,map.get(target-nums[i])};            }            //存入值            map.put(nums[i],i);        }        //返回        return new int[]{};    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><blockquote><p>我们完全可以通过 presum - k的个数获得 k 的个数,如图所示:</p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/08/25/leetcode-560-he-wei-k-de-zi-shu-zu/presum-k.png" alt="presum-k" style="zoom:67%;"></blockquote></li><li><p>本题的代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int subarraySum(int[] nums, int k) {        if (nums.length == 0) {            return 0;        }        HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();        //细节，这里需要预存前缀和为 0 的情况，会漏掉前几位就满足的情况        //例如输入[1,1,0]，k = 2 如果没有这行代码，则会返回0,漏掉了1+1=2，和1+1+0=2的情况        //输入：[3,1,1,0] k = 2时则不会漏掉        //因为presum[3] - presum[0]表示前面 3 位的和，所以需要map.put(0,1),垫下底        map.put(0, 1);        int count = 0;        int presum = 0;        for (int x : nums) {            presum += x;            //当前前缀和已知，判断是否含有 presum - k的前缀和，那么我们就知道某一区间的和为 k 了。            if (map.containsKey(presum - k)) {                count += map.get(presum - k);//获取次数            }            //更新            map.put(presum,map.getOrDefault(presum,0) + 1);        }        return count;    }}//或者是：class Solution {    public int subarraySum(int[] nums, int k) {        /*        前缀和+HashMap(两数之和进阶版)        若存在i与j满足sum[i,j]=sum[j+1]-sum[i]=k，对于j+1，满足条件的i的个数可以先统计出来        前面符合条件的数据为:sum[i]=sum[j+1]-k，这里注意是i&lt;=j，因此需要先统计了前面的再更新当前的        与两数之和是差不多的思路，不过这个多了个前缀和        时间复杂度:O(N) 空间复杂度:O(N)         */        int res = 0;        // 前缀和还可以进一步空间优化        int sum = 0;        // 哈希表存储前缀和数组中缺少了某个数的个数        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        map.put(0, 1);  // 初始前缀和        for (int num : nums) {            sum += num;            // 先统计            res += map.getOrDefault(sum - k, 0);            // 再更新当前的            map.put(sum, map.getOrDefault(sum, 0) + 1);        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>复杂度分析</strong>：</p><ul><li><p>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>，这里 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></eq>是数组的长度；</p></li><li><p>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>。</p></li></ul></li></ul><hr><h3 id="3.-%E5%8F%98%E5%BC%8F%E9%A2%98%E7%9B%AE" tabindex="-1">3. 变式题目</h3><blockquote><p><a href="https://leetcode.cn/problems/count-number-of-nice-subarrays/">1248. 统计「优美子数组」</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。如果某个连续子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「<strong>优美子数组</strong>」。</p><p>请返回这个数组中 <strong>「优美子数组」</strong> 的数目。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,1,2,1,1], k = 3输出：2解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><p>分析解答：类似，只是在遇到奇数的时候将prenum更新而已。类似于<code>HashMap</code>,这里用数组的索引来表示哈希表中的<code>key</code>，对应的值模拟哈希表中的<code>value</code>.代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int numberOfSubarrays(int[] nums, int k) {        int len=nums.length;        int []map=new int[len+1];        map[0]=1;        int oddnum=0;        int count=0;        for(int i=0;i&lt;len;i++){            if(nums[i]%2!=0){//如果是奇数的话，存入oddnum                oddnum++;            }            if(oddnum&gt;=k){                count+=map[oddnum-k];            }            map[oddnum]++;        }        return count;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="4.-%E5%B1%95%E6%9C%9B%EF%BC%88%E4%B8%8E%E9%A2%98%E7%9B%AE%E6%97%A0%E5%85%B3%EF%BC%89" tabindex="-1">4. 展望（与题目无关）</h3><blockquote><p>开学了，还是会继续学习算法，刷力扣，博客也会经常更新自己的学习动态，加油哇！🤗👍大三希望有机会找到一份实习，前后端都行，美化简历😊</p></blockquote><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/08/25/leetcode-560-he-wei-k-de-zi-shu-zu/Bupt.jpg" alt="Bupt" style="zoom:20%;">  <center><span style="font-size:30px;color:red;font-weight:bolder;">END~</span><center><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css"></center></center>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PriorityQueue实现最小堆和最大堆的用法[JAVA]</title>
      <link href="/2023/07/27/priorityqueue-shi-xian-zui-xiao-dui-he-zui-da-dui-de-yong-fa-java/"/>
      <url>/2023/07/27/priorityqueue-shi-xian-zui-xiao-dui-he-zui-da-dui-de-yong-fa-java/</url>
      
        <content type="html"><![CDATA[<h3 id="%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D" tabindex="-1">一、基本介绍</h3><ol><li><p><strong>介绍</strong></p><p>PriorityQueue翻译为优先队列，“优先”指元素在队列中按一定的顺序（优先级）进行存放，“队列”指一种先进先出的数据结构。因此PriorityQueue可以实现按照一定的优先级存取元素。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/07/27/priorityqueue-shi-xian-zui-xiao-dui-he-zui-da-dui-de-yong-fa-java/%E7%AE%80%E4%BB%8B.png" alt="简介"></p></li><li><p><strong>用法</strong></p></li></ol>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">//默认容量为 11  private static final int DEFAULT_INITIAL_CAPACITY = 11;  //1、无参构造，默认容量和默认排序方法  public PriorityQueue() {          this(DEFAULT_INITIAL_CAPACITY, null);      }  //2、指定容量  public PriorityQueue(int initialCapacity) {          this(initialCapacity, null);      }  //3、指定排序方法  public PriorityQueue(Comparator&lt;? super E&gt; comparator) {          this(DEFAULT_INITIAL_CAPACITY, comparator);      }  //4、指定容量和排序方法  public PriorityQueue(int initialCapacity,                           Comparator&lt;? super E&gt; comparator) {          // Note: This restriction of at least one is not actually needed,          // but continues for 1.5 compatibility          if (initialCapacity &lt; 1)              throw new IllegalArgumentException();          this.queue = new Object[initialCapacity];          this.comparator = comparator;      }  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在构造PriorityQueue时候我们可以指定初始容量和元素在队列中的排序方法，如果不指定，则默认初始容量为11，默认的排序方式是将元素从小到大进行排序。</p></blockquote><ol start="3"><li><strong>最小堆构造</strong></li></ol>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">PriorityQueue&lt;Integer&gt; minheap = new PriorityQueue&lt;&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用无参构造，元素在队列中按照默认从小到大的顺序排列，可以保证每次出队列的元素都是队列中的最小的元素。</li></ul><ol start="4"><li><p><strong>最大堆构造</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">PriorityQueue&lt;Integer&gt; maxheap = new PriorityQueue&lt;&gt;(Collections.reverseOrder());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>将排序方法指定为反序，元素是从大到小的顺序排列，也就是保证每次出队列的元素是队列中的最大的元素。</li></ul></li></ol><h3 id="%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95" tabindex="-1">二、常用的方法</h3><ul><li><p>以<code>Integer</code>的类型为例：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/07/27/priorityqueue-shi-xian-zui-xiao-dui-he-zui-da-dui-de-yong-fa-java/%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95.png" alt="常见用法"></p></li></ul><p>​</p><hr><h3 id="%E4%B8%89%E3%80%81%E4%B8%BE%E4%BE%8B" tabindex="-1">三、举例</h3><blockquote><p>Leetcode 2208. 将数组和减半的最少操作次数</p></blockquote><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><p>给你一个正整数数组 <code>nums</code> 。每一次操作中，你可以从 <code>nums</code> 中选择 <strong>任意</strong> 一个数并将它减小到 <strong>恰好</strong> 一半。（注意，在后续操作中你可以对减半过的数继续执行操作）</p><p>请你返回将 <code>nums</code> 数组和 <strong>至少</strong> 减少一半的 <strong>最少</strong> 操作数。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [5,19,8,1]输出：3解释：初始 nums 的和为 5 + 19 + 8 + 1 = 33 。以下是将数组和减少至少一半的一种方法：选择数字 19 并减小为 9.5 。选择数字 9.5 并减小为 4.75 。选择数字 8 并减小为 4 。最终数组为 [5, 4.75, 4, 1] ，和为 5 + 4.75 + 4 + 1 = 14.75 。nums 的和减小了 33 - 14.75 = 18.25 ，减小的部分超过了初始数组和的一半，18.25 &gt;= 33/2 = 16.5 。我们需要 3 个操作实现题目要求，所以返回 3 。可以证明，无法通过少于 3 个操作使数组和减少至少一半。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="2.-%E5%88%86%E6%9E%90%E8%A7%A3%E7%AD%94" tabindex="-1">2. 分析解答</h3><ul><li>常见的题目，由于每一次操作都会使得数组中的一个数字减半。要想使得总的数组中的减少的次数最少，<strong>其实就是从当前的数组中选取最大值进行减半的操作</strong></li><li>这里可以利用大根堆（优先队列）维护数组中的所有数，每次都是从优先队列中取出最大值 ttt，将其减半，然后将减半后的数重新放入优先队列中，同时更新 <code>s</code>，直到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">s≤0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></eq>为止。那么此时的操作次数就是答案。</li><li>用到的算法知识点是：贪心算法（每次选取队列中的最大值）+优先队列（大根堆，每次都更新排列）</li></ul><hr><h3 id="3.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" tabindex="-1">3.代码实现</h3><ul><li>Java代码（利用上述的<code>PriorityQueue</code>队列知识）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int halveArray(int[] nums) {        double s=0;        PriorityQueue&lt;Double&gt; q = new PriorityQueue&lt;&gt;(Collections.reverseOrder());        //上述的是最大堆，确保每次都是队列中最大的数出来,元素从大到小排列        for(int i:nums){            q.offer(i*1.0);//注意除半时候出现的浮点数值，先进行转换，添加队列中去            s+=i;//s为根堆（优先队列）元素之和        }        s/=2.0;//取半        int ans=0;        while(s&gt;0){//循环，直到s&lt;=0为止            double t =q.poll();//队头元素出列（当前的最大值）            s-=t/2.0;  //元素值减半，从s值中减去            q.offer(t/2.0);  //更新队列中的元素，找到最大值            ++ans;        }        return ans;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n * log_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>​</strong>。</p></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>​</strong>，其中的n指的是数组的长度。</p></li></ul><hr><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消失的她</title>
      <link href="/2023/07/10/xiao-shi-de-ta/"/>
      <url>/2023/07/10/xiao-shi-de-ta/</url>
      
        <content type="html"><![CDATA[<h3 id="%E6%B6%88%E5%A4%B1%E7%9A%84%E5%A5%B9%E5%BD%B1%E8%AF%84" tabindex="-1">消失的她影评</h3><blockquote><p>当利益过于庞大的时候，人性的阴暗面就会展露出来</p></blockquote><p>7月9号和哥们去看了《消失的她》，虽然之前在营销号内已经看过大致的剧情走向，但是真正到电影院里看完全片后，又有了不同的感觉。倒不是对爱情观又有什么执念了😂（毕竟牡丹20年），这里重点讨论人性和选择。</p><hr><h3 id="1.-%E6%95%85%E4%BA%8B%E6%A6%82%E8%BF%B0" tabindex="-1">1. 故事概述</h3><ul><li><p>《消失的她》讲述了这样一个故事：东南亚某地，何非（朱一龙 饰）的老婆李木子，突然失踪了。何非去警察局报案，结果第二天，他的床上莫名空降了个陌生女人。陌生女人说，她就是李木子，并且还拿出了照片作为证据。但，即使看到了所谓的证据，何非也还是不相信陌生女人。真正的李木子不见了踪影，成为了“消失的她”。随着剧情的发展，一张精心设置好的大局慢慢展开，凶手的身份逐渐明显起来。</p></li><li><p>作为一部悬疑片电影，和爱情扯上关系显然有点不合适，其实在电影放到一半时，也就是赌徒出现的时候，大概率就已经猜到了凶手正是丈夫何非。可是在看完电影后，内心却很难平静，倒不是因为剧情带来的震撼，相反，剧情给我的感觉和国外的悬疑电影很像，有反转但不多，细想也都合乎情理（至少符合角色的身份）。带给我震撼的其实是何非这个角色的设定，从最初的寻妻心切的“好丈夫”，到“亡命奔走”的赌徒，这才是人性的多面性所在，也是电影中最具阴暗面的地方。</p><hr></li></ul><h3 id="2.%E4%BA%AE%E7%82%B9%E5%88%86%E6%9E%90" tabindex="-1">2.亮点分析</h3><blockquote><ol><li>何非的回忆</li></ol></blockquote><ul><li>在电影中，可以很清楚地看到何非的回忆录，按照他的描述，他和李木子二人很恩爱，从第一段在潜水馆中救下险些溺水得李木子，到一起聊艺术，去看梵高的《星空》，再到车祸发生，出现了何非的表白“我会一辈子在你身边保护你”。回忆至此，故事画面充满了幸福和甜蜜，可是，从遇见到恋爱到结婚，这一切都是如此顺利，仿佛暗中已经挖好了陷阱，等待李木子的到来…</li><li>电影开始并未介绍何非的职业和爱好，留给观众的只有一个寻妻的丈夫形象，作为婚姻的一方，倘若二者发自内心深爱，妻子的失踪必然会引起丈夫的心急。何非确实这样做了，也正如他回忆录中所描述的一般，最初看电影的时候也是这样想的。但是随着后续剧情的进展，出现假李木子之后，何非的关注重心仿佛从真李木子身上转移，当前的首要目标是“除去假李木子”，为什么着急立案？为什么害怕假妻子的出现？为什么当问及李木子的时候总是会开始回忆过去的美好点滴，对妻子的失踪避而不谈，在整部电影中，何非的回忆是串联起这一切的关键线索，为后续的反转一步步埋下伏笔。</li></ul><blockquote><ol start="2"><li>陈麦（沈曼）的出现</li></ol></blockquote><ul><li>李木子最好的闺蜜是沈曼，在木子失踪后，沈曼本应该第一时间出现，但是站在何非的角度却从未出现过？所以，最初金牌律师陈麦的出现，明显就有暗示。剧中也有大量相关的片段镜头，诸如李木子和陈麦泡茶时都喜欢放柠檬，杯子底下的‘M’标记和表演箱上的M呼应，是否暗示着一切都是设好的局？</li><li>其次，在假李木子出现的时候，何非的眼神并不是害怕，感觉更多地是一种慌张。他以为这是曼曼的安排（曼曼本身对他就有偏见），所以才在一步步布局当中找到所谓的金牌律师陈麦，想着将假妻子的事情弄下去，自己好快速立案得到凭证。沈曼也是利用了赌徒的心理暗示，不愿相信任何人，除非可以对其利益实现最大化的特征，将何非圈在自己设定的陷阱当中。</li></ul><blockquote><ol start="3"><li>潜水和沙滩</li></ol></blockquote><ul><li><p>在本部电影中，令我感触最深的就是所谓的“海底星空”和阳光轻掠过的沙滩。电影中这两处场景的色调截然相反，代表着何非和李木子二人的性格特征和心理变化历程。</p><ul><li><p>何非对应的是海底的幽暗和未知，在其深潜馆中的上浮，我感觉更像一种自我的安慰救赎，而不是对生命的尊重和渴望，以至于后来到海底的“星空”，更像是一种未知的牢笼，将所谓的爱情和欲望深深锁在海底，不见光明，令人感受到郁闷和压抑。</p></li><li><p>李木子则是在温暖的海滩下留下了背影，将何非的脸照亮，更多是一种类似于乌托邦的幻想和对爱情的向往，这种渴望不是物欲的追求，相反，是明知物欲横流，却仍然想将爱留在彼此心间。所以这里的阳光和沙滩代表着爱情和爱人的简单纯粹，不带杂念，将彼此存储于世间温暖的阳光里。</p></li></ul><hr></li></ul><h3 id="3.-%E8%A7%82%E5%BD%B1%E6%84%9F%E6%82%9F" tabindex="-1">3. 观影感悟</h3><ol><li>相信世间仍然存在爱情，但是在爱中不要忽视人性中的恶与贪，切勿将个人的欲念强加于双方，甚至混融在婚姻生活中。<ul><li>爱情和婚姻仍然是两码事，学会了爱人，但是不一定学会了长久得爱人和生活，一旦对物欲得渴望超过了两人之间的能力匹配关系，那必然会导致婚姻的失衡，甚至走向破灭。</li></ul></li><li>“让你看到海底星空，但却将你置于黑暗的牢笼。”人性的恶如果被激活、放大了，那就无所谓对与错了，因为恶本身就是二者权衡的产物，只要有了开端和征兆，就会被无限放大直至坠落。<ul><li>就如影片中的何非好赌，从他开始押下赌注的时候，内心的恶被激活，他所做的一切是为了自己服务，在他眼中是正确的、合理的，可是在外人眼中确实错误的、疯狂的，以至于最后那婚姻作为最大的赌注。</li></ul></li><li>最后说一些恋爱相关的话题，虽然我是牡丹，但是目前和未来希望可以获得一段健康、积极的恋爱关系，双方不是彼此的附属品，更不是因为物质匹配来的恋爱。<ul><li>影片中的‘李木子’，说实话有些恋爱脑，也就是在爱情、婚姻中始终扮演着弱势的一方，渴望得到陪伴与爱，但是前提是需要对方的同意，把个人的想法寄托在他人身上，是不明智的。</li><li>我觉得，一段积极健康的恋爱关系，双方应该是彼此的肩膀，而非靠山，也就是生活里需要你的安慰和鼓励，并不是直接的索取和丢弃，我可以成为你的“消息中转站”，为你暂时排忧解难、分享与分担，等到心情变好的时候再将“消息”归还，由你自己处理；而不是你的“垃圾桶”，将所有不好归咎到对方，将负面消息发送给对方就置之不理。</li><li>希望在未来可以遇到合适的人吧。虽然看完电影后劲有点大，但是对于爱情，依然保持憧憬和向往~~</li></ul></li></ol><p><span style="color:lightblue;font-size:2em;">End~</span></p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 55：跳跃游戏</title>
      <link href="/2023/07/08/leetcode-55-tiao-yue-you-xi/"/>
      <url>/2023/07/08/leetcode-55-tiao-yue-you-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-55%EF%BC%9A%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89" tabindex="-1">Leetcode 55：跳跃游戏（贪心）</h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h4><ul><li><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。 <strong>判断你是否能够到达最后一个下标</strong></p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><hr><h4 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h4><ul><li><strong>分析：</strong></li><li><ul><li>本题的关键是对于每一步的把控，例如当处于<code>nums[0]</code>时，此时的值为<code>2</code>，也就是可以跳跃一步或者两步，这样下去对应数组中的每个数字都可以由不同的<code>跳跃方法</code>。</li><li><strong>但是我们要注意：每个位置跳多少步不是关键，而是最后的跳跃范围是否可以覆盖到最后一个数（也就是终点）</strong> 那么我们可以尝试每次移动取最大的跳跃步数（目的是得到最大的范围），依次更新覆盖的范围。</li><li><strong>本题的贪心算法的关键是：<mark>局部最优解</mark>，每次取最大的跳跃步数（取最大的覆盖范围）；<mark>整体最优解：</mark> 最后得到整体的最大覆盖范围，看看能否到达最后一个数（终点）</strong></li></ul></li></ul><hr><ul><li><p><strong>代码：</strong></p></li><li><pre class="line-numbers language-language-Java"><code class="language-language-Java">class Solution{    public boolean canJump(int[] nums){        if(nums.length==1){            return true;//特例：第一个数字自己就是终点        }        //开始覆盖范围        int cover=nums[0];//初始值        //在第一个数的覆盖范围内继续不断地更新最大覆盖范围        for(int i=0;i<=cover;i++){        //这里之所以可以取等，因为我们要求的相当于是每个位置的数值，那当然可以取等，如nums[0]==3,那么我们可以跳跃三次到nums[3],再更新最大范围;    cover=Math.max(cover,i+nums[i]);//当前的编号，加上可跳跃的数值，即为范围        if(cover>=nums.length-1){//覆盖范围可以到达最后一个数字的下标（终点）            return true;        }          }        return false;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h4 id="3.-%E6%80%BB%E7%BB%93" tabindex="-1">3. 总结</h4><ul><li><p>**时间复杂度考虑最坏的情况，如果全部元素都是1，那么循环需要n-1次，时间复杂度为：O(n); **</p></li><li><p><strong>空间复杂度：由于只引入了若干变量，未占用内存存储空间：O(1)</strong></p></li></ul><blockquote><center><span style="color:red;font-weight:3em;font-size:2em;">继续努力</span></center></blockquote><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双周赛100 T1：把钱分给最多的儿童</title>
      <link href="/2023/07/07/shuang-zhou-sai-100-t1-ba-qian-fen-gei-zui-duo-de-er-tong/"/>
      <url>/2023/07/07/shuang-zhou-sai-100-t1-ba-qian-fen-gei-zui-duo-de-er-tong/</url>
      
        <content type="html"><![CDATA[<h3 id="%E5%8F%8C%E5%91%A8%E8%B5%9B100t1%EF%BC%9A%E5%B0%86%E9%92%B1%E5%88%86%E7%BB%99%E6%9C%80%E5%A4%9A%E7%9A%84%E5%84%BF%E7%AB%A5" tabindex="-1">双周赛100T1：将钱分给最多的儿童</h3><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><p>​给你一个整数 <code>money</code> ，表示你总共有的钱数（单位为美元）和另一个整数 <code>children</code> ，表示你要将钱分配给多少个儿童。</p><p>​你需要按照如下规则分配：</p><ul><li><p>所有的钱都必须被分配。</p></li><li><p>每个儿童至少获得 <code>1</code> 美元。</p></li><li><p>没有人获得 <code>4</code> 美元。</p><p>请你按照上述规则分配金钱，并返回 <strong>最多</strong> 有多少个儿童获得 <strong>恰好</strong> <code>8</code> 美元。如果没有任何分配方案，返回 <code>-1</code>.</p></li></ul><hr><ul><li><p><strong>示例</strong>：</p></li><li><pre><code>输入：money = 20, children = 3输出：1解释：最多获得 8 美元的儿童数为 1 。一种分配方案为：- 给第一个儿童分配 8 美元。- 给第二个儿童分配 9 美元。- 给第三个儿童分配 3 美元。没有分配方案能让获得 8 美元的儿童数超过 1 。</code></pre></li></ul><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><ul><li><strong>分析：</strong></li><li><ul><li>最开始一以为这类题目都是直接模拟来做，但是发现限定条件有点多，主要是不好分类。这里<code>条件2:每个儿童至少获得1美元</code>，这里需要保证的是儿童分到的钱不为<code>0</code>，至少为<code>1</code>。<mark>换句话说就是先给每个儿童分配1美元</mark>  //对应的是：money-children。此时如果money&lt;0，那么直接返回-1。</li><li>然后<code>目的：返回获得8美元的儿童的最大数量</code>，此时条件改为每个获得<code>7</code>美元的儿童最大个数，我们将此时的money / 7 ，让尽可能多的儿童分到<code>7</code>美元，并向下取整，并且需要同当前的儿童的个数进行对比，不能够超过儿童实际人数，返回的是<code>ans=Math.min(money/7,children);</code>并且此时的<code>money-=ans*7;//最后的钱数</code>,<code>children-=ans;//剩余的未分配的儿童人数</code>。</li><li>此时开始判定<code>条件1和条件3：每个人都必须分配，没有儿童分到了4美元</code>。<ul><li><ol><li>如果此时剩余<code>0</code>人，也就是全部儿童都分完了（钱数都是<code>8</code>）,如果money&gt;0,说明还需要再分给一个儿童，也就是<code>ans-1</code>,有一个儿童不是8。</li></ol></li><li><ol start="2"><li>如果此时剩余1人（此时此人的钱数是<code>1</code>），且<code>money=3</code>,为了避免分配<code>4</code>美元，需要的是将此时的<code>3</code>分配给一个分到<code>8</code>的儿童，此时<code>ans-1</code>;</li></ol></li><li><ol start="3"><li>其余情况全部给一个人，如果这个人分配到<code>4</code>美元，那么它可以继续分给其他人，<code>ans</code>的总数保持不变。(<strong>也就是剩余money的值无非是mod7的正整数剩余系，4，5；6就进一位了，人数向下取整的时候要+1;对应的人数也是如此，剩余2、3…人数越多越可以分配剩余钱数不到4美元</strong>)。</li></ol></li></ul></li></ul></li></ul><hr><h3 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3. 具体代码</h3><ul><li><p><strong>代码</strong>：</p></li><li><pre class="line-numbers language-language-Java"><code class="language-language-Java">class Solution{    public int distMoney(int money,int children){        money-=chilrdren;//最开始的每个人初始值要为1        if(money<0) return -1;//不满足每个儿童获得钱数至少为1的条件，返回-1、        int ans=Math.min(money/7,children);        money-=ans*7;        children-=ans;        if(children==0 && money>0          ||children==1 && money==3){            ans--;        }        return ans;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>总结：</strong> <strong>时间复杂度为O(1),未用到循环遍历</strong>；<strong>空间复杂度为：O(1)，仅使用了若干额外的变量。</strong></p></li></ul><hr><p><span style="color:lightblue;font-size:30px;">END~</span></p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/07/07/shuang-zhou-sai-100-t1-ba-qian-fen-gei-zui-duo-de-er-tong/2.jpg" alt="2" style="zoom:80%;"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Offer26：重排链表</title>
      <link href="/2023/07/07/offer26-chong-pai-lian-biao/"/>
      <url>/2023/07/07/offer26-chong-pai-lian-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="offer26%EF%BC%9A%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8" tabindex="-1">Offer26：重排链表</h3><hr><h3 id="1.-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" tabindex="-1">1. 题目描述</h3><ul><li><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><p><code>L0 → L1 → … → Ln-1 → Ln</code><br>请将其重新排列后变为：</p><pre class="line-numbers language-none"><code class="language-none">L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例 1:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入: head = [1,2,3,4]输出: [1,4,2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr></li></ul><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><ul><li><p><strong>分析：</strong> 这题不难发现，最后需要输出的链表其实是<code>前半部分</code>和<code>后半部分的翻转</code>,接着再头连着头，依次进行排序输出。</p><ul><li>所以最原始的方法是需要3个不同的函数功能。<ol><li><code>reorderList()</code>函数：主函数，用于均分两半链表，并将它们进行操作。</li><li>``reverse()`函数：翻转后半部分的链表。</li><li><code>link()</code>函数：用于连接前半部分链表、后半部分链表。</li></ol></li></ul><hr></li><li><p><strong>代码：</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution{    public void recorderList(ListNode head){        ListNode dummy=new ListNode(0);        dummy.next=head;//哨兵        ListNode fast=dummy;//快指针        ListNode slow=dummy;//慢指针       while(fast!=null &amp;&amp; fast.next!=null){           slow=slow.next;           fast=fast.next.next;       }                ListNode temp=slow.next;//中间节点的指针暂定为temp        slow.next=null;//准备连接，slow.next为空了        link(head,reverse(temp),dummy);//开始连接    }    private ListNode reverse(ListNode head){//反转链表，注意指针的指向位置        ListNode prev=null;        ListNode cur=head;        while(cur!=null){            ListNode next=cur.next;            cur.next=prev;            prev=cur;            cur=next;        }        return prev;    }    private void link(ListNode node1,ListNode node2,ListNode head){//借助原链表的头结点head（在本题函数中指的是哨兵节点dummy）,按照题目要求连接前后两部分，新链表的头节点为prev        ListNode prev=head;        while(node1!=null &amp;&amp; node2!=null){            ListNode temp=node1.next;//当前node1节点的下一个位置为temp                       prev.next=node1;//prev指针指向node1部分第一个节点            node1.next=node2;//node1后面连的是反转后node2的第一个            prev=node2;//prev开始下一次连接                        node1=temp;//node1后移            node2=node2.next;//node2后移        }        if(node1!=null){            prev.next=node1;//这一个if是用来判断前半部分链表必须比后半部分多，当node1无法匹配连接node2时，直接连接返回node1的节点值。        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr></li></ul><h3 id="3.-%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93" tabindex="-1">3. 思考总结</h3><ul><li><p><strong>思考：</strong> 其实代码不用写三个函数，用在一个函数内部即可，不需要来回调用，实现<code>折半翻转再重连</code>即可。代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution {    public void reorderList(ListNode head) {        ListNode f = head, s = head;        while (f.next != null &amp;&amp; f.next.next != null) {            s = s.next;//慢指针找到中间的节点            f = f.next.next;//快指针直接到末尾节点        }        ListNode t = s.next;//暂存的t节点是慢指针的下一位        f=null;//快指针此时位于最后一个节点，赋值为空        while (t != null) {//翻转            t = s.next;            s.next = f;            f = s;            s = t;        }        s = head;//这里是将后半部分翻转。此时快指针指向原链表的最后一位元素        while (s != null) {//再重新进行连接            t = s.next;//保留当前位置的下一位            s.next = f;//后半部分的最后一位            s = f;            f = t;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>END</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/07/07/offer26-chong-pai-lian-biao/1.jpg" alt="1"></p></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指Offer（专项） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 1.两数之和</title>
      <link href="/2023/07/07/leetcode-1-liang-shu-zhi-he/"/>
      <url>/2023/07/07/leetcode-1-liang-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C" tabindex="-1">Leetcode 1.两数之和</h3><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><ul><li><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​</p></li></ul><hr><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><ul><li>本题有好多种解法，这里选择两种常见的解法，一种是直接上循环，不断遍历数组；另外一种是利用哈希表，返回对应表的下标（利用<code>key</code> 和<code>value</code>）</li></ul><h4 id="%E6%96%B9%E6%B3%951%EF%BC%9A%E5%88%A9%E7%94%A8%E9%81%8D%E5%8E%86%E6%A8%A1%E6%8B%9F" tabindex="-1">方法1：利用遍历模拟</h4><ul><li>本题要求的是返回两个数字和为<code>target</code>的数组元素的下标，这里可以直接交换遍历，比如最简单的for循环，我们会把两个指针所指向的值之和，依次比较，最后返回数组元素的下标（构建新的数组）</li></ul>  <pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution{    public int[] twoSum(int []nums,int target){        int j=1;        int i=0;        int maxLen=nums.length-1;        while(nums[i]+nums[j]!=target){            if(j==maxLen)}{            i++;            j=i;        }        j++:        }    return new int[]{i,j};    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>时间复杂度：O(n<sup>2</sup>)</strong>,一个是i，另外一个是j的循环遍历，至少需要**n(n-1)**的步骤；<strong>空间复杂度为O(1)</strong></p><p>​</p><p>​</p></li></ul><h4 id="%E6%96%B9%E6%B3%952%EF%BC%9Ahash%E8%A1%A8" tabindex="-1">方法2：Hash表</h4><ul><li><p>Hash表是一种数据结构关系，利用<code>键(key)</code>和<code>值(value)</code>的<code>一一对应</code>的关系，生成map。map目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）</p></li><li><p>在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素</p><ul><li>本题的map我们这样定义：<code>key</code>为数组中的num[i]值，对应的<code>value</code>为 ：下标元素i；</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution{    public int[] twoSum(int[] nums,int target){        int[]res=new int[2];//首先生成最后需要返回的数组，保存的是数组的元素下标        if(nums==null || nums.length==0){            return res;//考虑特例        }        Map&lt;Integer,Integer&gt;map=new HashMap&lt;&gt;();//建立HashMap        for(int i=0;i&lt;nums.length;i++){            int temp=target-nums[i];//从第i个元素开始，看看当前的元素数组中是否存在可以满足条件的值            if(map.containsKey(temp)){                res[1]=i;                res[0]=map.get(temp);//这里的get返回的是满足条件的temp数组元素的下标，注意我们定义Value是数组元素的下标，对应的Key是数组元素的值                break;//跳出循环            }            map.put(nums[i],i);//如果没有找到匹配的对，对于大的循环而言，只需要在HashMap中添加对应的nums值和下标即可，为后续的元素查找匹配提供map数据资源。        }        return res;//返回需要的元素数组下标的新数组    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>复杂度分析</strong>：</p><ul><li><p><strong>时间复杂度：O(n)</strong>，利用HashMap的数据结构大大提高了查找的效率，就相当于是额外开辟内存空间进行数组元素的值、下标的匹配关系映射，通过牺牲空间复杂度换取时间、效率的提高。</p></li><li><p><strong>空间复杂度为：O(n),（相当于为每个元素都开辟了n-1的空间）。</strong></p></li></ul><p>​</p></li></ul><hr><h3 id="3.%E6%80%BB%E7%BB%93" tabindex="-1">3.总结</h3><ul><li>这道题很经典，其实还有很多其他的解法，这里由于篇幅就不一一介绍了。对于不同的数据结构和算法而言，我们实现的目标、途径都是不同，同样，时间和空间的各自复杂度的考虑也存在差异，多加练习，多多增加对于每道题目的不同思考方式，继续加油！</li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>First_In</title>
      <link href="/2023/07/05/first-in/"/>
      <url>/2023/07/05/first-in/</url>
      
        <content type="html"><![CDATA[<h3 id="test" tabindex="-1">Test</h3><ol><li>第一篇博客简单测试实现的功能，后续会继续优化网页的显示</li><li>得抓紧时间学习新知识，争取找点找到实习工作</li><li>一切都拼尽全力，一切都顺其自然，让自己快乐快乐这才叫做意义</li></ol><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/05/hello-world/"/>
      <url>/2023/07/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start" tabindex="-1">Quick Start</h2><h3 id="create-a-new-post" tabindex="-1">Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server" tabindex="-1">Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files" tabindex="-1">Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites" tabindex="-1">Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
