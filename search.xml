<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>华为0920/0923秋招笔试</title>
      <link href="/2023/09/23/hua-wei-0920-0923-qiu-zhao-bi-shi/"/>
      <url>/2023/09/23/hua-wei-0920-0923-qiu-zhao-bi-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="%E5%8D%8E%E4%B8%BA0920%2F0923%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95" tabindex="-1">华为0920/0923秋招笔试</h3><blockquote><p>开启这个系列，主要是对大厂的笔试的刷题模式进行熟悉，每次的摘录会选择自己理解并有所思考的题目，也算是一种总结思考。</p></blockquote><p>​</p><h3 id="0920.t1-%E4%B8%A2%E5%A4%B1%E6%8A%A5%E6%96%87%E7%9A%84%E4%BD%8D%E7%BD%AE" tabindex="-1">0920.T1 丢失报文的位置</h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h4><p>某通信系统持续向外发送报文，使用数组<code>nums</code>保存<code>n</code>个最近发送的报文，用于在报文未达到对端的情况下重发。报文使用序号<code>sn</code>表示，序号<code>sn</code>按照报文发送顺序从小到大排序，相邻报文<code>sn</code>不完全连续且有可能相同。报文使用循环覆盖的方式保存，即<code>nums</code>数组填满后，从头开始保存新的报文。假设需要重发序号为<code>sn</code>的报文。请找出序号为<code>sn</code>的报文在数组中的开始位置和结束位置。</p><p><strong>解答要求</strong></p><p>时间限制:C/C<ins>1000ms,其他语言: 2000ms内存限制: C/C</ins>256MB其他语言:512MB</p><p><strong>输入</strong></p><pre class="line-numbers language-none"><code class="language-none">第一行输入:数组nums的大小n，取值范围[0,10000]第二行输入:数组中的所有报文的序号sn，sn取值范围[0,100000]。第三行输入:需要重发的报文序号sn，取值范围[0,100000]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>输出</strong></p><pre class="line-numbers language-none"><code class="language-none">start end<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>说明:</strong></p><p><code>start</code>和<code>end</code>代表需要重发的报文序号<code>sn</code>在数组中的起始下标和结束下标</p><p><strong>样例1</strong></p><p><strong>输入:</strong></p><pre class="line-numbers language-none"><code class="language-none">70 0 1 2 2 5 61<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>输出:</strong></p><pre class="line-numbers language-none"><code class="language-none">2 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>解释</strong>：</p><pre class="line-numbers language-none"><code class="language-none">nums数组大小为7保存了7个报文，sn分别是0 0 1 2 2 5 6sn为1的报文在数组中仅有1个，下标是2，因此输出22<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​</p><h4 id="2.-%E5%88%86%E6%9E%90%E8%A7%A3%E7%AD%94" tabindex="-1">2. 分析解答</h4><ul><li><p>找到特定的元素的下标，返回其在数组中的特定位置，也就是最初出现的位置和最后出现的位置。不难想到是从最小值开始进行遍历，以数组的大小为窗口，不断进行取余的运算(确保最后的元素可以连续不断填充)。</p><p>​</p></li></ul><h4 id="3.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" tabindex="-1">3.完整代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class title1 {    public static void main(String[] arg){        int n,sn;        Scanner in=new Scanner(System.in);        n=in.nextInt();//数组nums的长度        int[] nums=new int[n];        for(int i=0;i&lt;n;i++){            nums[i]=in.nextInt();//输入数组的元素        }        sn=in.nextInt();//确定的元素的值        int minIndex=0,minValue=nums[0];//从最数组最初值开始遍历        for(int i=0;i&lt;n;i++){            if(nums[i]&lt;minValue){                minIndex=i;//最小值下标                minValue=nums[i];//最小值            }        }        int start=-1,end=-1;//记录开始和结束位置        for(int i=0;i&lt;n;i++){            int index=(minIndex+i)%n;//遍历当前的下标            if(nums[index]==sn) {//找到需要的元素值得下标                if (start == -1) {//首次                    start = index;                    end = index;                } else {//不是首次的话，只用返回更新end指针即可                    end = index;                }            }        }        System.out.println(start+ " " + end);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>现实笔试中是需要完整的代码演示的，所以需要更加谨慎认真，对每个限定条件都进行判定。</li></ul><p>​</p><h3 id="0920.t2-%E5%BF%AB%E9%80%9F%E4%BC%A0%E7%90%83" tabindex="-1">0920.T2 快速传球</h3><h4 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E-1" tabindex="-1">1. 题目说明</h4><p>班级组织传球活动，男女同学随机排成m行n列队伍，第一列中的任意一个男同学都可以作为传球的起点，要求最终将球传到最后一列的任意一个男同学手里，求所有能够完成任务的传球路线中的最优路线(传球次数最少的路线)的传球次数。</p><p><strong>传球规则:</strong></p><pre class="line-numbers language-none"><code class="language-none">1.男同学只能将球传给男同学，不能传给女同学。2.球只能传给身边前后左右相邻的同学。3.如果游戏不能完成，返回-1。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>说明</strong></p><pre class="line-numbers language-none"><code class="language-none">1.传球次数最少的路线为最优路线。2最优路线可能不唯一，不同最优路线都为最少传球次数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>解答要求</strong></p><p>时间限制:C/C<ins>100ms其他语言: 200ms内存限制: C/C</ins>256MB,其他语言: 512MB</p><p><strong>输入</strong></p><pre class="line-numbers language-none"><code class="language-none">班级同学随机排成的m行n列队伍，1代表男同学，0代表女同学。输入第一行包含两个用空格分开的整数m[1,30]和n [1,30]，表示m行n列的队伍;接下来是m行每行包含n个用空格分开的整数1或0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>输出</strong></p><p>最优路线的传球次数（最少传球次数）</p><p><strong>样例1</strong></p><p><strong>输入</strong></p><pre class="line-numbers language-none"><code class="language-none">4 41 1 1 01 1 1 00 0 1 00 1 1 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出</strong></p><pre class="line-numbers language-none"><code class="language-none">5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​</p><h4 id="2.-%E5%88%86%E6%9E%90%E8%A7%A3%E7%AD%94-1" tabindex="-1">2. 分析解答</h4><ul><li>涉及到最优路线和最短的路线，一般都会想到<code>BFS</code>或者<code>DFS</code>。这里就直接最短路BFS。</li><li>枚举第一列的所有的点，做一次BFS，判断走到最后一列的最短距离即可。关键在于100ms，其他语言一定要注意输入超时。</li></ul><p>​</p><h4 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3. 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//班级组织传球活动，男女同学随机排成m行n列队伍，// 第一列中的任意一个男同学都可以作为传球的起点，要求最终将球传到最后一列的任意一个男同学手里，// 求所有能够完成任务的传球路线中的最优路线(传球次数最少的路线)的传球次数。//班级同学随机排成的m行n列队伍，1代表男同学，0代表女同学。//输入第一行包含两个用空格分开的整数m[1,30]和n [1,30]，表示m行n列的队伍;//接下来是m行每行包含n个用空格分开的整数1或0。//输入：4 4//1 1 1 0//1 1 1 0//0 0 1 0//0 1 1 1//输出：5import java.io.*;import java.util.Deque;import java.util.LinkedList;import java.util.StringTokenizer;public class title2 {     //定义快速读入的类，这里需要学习记录一下：    private static  class FastScanner {        BufferedReader br; //用于按行读取输入数据        StringTokenizer st; //用于将一行数据分割为多个token。               public FastScanner(InputStream stream){            br =  new BufferedReader(new InputStreamReader(stream), 32768); //通过InputStreamReader将输入流转换为字符流，并指定缓冲区大小为32768。            st = null; //初始化为null        }        String next() { //用于获取下一个token（字符串）            while (st == null ||  !st.hasMoreTokens())// 当st为null或者当前行的token已经全部使用完毕时，进入循环                try {                    st=new StringTokenizer(br.readLine());//尝试读取下一行数据并将其分割为多个token                } catch (IOException e) {//异常处理                    e.printStackTrace();                }            return st.nextToken(); //循环结束，返回当前行的下一个token        }        int nextInt() {// nextInt()方法，用于获取下一个整数            return Integer.parseInt(next()); //调用next()方法获取下一个token（字符串），将调用到的token解析为整数并返回        }    }    public static void main(String[] args) {        new title2().solve();// 创建实例（solve()类看下文）    }    int m,n;// 队伍的行和列    int[][] grid; // 储存队伍中同学的性别信息    void solve() {        PrintWriter pwin = new PrintWriter(new OutputStreamWriter(System.out));        FastScanner fsc = new FastScanner(System.in);// 调用类        m = fsc.nextInt();;        n = fsc.nextInt();        grid = new int[m][n];        for (int i = 0; i &lt; m; i++) {            for (int j = 0; j &lt; n; j++) {                grid[i][j] = fsc.nextInt();            }        }        int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};// 定义dirs数组，表示四个方向的移动：右、下、左、上        int res = 10000001; // 初始化变量res为一个较大的数，用于保存最少传球次数        for (int i = 0; i &lt; m; i++) {// 利用广度优先搜索找到传球到最后一列男同学的最短路径。            if (grid[i][0] == 1) { // 判断是否为男同学，grid[i][0]表示第i行、第0列的位置，其中1表示男同学，0表示女同学。                Deque&lt;int[]&gt; dq = new LinkedList&lt;&gt;();// 定义队列，用于广度优先                dq.add(new int[]{0,i,0}); // 表示起点的传球次数、行号和列号                boolean[][] used = new boolean[m][n]; // 用于标记已经遍历过的位置                used[i][0] = true;                while (!dq.isEmpty()) {                    int[] a = dq.poll();// 从dq中取出队首元素a，其中d表示传球次数，x表示行号，y表示列号。                    int d = a[0], x = a[1], y = a[2];                    if (y == n-1) {                        res = Math.min(res, d);//如果当前列号等于n-1（最后一列），则更新最小传球次数res为传球次数d的较小值。                    }                    for (int[] dir : dirs) {                        //遍历四个方向的移动，计算新的行号nx和列号ny。//判断下一个位置是否合法，如果不合法则跳过继续下一次循环。//如果下一个位置合法且未被使用且为男同学，则将该位置标记为已使用，并加入dq，传球次数加1。                        int nx = x + dir[0],  ny = y + dir[1];                        if (nx &lt; 0 || ny &lt; 0 || nx &gt;= m || ny &gt;= n || used[nx][ny] || grid[nx][ny] != 1) continue;                        used[nx][ny] = true;                        dq.add(new int[]{d+1, nx,ny});// 循环结束，得到从当前起点到最后一列男同学的最短传球次数                    }                }            }        }        //如果找到了最短路径，则输出最小传球次数；如果无法找到最短路径，则输出-1。最后，通过刷新打印流pwin，确保结果被立即输出。        if (res != 10000001) pwin.println(res);//如果不等于10000001，表示找到了从起点到最后一列男同学的最短路径。等于的话就是没有找到        else pwin.println(-1);        pwin.flush();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>复杂度分析</strong><ul><li><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong>   对于每个男同学，最坏情况下需要遍历整个队伍，所以时间复杂度为O(m * n)，其中m为行数，n为列数。</li><li><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></strong>  需要使用额外的空间保存队列和标记已访问的位置，所以空间复杂度为O(m * n)。</li></ul></li></ul><blockquote><p>第三题太复杂了，还没弄懂，9.23号的后续接着更新…</p></blockquote><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023大厂秋招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西门子远程办公 Day1</title>
      <link href="/2023/09/20/xi-men-zi-yuan-cheng-ban-gong-day1/"/>
      <url>/2023/09/20/xi-men-zi-yuan-cheng-ban-gong-day1/</url>
      
        <content type="html"><![CDATA[<h3 id="%E8%A5%BF%E9%97%A8%E5%AD%90%E8%BF%9C%E7%A8%8B%E5%AE%9E%E4%B9%A0day1" tabindex="-1">西门子远程实习Day1</h3><ul><li><p><strong>时间安排？</strong></p><blockquote><p>今天有个早八的软件工程基础，老师还是一如既往地PPT讲解。8:30开始等Leader的邮件，结果差不多10:30才等到。从10:30一直工作到下午6:00，中间花了20分钟吃午饭。</p></blockquote></li><li><p><strong>任务分配？</strong></p><blockquote><p>今天主要是认识熟悉测试开发的平台<code>AEM Editor</code>,Leader下发的任务是完成19个文档网页的上传和测试。平台好多功能组件都不是很熟，也的确花费了大量时间进行复盘和尝试。最后只完整发布了<code>4</code>份测试报告，不过Leader说不着急，明天可以继续做。</p></blockquote></li><li><p><strong>后续安排？</strong></p><blockquote><ul><li>特意问了Leader明天是否需要到公司实地办公，她的回答是先不用。由于入职手续还没办理完成(我的招商银行工资卡还在申请制作当中),实习ID卡也没有办理好，所以目前还是远程办公。</li><li>远程实习是节约了大量的通勤时间，但是感觉询问和交流的效率稍低。希望在中秋、国庆假期之前可以实际去趟公司吧。</li></ul></blockquote></li><li><p><strong>收获感想</strong></p><blockquote><ol><li>工作遇到不会的不要着急，要多问多想多记录，比如今天的数据库上传的时候出现问题。通过询问之后才得知需要<code>Assets</code>保存<code>Properties</code>才可以成功上链。不同的公司要求不一样，实习作为一种特殊的工作经历，试错成本相对比较低了，对新人比较友好。</li><li>实习的时间相对比较轻松，远程实习就更是了。所以要好好利用空余时间抓紧学习知识。最近几天比较忙，<code>Leetcode</code>刷得较少。争取今年把里面的所有算法知识点学完，多练习、多理解、多举一反三。为明年的暑期实习和秋招做准备吧，加油！</li></ol></blockquote><p>​</p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/09/20/xi-men-zi-yuan-cheng-ban-gong-day1/%E6%A8%A1%E7%BB%84%E5%88%B6%E4%BD%9C.jpg" alt="模组制作" style="zoom:50%;"><blockquote><p>放一张今天解决的页面排版模板，认识组件太重要了😭~</p></blockquote><blockquote><p>对了，插播一句题外话，从本周末开始会开始更新2023.大厂秋招算法题目，也是自己思考过的题目类型，希望不会拖更哈哈，别到时候忙忘了😂~</p></blockquote></li></ul><center><span style="color:green;font-size:20px;">不断前进！😊</span></center><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双周赛113: 前3题</title>
      <link href="/2023/09/17/shuang-zhou-sai-113-qian-3-ti/"/>
      <url>/2023/09/17/shuang-zhou-sai-113-qian-3-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="%E5%8F%8C%E5%91%A8%E8%B5%9B113%EF%BC%9A%E5%89%8D3%E9%A2%98" tabindex="-1">双周赛113：前3题</h3><blockquote><p>本次双周赛的前3题难度适中，比较适合自己的学习。由于接了实习，最近也同样在学习有关的开发知识，力扣刷得不多。现在开始刷题学习之旅吧~</p></blockquote><p>​</p><h3 id="t1.-%E4%BD%BF%E6%95%B0%E7%BB%84%E6%88%90%E4%B8%BA%E9%80%92%E5%A2%9E%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%91%E5%8F%B3%E7%A7%BB%E6%AC%A1%E6%95%B0" tabindex="-1">T1. <a href="https://leetcode.cn/problems/minimum-right-shifts-to-sort-the-array/">使数组成为递增数组的最少右移次数</a></h3><h4 id="1.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1.1 题目说明</h4><p>给你一个长度为 <code>n</code> 下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组中的元素为 <strong>互不相同</strong> 的正整数。请你返回让 <code>nums</code> 成为递增数组的 <strong>最少右移</strong> 次数，如果无法得到递增数组，返回 <code>-1</code> 。</p><p>一次 <strong>右移</strong> 指的是同时对所有下标进行操作，将下标为 <code>i</code> 的元素移动到下标 <code>(i + 1) % n</code> 处。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [3,4,5,1,2]输出：2解释：第一次右移后，nums = [2,3,4,5,1] 。第二次右移后，nums = [1,2,3,4,5] 。现在 nums 是递增数组了，所以答案为 2 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [2,1,4]输出：-1解释：无法将数组变为递增数组。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= nums.length &lt;= 100</code></p></li><li><p><code>1 &lt;= nums[i] &lt;= 100</code></p></li><li><p><code>nums</code> 中的整数互不相同。</p><p>​</p></li></ul><hr><h4 id="1.2-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">1.2 解答分析</h4><ul><li><p>读题之后可以简单地分析需求：</p><ol><li>递增数组</li><li>最少右移次数</li><li><code>x</code>次右移是将下标<code>i</code>的元素移动到下标<code>(i+x)%n</code>处即可</li></ol></li><li><p>如何满足上述的三个需求？</p><ol><li><p>先将数组元素从小到大排序，得到最后的递增数组<code>a[]</code></p></li><li><p>最少移动次数用数组<code>遍历即可，x++;满足条件返回当前的x值即可</code>。在移动一次后的当前答案后判断此时的数组元素是否和数组<code>a[]</code>每一位的元素相同即可。</p></li><li><p>判断此时移动后的数组元素和下标为<code>(i+x)%n</code>处的元素是否相同即可</p></li></ol><p>​</p></li></ul><hr><h4 id="1.3-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">1.3 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution{    public int minimumRightShift(List&lt;Integer&gt;nums){        //注意题干给出恶的是List列表，此时获取nums中的元素用到get方法，长度用size()函数方法        int n=nums.size();        //a[]是当前排序好的结果元素，作为标准        int[] a=new int[n];        for(int i=0;i&lt;n;i++){            a[i]=nums.get(i);        }        Arrays.sort(a);        //枚举需要右移的次数，同时开始每一位的判定        for(int x=0;x&lt;n;x++){//x若移动n次和0次的效果相同            boolean flag=true;//用于判断每一次移动后的数组元素和标准数组的每一位是否相同，作为判断哨兵            for(int i=0;i&lt;n;i++){                if(nums.get(i)!=a[(i+x)%n]){                    f=false;                    break;                }            }            if(f){                return x;//返回当前右移统计的次数            }        }        return -1;//特例，没有则返回-1    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq></p><blockquote><p>Arrays.sort(a)的时间复杂度为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>,接下来两层循环的复杂度为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>。综上所述，时间复杂度为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq></p></blockquote></li><li><p><strong>空间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><p>在代码中，创建了一个长度为n的整型数组a来存储排好序的nums列表。由于nums列表和a数组的大小相同，因此需要额外的O(n)的空间。</p></blockquote></li></ul></li></ul><hr><h3 id="t2.-%E5%88%A0%E9%99%A4%E6%95%B0%E5%AF%B9%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6" tabindex="-1">T2. <a href="https://leetcode.cn/problems/minimum-array-length-after-pair-removals/">删除数对后的最小数组长度</a></h3><h4 id="2.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">2.1 题目说明</h4><p>给你一个下标从 <strong>0</strong> 开始的 <strong>非递减</strong> 整数数组 <code>nums</code> 。</p><p>你可以执行以下操作任意次：</p><ul><li>选择 <strong>两个</strong> 下标 <code>i</code> 和 <code>j</code> ，满足 <code>i &lt; j</code> 且 <code>nums[i] &lt; nums[j]</code> 。</li><li>将 <code>nums</code> 中下标在 <code>i</code> 和 <code>j</code> 处的元素删除。剩余元素按照原来的顺序组成新的数组，下标也重新从 <strong>0</strong> 开始编号。</li></ul><p>请你返回一个整数，表示执行以上操作任意次后（可以执行 <strong>0</strong> 次），<code>nums</code> 数组的 <strong>最小</strong> 数组长度。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,3,4,9]输出：0解释：一开始，nums = [1, 3, 4, 9] 。第一次操作，我们选择下标 0 和 1 ，满足 nums[0] &lt; nums[1] &lt;=&gt; 1 &lt; 3 。删除下标 0 和 1 处的元素，nums 变成 [4, 9] 。下一次操作，我们选择下标 0 和 1 ，满足 nums[0] &lt; nums[1] &lt;=&gt; 4 &lt; 9 。删除下标 0 和 1 处的元素，nums 变成空数组 [] 。所以，可以得到的最小数组长度为 0 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="2.2-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2.2 解答分析</h4><ul><li><p>注意审题，<strong>非递减数组说明可以存在相同的元素，比如数组[1,2,2,2,2,3,4,5,6]就满足条件</strong></p></li><li><p>简化题干就是每次都需要删除一组的<code>2</code>个数，满足下标和数值不同，满足递增即可。其实就是寻找出现次数最多的数字，并记录它出现的次数。如果它出现的次数大于总数的一半，那么它一定无法被完全消去；否则判断数组长度的奇偶性，因为偶数可以一一匹配，消除掉，奇数则会存在一个剩余。</p></li></ul><hr><h4 id="2.3-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">2.3 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution{    public int minLengthAfterRemovals(List&lt;Integer&gt; nums){        //统计数组中相同元素出现的次数，找出出现次数最多的元素；首先判断是否可以被消除(也就是次数小于等于总数的一半)。如果行，则直接判断奇偶性即可；如果不行，计算最后剩余的次数        HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();        int max=0;        for(int n:nums){            int curcount=mao.getOrDefault(n,0)+1;            max=Math.max(max,curcount);            map.put(n,curcount);//每次遇到新的键、值都更新        }        int len=nums.size();        if(2*max&lt;=len){            return len%2;//判断数组长度的奇偶性        }else{            return max-(len-max);////计算的是出现次数最多的数比其他数多的次数,也是最后多出来的次数}    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><p>代码首先使用HashMap来统计每个数字出现的次数。在遍历nums列表时，对于每个数字n，将其出现次数记录在map中，并更新当前最大次数max。这个过程的时间复杂度是O(n)，因为需要遍历整个nums列表。根据出现次数max和数组长度len进行判断，得出最小长度的结果。这部分操作只涉及简单的数学运算和条件判断，时间复杂度为O(1)。</p></blockquote></li><li><p><strong>空间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)/O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><p>对于空间复杂度，代码中使用了一个HashMap来存储数字和出现次数的映射关系，所占用的空间取决于nums列表中不同数字的个数，即O(k)，其中k是不同数字的数量。最坏的情况是O(n)，但是一般k会远小于n，随着n的不断增大。</p></blockquote></li></ul></li></ul><p>​</p><hr><h3 id="t3.-%E7%BB%9F%E8%AE%A1%E8%B7%9D%E7%A6%BB%E4%B8%BA-k-%E7%9A%84%E7%82%B9%E5%AF%B9" tabindex="-1">T3. <a href="https://leetcode.cn/problems/count-pairs-of-points-with-distance-k/">统计距离为 k 的点对</a></h3><h4 id="3.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">3.1 题目说明</h4><p>给你一个 <strong>二维</strong> 整数数组 <code>coordinates</code> 和一个整数 <code>k</code> ，其中 <code>coordinates[i] = [xi, yi]</code> 是第 <code>i</code> 个点在二维平面里的坐标。</p><p>我们定义两个点 <code>(x1, y1)</code> 和 <code>(x2, y2)</code> 的 <strong>距离</strong> 为 <code>(x1 XOR x2) + (y1 XOR y2)</code> ，<code>XOR</code> 指的是按位异或运算。</p><p>请你返回满足 <code>i &lt; j</code> 且点 <code>i</code> 和点 <code>j</code>之间距离为 <code>k</code> 的点对数目。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：coordinates = [[1,2],[4,2],[1,3],[5,2]], k = 5输出：2解释：以下点对距离为 k ：- (0, 1)：(1 XOR 4) + (2 XOR 2) = 5 。- (2, 3)：(1 XOR 5) + (3 XOR 2) = 5 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：coordinates = [[1,3],[1,3],[1,3],[1,3],[1,3]], k = 0输出：10解释：任何两个点之间的距离都为 0 ，所以总共有 10 组点对。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= coordinates.length &lt;= 50000</code></li><li><code>0 &lt;= xi, yi &lt;= 10^6</code></li><li><code>0 &lt;= k &lt;= 100</code></li></ul><p>​</p><hr><h4 id="3.2-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">3.2 解答分析</h4><ul><li><p>看到这个求和为k，想到的是<code>两数之和</code>，也就是要利用到HashMap进行遍历匹配。同时注意到提示条件中有<code>0&lt;=k&lt;=100</code>,说明此时可以枚举全部的<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>x</mi><mn>1</mn></msub><mi>X</mi><mi>O</mi><mi>R</mi><msub><mi>x</mi><mn>2</mn></msub><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">0\le x_1XORx_2\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.00773em;">XOR</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span></eq>情况即可。</p></li><li><p>如何将对应的二维数组唯一确定呢？需要利用<code>HashMap</code>进行存储计算，记录每个坐标出现的次数。使用乘法因子<code>mul</code>对<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>t</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_t,y_t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>转坏为唯一的<code>find</code>值，过查询<code>count</code>HashMap来获取<code>find</code>对应的值，并将其累加到<code>res</code>上。</p></li><li><p>将当前坐标（x, y）转换为唯一的<code>key</code>值，同样使用乘法因子<code>mul</code>，然后将<code>key</code>更新到<code>count</code>HashMap中，如果<code>key</code>已经存在，则将其对应值加1；如果<code>key</code>不存在，则初始化为1</p></li><li><p>本题是如何唯一确认二维坐标<code>(xi</code>, <code>yi)</code>的呢？这里设置比较大的乘法因子<code>mul</code>，设置成最大的值10^6,保证不会出现哈希碰撞导致键值对不唯一，确保生成的唯一数值范围足够广，以避免哈希冲突。。</p><blockquote><p>当有两个不同的二维坐标（<code>xi1</code>, <code>yi1</code>）和（<code>xi2</code>, <code>yi2</code>）满足<code>xi1 + yi1 = xi2 + yi2</code>时就会发生哈希冲突。</p></blockquote></li><li><p><strong>根据异或的性质，有 x ^ (i ^ x) = i, y ^ ((k - i) &amp; y) = k - i，因此与 坐标 (x, y) 可以匹配的坐标是 (i ^ x, (k - i) ^ y)，其中 i 的取值范围是 0 ~ k。</strong></p></li></ul><p>​</p><hr><h4 id="3.3-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3.3 具体代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution{    private static final long mul=1000000;    public int countPairs(List&lt;List&lt;Integer&gt;&gt; coordinates,int k){        HashMap&lt;Long,Integer&gt;count =new HashMap&lt;&gt;();        int res=0;        for(List&lt;Integer&gt;coor:coordinates){            int x=coor.get(0),y=coor.get(1);//获取当前点对的x和y的值                        for(int i=0;i&lt;=k;i++){                int xt=i^x,yt=(k-i)^y;//异或操作                long find=xt*mul+yt;//乘法计算转化为唯一的find值                res+=count.getOrDefault(find,0);//统计出现和为k的数对的次数            }                        long key=x*mul+y;            count.put(key,count.getOrDefault(key,0)+1);//将当前坐标出现的次数更新到HashMapcount中。如果key已存在，则将其对应的值加1；若不存在，则初始化为1。        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><ul><li><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>∗</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><ul><li>首先，遍历二维坐标列表需要花费O(N)的时间，其中N是坐标的数量。</li><li>内部嵌套循环的时间复杂度是O(k)，因为它迭代了从0到k的i的所有可能取值。</li><li>在内层循环中，通过HashMap的getOrDefault方法进行查询和更新操作，其时间复杂度是O(1)。</li><li>因此，总体时间复杂度为O(N * k)。</li></ul></blockquote></li><li><p><strong>空间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><p>创建一个HashMap<code>count</code>用于记录每个坐标出现的次数，需要的空间是O(n)，其余地方并没有使用到额外的数据结构。</p></blockquote></li></ul></li></ul><p>​</p><center><span style="color:red;font-size:30px;font-weight:bolder;">END~</span><p style="color:lightblue;font-size:20px;">继续努力！</p></center><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 138.复制带随机指针的链表</title>
      <link href="/2023/09/14/leetcode-138-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/"/>
      <url>/2023/09/14/leetcode-138-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-138.-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8" tabindex="-1"><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">Leetcode 138. 复制带随机指针的链表</a></h3><blockquote><p>最近的编译原理课程的lab1进行了链表的基本操作，这下回来想着如果链表的指针并不唯一指定的话，需要怎么进行复制，或者说是链接。刚好在力扣找到了这道题，所以拿来试试手…</p></blockquote><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a></strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p><p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p><p>返回复制链表的头节点。</p><p>用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p><ul><li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li><li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code> 。</li></ul><p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​</p><hr><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><ul><li><p>本题的基本操作是将链表进行复制，但是对于每个链表的节点而言都存在随机的指针<code>random</code>，其实在不考虑<code>random</code>指针的情况下，只需要将原先的链表进行拷贝，这里引入两个指针，一个用于遍历原链表，一个用于构造新链表（始终指向新链表的尾部）。</p><blockquote><p>这个过程实际上就是创建节点+构建<code>next</code>的指针关系</p></blockquote></li><li><p>所以现在就是在原先的基础上添加特定的<code>random</code>指针，我们可以将<code>next</code>指针和<code>random</code>指针进行关系的构建，从输入的格式中可以强烈看出应该是要用到<code>哈希表</code>的数据结构，<code>key</code>为原节点，对应的<code>value</code>是新节点。</p><ul><li>先不考虑<code>random</code>指针的关系，和原本链表复制一样，创建新节点，并构造出<code>next</code>的指针关系，<strong>同时使用的是哈希表记录原节点和新节点的映射关系</strong></li><li>对原链表和新链表进行同时遍历，对于原链表的每个节点上的<code>random</code>都利用<strong>哈希表</strong>的找到新<code>random</code>节点，并在新链表上构造<code>random</code>关系。<strong>也就是总共两条链表，其中的每个节点都是利用HashMap构造的对应映射关系</strong></li></ul></li></ul><hr><h3 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3. 具体代码</h3><ul><li><p><code>Java</code>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution{    public Node copyRandomList(Node head){        Node t=head;        Node dummy=new Node(-10010),cur=dummy;//dummy是空节点，cur是对应的指针        Map&lt;Node,Node&gt;map=new HashMap&lt;&gt;();        //第一次遍历原链表：遍历每个原节点 head，创建一个新节点 node 并保存到哈希表中，同时将新节点连接到复制链表中。(存HashMap)        while(head!=null){            Node node=new Node(head.val);            map.put(head,node);            cur.next=node;            cur=cur.next;            head=head.next;        }                cur=dummy.next;//重置指针        head=t;//为第二次遍历做准备        //第二次遍历原链表：遍历每个原节点 head，从哈希表中获取对应的复制节点，并将其赋值给复制链表当前节点的 random 指针。（进行链表复制）        while(head!=null){            cur.random=map.get(head.random);            cur=cur.next;            head=head.next;        }        return dummy.next;//返回复制指针的头节点    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>复杂度分析</strong></p><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq></strong></p><blockquote><p>两次遍历原链表：需要遍历整个链表，时间复杂度为 O(N)，其中 N 是原链表的长度。 综上所述，总的时间复杂度为 O(N)。</p></blockquote></li><li><p><strong>空间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><p>创建了一个哈希表 <code>map</code>，存储了原节点和对应的复制节点，因此需要额外的空间来存储哈希表中的键值对。哈希表的空间复杂度为 O(N)。同时为了复制链表，创建了哨兵节点<code>dummy</code>和指针<code>cur</code>,但是他们的数量和键值对数量一样为N，综上所述：空间复杂度为O(N)。</p></blockquote></li></ul></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西门子实习面试经验帖</title>
      <link href="/2023/09/13/xi-men-zi-shi-xi-mian-shi-jing-yan-tie/"/>
      <url>/2023/09/13/xi-men-zi-shi-xi-mian-shi-jing-yan-tie/</url>
      
        <content type="html"><![CDATA[<h3 id="%E8%A5%BF%E9%97%A8%E5%AD%90%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E5%B8%96" tabindex="-1">西门子实习面试经验帖</h3><h3 id="1.-%E9%80%89%E6%8B%A9%E5%8E%9F%E5%9B%A0" tabindex="-1">1. 选择原因</h3><blockquote><p>始终认为：学会认知自我，并作出改变是大学的必修课；面向就业，并为社会国家做出一定贡献是大学生的必拿学分。</p></blockquote><ul><li><p>大三上学期排课不是很多，工作日几乎可凑出三天的时间</p></li><li><p>西门子作为<code>TOP500</code>企业，想从实习岗位中大致进行职位的体验，不断职业规划，有所进步</p></li><li><p>对岗位感兴趣，尤其是网站开发的职位，一直都想有机会得到技术提升</p><p>​</p></li></ul><hr><h3 id="2.-%E6%8A%95%E6%94%BE%E8%BF%87%E7%A8%8B" tabindex="-1">2. 投放过程</h3><ul><li><p>首先是在<code>北邮人论坛</code>上找到了内推实习，实习的工作是进行网站维护和开发，需要用到的语言有<code>HTML/CSS/Javascipt</code>，以及部分的后端J<code>Java</code>代码对接处理。</p></li><li><p>直接做好简历进行投递，办理入职的过程如下：（</p><blockquote><p>听说外企的办理还是挺麻烦了，这里就一直记录下来，直到结束办理）</p></blockquote><ul><li><p>9.8晚上简历投递；</p></li><li><p>9.11号上午通知简历通过，准备面试和技术面；</p></li><li><p>9.12下午进行面试，和hr与技术组组长沟通洽谈</p></li><li><p>9.13 上午面试通过，收到交接通知，进行线上培训</p></li><li><p>9.14 加上Leader微信，沟通时间安排</p></li><li><p>9.18 开始进行办公，第一天任务是SMART网站资料更新，比较友好，但是还是花了一上午。下午收到"Welcome to Siemens"的offer邮件。</p></li><li><p>9.19 - 9.20 提交实习生资料（9.23号才办理好银行卡，收到网上合同和准测预览）</p></li><li><p>9.20-至今(9.24)  开始大任务，进行案例文章的发布和新闻修改上传，任务多多…</p></li></ul><p>​</p></li></ul><hr><h3 id="3.-%E9%9D%A2%E8%AF%95%E8%BF%87%E7%A8%8B(%E7%BA%BF%E4%B8%8A)" tabindex="-1">3. 面试过程(线上)</h3><blockquote><p>本次面试的体验感觉很棒，面试官很有亲和力，在具体技术面试的时候<code>Leader</code>也会有所提示，对于存在的问题客观评价，这点对于像我这样成长期中的实习生来说是一次很宝贵、难得的学习机会。</p></blockquote><h4 id="%E9%83%A8%E5%88%86%E6%B5%81%E7%A8%8B%E5%A6%82%E4%B8%8B%EF%BC%9A" tabindex="-1">部分流程如下：</h4><ul><li>打招呼，问候</li></ul><p><strong>Q1</strong>：进行简单的自我介绍？</p><blockquote><p>介绍自己的学历、项目经历、以及选择该岗位的对应技能要求</p></blockquote><p><strong>Q2</strong>：为什么选择西门子公司？</p><blockquote><p>这里我分为了两个部分，一个是对实习企业平台的考虑，主要介绍西门子公司的经营业务(体现出对公司的了解)，以及对拓展个人视野的阐述；另外一个是对自身技能提升的考虑，说明自身对相关实习经历的需求，我结合了参与的竞赛、项目，希望可以把握好本次机会得到锻炼。</p></blockquote><p><strong>Q3</strong>： 简单介绍一次影响深刻的小组合作项目？</p><blockquote><p>我的介绍分为以下三步：</p><ol><li>项目目的与需求</li><li>项目分工与配合（这里说了很多）</li><li>项目收获</li></ol></blockquote><ul><li>接下来是技术面，技术组<code>Leader</code>打开word文档，里面包含前后端的代码分析，具体的大概有网页<code>HTML/CS/JavaScript</code>的组件分析，<code>数据库</code>后端的适配和应用，以及基于<code>Java</code>的功能分析实践。很多都是常见的八股文分析，同时包含性能优化与提升，这些我都一一回答，唯一遗憾的是有个<code>Java</code>问题回答得仓促，再加上周围环境有些嘈杂，回答了三次才让面试官点头满意，回答问题不要急，要全面分析后得出自己得理解，娓娓道来。</li></ul><p><strong>Q4：</strong> 具体实习的时间和薪资预期？</p><blockquote><p>当问到这个问题的时候，我知道大概率是通过了，但是也不敢打包票保证。</p><ol><li>实习时间：由于我需要上课，先开始说的是周三、周四两天可以去实习；后续hr说希望可以工作2.5天，需要至少1天到公司。我个人的安排是周四到司，剩余一天半远程实习。</li><li>薪资：hr提问得十分谨慎，估计是有很多本科生由于薪资拒绝了吧。对我而言，权衡薪资和经历，我更偏向于后者，真诚回答即可。</li></ol></blockquote><ul><li><p>接着是被面试者的提问环节，就不细说了。</p></li><li><p>最后致谢，礼貌告别</p><p>​</p></li></ul><hr><h3 id="4.-%E6%84%9F%E6%82%9F" tabindex="-1">4. 感悟</h3><ol><li><p>终究需要走出这一步，走出去了后面会越来越好的！尤其是面试的时候，一直不断做积极的心理暗示为紧张的自己鼓励加油😂</p></li><li><p>入职后要多看多学多用，不浪费机会，将自己所学实际应用出来😁</p></li><li><p>北邮人论坛太棒了！感谢学校平台和学长学姐们的职位推荐，我也会努力学习，做出成绩，为后来的学弟学妹们树立榜样👍</p></li></ol><p>​</p><center><span style="font-size:25px;color:lightblue;">Successful interview experience😄</span></center><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 企业面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML/CSS知识准备</title>
      <link href="/2023/09/11/html-css-zhi-shi-zhun-bei/"/>
      <url>/2023/09/11/html-css-zhi-shi-zhun-bei/</url>
      
        <content type="html"><![CDATA[<h3 id="html%2Fcss%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87" tabindex="-1">HTML/CSS知识储备</h3><blockquote><p>bg：前几天在论坛里找到了<code>西门子</code>的内推，本想试一试就把简历制作发过去了。没想到回复邮件通知面试，面试的岗位是：内网/外网技术支持实习生,主要负责网页的运行维护、新闻推送页面制作等。我觉得挺好的，虽然平时也会主动去学习相关的web开发的工作，但是真正面试还是第一次，要好好准备，希望这次可以有学习体验的机会。明天下午进行面试，主要考察网页相关的知识，现在把HTML/CSS知识重新梳理复习一遍，明天加油！！！</p></blockquote><h2 id="html" tabindex="-1">HTML</h2><ul><li><p>HTML的定义：<strong>是一种超文本标记语言</strong>，不是编程语言，<strong>利用标记标签来描述网页。</strong></p></li><li><p>HTML的标签：利用尖括号包围、成对出现、有开始有结束的标签、开放标签和闭合标签</p></li><li><p><strong>HTML的元素</strong>：</p><ul><li>标题是通过<code>&lt;h1&gt;--&gt;&lt;h6&gt;</code>的标签进行定义，按重要级从小到大</li><li>段落是通过<code>&lt;p&gt;</code>的标签进行定义，分行</li><li>链接是通过<code>&lt;a&gt;</code>标签进行定义的，主要还有<code>href</code>的属性值，后面接的是链接的对应的网页地址</li><li>图像是利用<code>&lt;img&gt;</code>标签进行定义，注意<code>src</code>属性值表示对应图片的存储位置</li><li>空的html元素：虽然没有实际的内容，但是还是需要返回和关闭标签，注意<code>&lt;br /&gt;</code>的用法，在开始标签中添加斜杠</li><li>html中的标签对大小写不敏感，但是大多数网站都可以实现大写的<code>HTML</code>标签.</li></ul></li></ul><p>​</p><ul><li><p><strong>HTML的属性</strong></p><ul><li>这里的属性太多了，挑选一些常见的属性实例<ul><li><code>align="center"</code> 直接写在开始标签中，用于将文本对齐居中</li><li><code>body</code>主体中的属性，比如改变颜色，可以设置为<code>background-color:yellow;</code>同样也可以设置为<code>&lt;body bgcolor="yellow"&gt;</code>来表示</li><li><code>&lt;table&gt;</code>定义为HTML的表格样式</li><li>同样的在HTML中，对属性和属性值大小写并不敏感</li><li><strong>属性值（也就是具体的选值）需要被包含在双引号之中</strong></li></ul></li></ul></li></ul><p>​</p><ul><li><strong>HTML的标题</strong></li><li>需要根据具体的样式选取标签，也就是前文所说的<code>&lt;h1&gt;...&lt;h6&gt;</code>等，其中都是根据标题文字的重要性进行的排列，依次降低<ul><li>默认情况下，浏览器会自动地在标题的前后添加空行</li><li><code>HTML</code>的水平线，例如<code>&lt;hr /&gt;</code>,直接在当前界面中添加水平分割线</li></ul></li></ul><p>​</p><ul><li><p><strong>HTML段落</strong></p><ul><li>浏览器会自动地在段落前后添加空行（<code>&lt;p&gt;是块级元素</code>）</li></ul></li></ul><p>​</p><ul><li><p><strong>HTML样式（这个是重点！）</strong></p><ol><li><p><strong>直接style用法</strong></p><blockquote><p>比如说是:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">background-color</span><span class="token punctuation">:</span>green<span class="token punctuation">;</span><span class="token property">font-size</span><span class="token punctuation">:</span>20px<span class="token punctuation">;</span><span class="token property">text-align</span><span class="token punctuation">:</span>center</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>This is an apple!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote></li><li><p><strong>附加文件CSS</strong></p></li></ol><ul><li><p><code>&lt;em&gt;和&lt;i&gt;的区别：</code></p><ul><li><p><code>&lt;em&gt;</code>表示的是浏览器中的文本为强调的内容，但是最后</p></li><li><p><code>&lt;i&gt;</code>本身就是斜体字符的样式</p></li><li><p><code>&lt;strong&gt;</code>，这个标签也同样是强调文本的意思，但是它强调的程度更强一些，直接加粗字体的用法</p></li></ul></li></ul></li></ul><p>​</p><ul><li><p><strong>HTML引用</strong></p><ul><li><p><code>&lt;q&gt;</code>，元素是简短的引用，浏览器通常会直接对<code>&lt;q&gt;</code>元素包围引号</p></li><li><p><code>&lt;blockquote&gt;</code> ,通常是对元素定义被引用的节</p></li><li><p><code>cite</code>,表示引用的数据的地址与来源</p></li><li><p><code>abbr</code>,元素定义缩写或首字母缩略语</p><p>对缩写进行标记能够成为为浏览器、翻译系统以及搜索引擎提供有用的信息。比如</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>abbr</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>World Health Organization<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>WHO<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>abbr</span><span class="token punctuation">&gt;</span></span> 成立于 1948 年。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>输出就是：WHO....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>dfn</code>，元素定义项目或缩写</p></li><li><p><code>address</code>元素定义文档或者文章的联系信息（作者/拥有者）,此元素通常以斜体进行表示</p></li><li><p><code>cite</code>，该元素是著作的标题，通常会以斜体显示<code>&lt;cite&gt;</code>的元素</p></li></ul></li></ul><p>​</p><ul><li><p><strong>HTML CSS</strong></p><blockquote><p>上述的html的样式引入比较浅显，这里具体分类分析一下：</p></blockquote><ol><li><p><strong>外部样式表</strong></p><blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mystyle.css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--上述代码中的rel表示当前引入的是外部样式表，type样式表示当前被链接文件的类型，href指定文件的存储路径和位置--&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote></li><li><p><strong>内部样式表</strong></p><blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css"><span class="token selector">body</span> <span class="token punctuation">{</span><span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">}</span><span class="token selector">p</span> <span class="token punctuation">{</span><span class="token property">margin-left</span><span class="token punctuation">:</span> 20px<span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--注意是直接在head内部定义css样式--&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote></li><li><p><strong>内联样式</strong></p><blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span> <span class="token property">margin-left</span><span class="token punctuation">:</span> 20px</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>This is a paragraph<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--注意是在标签头内部直接进行样式style的书写--&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote></li></ol><ul><li><code>&lt;span&gt;</code>表示的是定义文档中的行内较小的一块或者是区域。</li><li><code>&lt;div&gt;</code>定义文档中的节或者是区域（块级）</li></ul></li></ul><p>​</p><ul><li><p><strong>HTML超链接</strong></p><ol><li><p>通过使用 href 属性 - 创建指向另一个文档的链接，<strong>也就是规定链接的目标</strong></p></li><li><p>通过使用 name 属性 - 创建文档内的书签，也就是给</p></li><li><p>其中的<code>target</code>属性：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3school.com.cn/<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Visit W3School!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--上述的代码表示会将新创建的超链接窗口定义为一个新的网页窗口--&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p>​</p></li><li><p><strong>HTML图像</strong></p></li><li><p><code>&lt;img&gt;</code>标签，使用的是<code>src</code>源属性，指的是图像的<code>URL</code>地址关系，<code>&lt;img src="url" /&gt;</code></p></li><li><p>替换文本属性<code>&lt;Alt&gt;</code>,表示的是为图像定义一串预备的可替换的文本，替换文本属性的值是用户自己定义的。</p><ul><li><p><code>&lt;area&gt;标签的coords属性规定了客户端图像映射到鼠标敏感的区域的坐标</code></p><ul><li>如下面代码：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>circle<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>180,139,14<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>venus.htm<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Venus<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token comment">&lt;!--这里的 x 和 y 定义了圆心的位置（"0,0" 是图像左上角的坐标），r 是以像素为单位的圆形半径。--&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>​</p></li><li><p><strong>HTML表格</strong></p><ul><li><p>表格是由<code>&lt;table&gt;</code>标签进行定义，每个表格都有若干行<code>&lt;tr&gt;</code>，每行是会被分割为若干个单元格<code>&lt;td&gt;</code>。数据单元格的内容，包含文本、图片、列表、段落、表单、水平线、表格等等。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!--border="1"表示1个像素，也就是1px--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>row 1, cell 1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>row 1, cell 2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>row 2, cell 2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--tr是行，td是列--&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>*<strong>表格跨行、跨列操作</strong></p><p><code>&lt;colspan&gt;</code>实现单元格的跨列操作，使用<code>&lt;rowspan&gt;</code>实现单元格的跨行操作。</p><blockquote><p>其中的colspan="0"表示浏览器横跨到列的最后一列，对应rowspan也是一样,其余的直接数字就表示跨的列/行。</p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">&gt;</span></span>星期一<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">&gt;</span></span>星期二<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">colspan</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>星期天<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/09/11/html-css-zhi-shi-zhun-bei/%E8%B7%A8%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA.jpg" alt="跨列表展示"></p><p>​</p></li></ul></li><li><p><strong>HTML列表</strong></p><ul><li><strong>无序列表</strong><code>&lt;ul&gt;,每个列表项始于&lt;li&gt;</code></li><li><strong>有序列表</strong><code>&lt;ol&gt;</code>，每个列表项始于<code>&lt;li&gt;标签</code></li></ul></li></ul><p>​</p><ul><li><p><strong>HTML的块</strong></p><ul><li><p>大多数的HTML元素被定义为块级元素或者是内联元素，对于<strong>HTML块级元素</strong>来说，其在浏览器显示的时候，通常会以新行来开始或者结束。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>HTML的内联元素</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">常见的有：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span><span class="token punctuation">&gt;</span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span><span class="token punctuation">&gt;</span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>HTML<code>&lt;span&gt;</code>元素</strong></p><blockquote><p><code>&lt;span&gt;</code>元素可用于部分文本设置样式属性</p></blockquote><p>​</p></li></ul></li><li><p><strong>HTML的id属性</strong></p><ul><li><p>id属性指定HTML元素中唯一id，属性的值在HTML文档中国也必须是唯一的。</p><blockquote><p>这点和类名不一样，一个类名可以由多个元素共同使用，但是一个id属性只能由一个元素使用</p></blockquote></li></ul></li></ul><p>​</p><ul><li><p><strong>HTML Iframe</strong></p><ul><li><p><code>Iframe</code>通常用于在网页内显示网页，主要是用于嵌套网页</p><p><code>&lt;iframe src="https://shakej96.github.io/"&gt;&lt;/iframe&gt;,&lt;!--URL 指向隔离页面的位置。--&gt;</code></p></li><li><pre class="line-numbers language-language-html"><code class="language-language-html"><iframe src="https://shakej96.github.io/"></iframe><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>同样是可以设置高度和宽度</p></li><li><p><code>Iframe</code> :<code>frameborder</code>的属性规定是否显示周围的边框。</p></li></ul><p>​</p><p style="color:red;font-size:20px;" align="center">先写这么多吧，基本的HTML操作应该都复习到了，后续再添加上常用的CSS。</p><center>明天面试加油😊</center></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端准备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 394.字符串解码</title>
      <link href="/2023/09/09/leetcode-394-zi-fu-chuan-jie-ma/"/>
      <url>/2023/09/09/leetcode-394-zi-fu-chuan-jie-ma/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-394.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81" tabindex="-1"><a href="https://leetcode.cn/problems/decode-string/">Leetcode 394. 字符串解码</a></h3><blockquote><p>摘要：本题名为字符串的解码，实际上分为两部分，一部分是字符串出现的次数；另外一部分是子字符串。本题引入数据结构是栈，通过对"[ ]"括号的分类，判断入栈出栈的时机，对全部的字符串进行解码。</p></blockquote><p>​</p><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><ul><li><p>给定一个经过编码的字符串，返回它解码后的字符串。</p></li><li><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p></li><li><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p></li><li><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：s = "3[a]2[bc]"输出："aaabcbc"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：s = "3[a2[c]]"输出："accaccacc"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><hr><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><ul><li><p>一看到题目想到的是对数字和字符进行分类，但是后来考虑到这是通过<code>字符串</code>的形式进行的解码，而且对数字和字符串的匹配关系存在==“[ ]“<mark>的要求，所以这里就对</mark>”[ ]”==进行讨论，<strong>将引入辅助栈对数字和字符串进行匹配</strong>，算法的流程如下：</p><ol><li><p>构建辅助栈 <code>stack</code>， 遍历字符串 <code>s</code> 中每个字符 c；</p><ul><li><p>当 c 为数字时，将数字字符转化为数字 <code>multi</code>，用于后续倍数计算；</p></li><li><p>当 c 为字母时，在<code> res</code> 尾部添加 c；</p></li><li><p>当 c 为 <code>[</code> 时，将当前 <code>multi </code>和 <code>res</code> 入栈，并分别置空置 0：</p><ul><li>记录此 <code>[</code> 前的临时结果<code> res</code> 至栈，用于发现对应 <code>]</code> 后的拼接操作；</li><li>记录此 <code>[</code> 前的倍数 <code>multi</code> 至栈，用于发现对应 <code>] </code>后，获取 <code>multi × [...]</code> 字符串。</li><li>进入到新<code>[</code>后，<code>res </code>和 <code>multi</code> 重新记录。</li></ul></li><li><p>当 c 为<code>]</code>时，<code>stack</code> 出栈，拼接字符串 <code>res = last_res + cur_multi * res</code>，其中:</p><ul><li><code>last_res</code>是上个 [ 到当前 [ 的字符串，例如 <code>"3[a2[c]]" </code>中的 <code>a</code>；</li><li><code>cur_multi</code>是当前 [ 到 ] 内字符串的重复倍数，例如 <code>"3[a2[c]]"</code> 中的 <code>2</code>。</li></ul></li></ul></li><li><p>返回字符串<code> res</code>。</p></li></ol></li><li><p>其实就是对所有的字符进行划分，引入两个栈空间对数字和字符进行存储，这里要用到的是<code>LinkedList</code>的数据结构链表，对字符串进行拼接。</p></li></ul><hr><h3 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3. 具体代码</h3><ul><li><p><strong>Java代码如下：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public String decodeString(String s) {        //首先需要注意的是对于字符串的拼接和次数的限制.这里还有‘[]’的要求，其实有提示就是需要栈的进出        StringBuffer res=new StringBuffer();        int multi=0;        LinkedList&lt;Integer&gt; stack_multi=new LinkedList&lt;&gt;();        LinkedList&lt;String&gt; stack_res=new LinkedList&lt;&gt;();        for(Character c:s.toCharArray()){            if(c=='['){                stack_multi.addLast(multi);//添加数字的栈                stack_res.addLast(res.toString());//在当前的栈的末尾添加新遍历后的元素                multi=0;//对应的清0                res=new StringBuffer();//res重置为空的字符串，便于后续的存储            }            else if(c==']'){                StringBuffer tmp=new StringBuffer();//添加暂时的中间变量                int cur_multi=stack_multi.removeLast();//弹出最后的元素，并且在弹出后首先清除                for(int i=0;i&lt;cur_multi;i++){                    tmp.append(res);//遍历需要复写的次数                }                res=new StringBuffer(stack_res.removeLast()+tmp);//返回特定的字符串，为下一次遍历做准备            }            else if(c&gt;='0' &amp;&amp; c&lt;='9'){                multi=multi*10+Integer.parseInt(c+"");//先将字符'c'转化为字符串的形式，后来当遇到一个数字字符时，将其转换为整数，并将其累积到乘数中，让多个字符形成字符串的格式            }            else res.append(c);//字符串直接拼接        }        return res.toString();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>复杂度分析：</strong></p><ul><li><p>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>，通过一次遍历<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></eq></p></li><li><p>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>,辅助栈在极端情况下是需要使用线性空间的，也就是调用太多次==”[ ]“==,比如：<code>2[2[2[a]]]</code></p></li></ul></li></ul><hr><blockquote><p>插一句题外话：最近开始投实习了，也希望可以在工作项目中得到提升吧，刷题大多数情况下是有思路，但是写得不规范，导致总是会有小错误。在接下来的日子里，继续学习沉淀，希望可以在大三找到一份实习工作，压力🍐++;</p></blockquote><center><span style="text-align:center;font-size:30px;background-color:lightblue;">我会努力的！👌</span>  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css"></center>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 1921.消灭怪物的最大数量</title>
      <link href="/2023/09/07/leetcode-1921-xiao-mie-guai-wu-de-zui-da-shu-liang/"/>
      <url>/2023/09/07/leetcode-1921-xiao-mie-guai-wu-de-zui-da-shu-liang/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-1921.-%E6%B6%88%E7%81%AD%E6%80%AA%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F" tabindex="-1"><a href="https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/">Leetcode 1921. 消灭怪物的最大数量</a></h3><blockquote><p>概要：本题是在比较孤傲五移动的次数和我们可以走的次数，其中需要判断的是每一次移动之后，怪物移动的距离是否会比人移动的次数多。这里重要的思想是移动的次数问题，需要满足取余的思想</p></blockquote><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><ul><li>你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个 <strong>下标从 0 开始</strong> 且长度为 <code>n</code> 的整数数组 <code>dist</code> ，其中 <code>dist[i]</code> 是第 <code>i</code> 个怪物与城市的 <strong>初始距离</strong>（单位：米）。</li><li>怪物以 <strong>恒定</strong> 的速度走向城市。给你一个长度为 <code>n</code> 的整数数组 <code>speed</code> 表示每个怪物的速度，其中 <code>speed[i]</code> 是第 <code>i</code> 个怪物的速度（单位：米/分）。</li><li>怪物从 <strong>第 0 分钟</strong> 时开始移动。你有一把武器，并可以 <strong>选择</strong> 在每一分钟的开始时使用，包括第 0 分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。</li><li>一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 <strong>恰</strong> 在某一分钟开始时到达城市，这会被视为 <strong>输掉</strong> 游戏，在你可以使用武器之前，游戏就会结束。</li><li>返回在你输掉游戏前可以消灭的怪物的 <strong>最大</strong> 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回 <code>n</code> 。</li></ul><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：dist = [1,3,4], speed = [1,1,1]输出：3解释：第 0 分钟开始时，怪物的距离是 [1,3,4]，你消灭了第一个怪物。第 1 分钟开始时，怪物的距离是 [X,2,3]，你没有消灭任何怪物。第 2 分钟开始时，怪物的距离是 [X,1,2]，你消灭了第二个怪物。第 3 分钟开始时，怪物的距离是 [X,X,1]，你消灭了第三个怪物。所有 3 个怪物都可以被消灭。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><hr><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><ul><li><p><code>dist[]</code>数组表示的距离，<code>speed[]</code>表示的是移动的速度（每次移动的距离），所以可见对于怪物而言，需要计算的就是移动<code>所需的时间</code>，或者说是<code>次数</code>问题</p></li><li><p>那对于人而言，每分钟我们都可以杀一只怪兽，如果怪兽在我们击杀前到达，<strong>也就是<mark>人杀死怪物需要的次数</mark>比<mark>怪物到达城市所需的次数</mark>多</strong>的话，则会输掉比赛。</p></li><li><p>所以返回的是可以杀死多少个这样的怪物，是人可以拥有的移动的次数<code>i</code>（人每移动一次杀死一只怪兽）</p></li></ul><hr><h3 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3. 具体代码</h3><ul><li>首先引入数组<code>arr[]</code>，用于表示每只怪兽到达需要的时间（次数）</li><li>接着遍历所有的怪兽数组<code>dist[]</code>,补充当前的<code>arr[]</code>数组</li><li>接着排序，对<code>arr[]</code>数组进行排序，<strong>其实就是危险性的排序</strong></li><li>遍历当前的<code>arr[]</code>数组，判断当前的人的移动次数和对应的的怪兽次数比较</li></ul><p><strong>java代码如下：</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution {    public int eliminateMaximum(int[] dist, int[] speed) {        //java, 排序        int n = dist.length;        //记录每只怪兽到达需要的时间        int[] arr = new int[n];        for (int i = 0; i &lt; n; i++) {            if (dist[i] == 0) return 0;//如果距离为0.此时怪兽已经到达            arr[i] = dist[i] % speed[i] == 0 ? dist[i] / speed[i] - 1: dist[i] / speed[i];//之所以取余，是因为speed[i]每一次都是以speed[i]的速度增长，而不是单纯地走一步++，            //如果此时的取余为0，说明还可以让它走商减1次（除去最后遇到的那次），也就是剩余商-1次机会            //如果此时的取余不为0，说明还剩下商次机会，不用减1，是因为不会刚好遇到        }        //排序，对所有的arr时间进行排序        Arrays.sort(arr);        //每分钟我们都可以杀一只怪兽，如果怪兽在我们击杀前到达，则会输掉比赛        for (int i = 1; i &lt; n; i++) {//i表示次数问题            if (arr[i] &lt; i) return i;        }        return n;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析</strong></p><ul><li><p><strong>时间复杂度:</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><ol><li>首先，对于遍历数组 <code>dist</code> 和 <code>speed</code> 来计算 <code>arr</code> 数组的时间复杂度是 O(n)，其中 n 是数组的长度。</li><li>接下来，对 <code>arr</code> 数组进行排序的时间复杂度是 O(nlogn)，其中 n 是数组的长度。</li><li>最后，再次遍历 <code>arr</code> 数组进行比较的时间复杂度是 O(n)</li></ol></blockquote></li><li><p><strong>空间复杂度：</strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><p>该代码仅仅使用了一个数组的长度来存储每只怪兽会到达的时间，n为数组的长度，在这之后并未使用额外的空间了</p></blockquote><p>​<br>​</p><hr></li></ul></li></ul><center><span style="color:#0f39;font-size:30px;font-weight:bolder">END👌</span></center><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三步走套路递归问题</title>
      <link href="/2023/09/04/san-bu-zou-tao-lu-di-gui-wen-ti/"/>
      <url>/2023/09/04/san-bu-zou-tao-lu-di-gui-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="%E4%B8%89%E6%AD%A5%E8%B5%B0%E5%A5%97%E8%B7%AF%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98" tabindex="-1">三步走套路递归问题</h3><blockquote><p>写递归的题目的时候发现总是不清楚递归的次序和条件，当前的函数做了什么？它调用自身后的下一层又做了什么…这样想还是比较复杂的，思考了很久，在网上学习八股的知识的时候想到了具体的过程，下面就来说说看。</p></blockquote><h3 id="1.-%E4%B8%89%E6%AD%A5%E8%B5%B0%E5%A5%97%E8%B7%AF" tabindex="-1">1. 三步走套路</h3><ul><li><p>先上一张图片，里面清晰地记录了递归的过程和每一层所需要实现的作用。</p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/09/04/san-bu-zou-tao-lu-di-gui-wen-ti/3_step_picture.png" alt="3_step_picture" style="zoom:67%;"></li><li><p><strong>个人理解</strong>：递归，其实就是将一级递归（也就是最开始的那层递归），调用之后需要返回特定的值，一直递归直到找到终止条件。</p></li><li><p><strong>由此可见</strong></p><ol><li><strong>找整个递归的终止条件：递归应该在什么时候结束？</strong></li><li><strong>找返回值：应该给上一级返回什么信息？</strong></li><li><strong>本级递归应该做什么：在这一级递归中，应该完成什么任务？</strong></li></ol></li></ul><hr><h3 id="2.-%E4%B8%BE%E4%BE%8B%E5%AE%9E%E6%88%98" tabindex="-1">2. 举例实战</h3><ul><li><p><strong><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">Leetcode 24. 两两交换链表中的节点</a></strong></p></li><li><p>简单利用三部曲：1. 找到终止条件（也就是特例情况）；2. 找到前一个递归级的返回值；3.在当前的递归中需要什么（具体分析）</p></li></ul><blockquote><p>开始实际操作！</p></blockquote><h4 id="2.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">2.1 题目说明</h4><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：head = [1,2,3,4]输出：[2,1,4,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：head = []输出：[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：head = [1]输出：[1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><p>链表中节点的数目在范围 <code>[0, 100]</code> 内</p></li><li><p><code>0 &lt;= Node.val &lt;= 100</code></p></li></ul><hr><h4 id="2.2-%E5%A5%97%E8%B7%AF%E5%88%86%E6%9E%90" tabindex="-1">2.2 套路分析</h4><ol><li><p><strong>找终止条件。</strong> 什么情况下递归终止？没得交换的时候，递归就终止了，因此当链表只剩一个节点或者没有节点的时候，自然递归就终止了。</p></li><li><p><strong>找返回值。</strong> 我们希望向上一级递归返回什么信息？由于我们的目的是两两交换链表中相邻的节点，因此自然希望交换给上一级递归的是已经完成交换处理，即已经处理好的链表。</p></li><li><p><strong>本级递归应该做什么。</strong> 结合第二步，看下图！由于只考虑本级递归，所以这个链表在我们眼里其实也就三个节点：head、head.next、已处理完的链表部分。而本级递归的任务也就是交换这3个节点中的前两个节点。</p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/09/04/san-bu-zou-tao-lu-di-gui-wen-ti/3.png" alt="3" style="zoom:67%;"></li></ol><hr><h4 id="2.3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" tabindex="-1">2.3 代码实现</h4><p>​</p><ul><li><p><strong>具体的代码如下(java)：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public ListNode swapPairs(ListNode head) {      //终止条件：链表只剩一个节点或者没节点了，无法再次进行交换。返回的是已经处理好的链表        if(head == null || head.next == null){            return head;        }      //一共三个节点:head, next, swapPairs(next.next)      //下面的任务便是交换这3个节点中的前两个节点        ListNode next = head.next;        head.next = swapPairs(next.next);        next.next = head;      //根据第二步：返回给上一级的是当前已经完成交换后，即处理好了的链表部分，需要返回的值        return next;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h3 id="3.%E7%9B%B8%E4%BC%BC%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90" tabindex="-1">3.相似题目分析</h3><ul><li><p><a href="https://leetcode.cn/problems/invert-binary-tree/">Leetcode 226. 翻转二叉树</a></p><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​</p></li><li><p><strong>分析：</strong></p><ul><li><p><strong>终止条件</strong>：无法返回根节点<code>root</code>,也就是根节点此时为空<code>null</code></p></li><li><p><strong>找上一回递归的返回值</strong>：对于每次的翻转，我们希望返回的是对应枝节的根节点<code>root</code>，这里先不用考虑每一层的操作，反正最后返回的是该层的根节点</p></li><li><p><strong>本级递归的操作</strong>：每一层都会进行左右交换，首先确定左子树，接着将左子树的每个子节点依次进行递归左右交换操作，实现每一层的交换，递归从底到顶返回的时候再将原始的左子树和右子树进行交换即可。<strong>也就是要求使用两次递归，一次是左右子树之间的交换，一次是根左右子树之间的交换</strong>，最后返回上一级的递归结果</p></li></ul></li><li><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public TreeNode invertTree(TreeNode root) {        if(root==null){            return root;//终止        }        TreeNode leftafter=root.left;        root.left=invertTree(root.right);        root.right=invertTree(leftafter);                return root;//前一次的返回值    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><blockquote><p>最后：递归的套路还有很多需要实际上手体会，本文只介绍其中一个，希望可以用到以后的刷题实践中去吧</p></blockquote><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 918. 环形子数组的最大和</title>
      <link href="/2023/09/03/leetcode-918-huan-xing-zi-shu-zu-de-zui-da-he/"/>
      <url>/2023/09/03/leetcode-918-huan-xing-zi-shu-zu-de-zui-da-he/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-918.-%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C" tabindex="-1"><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">Leetcode 918. 环形子数组的最大和</a></h3><blockquote><p>概要：子数组的最大和利用的是动态规划/滑动窗口的思想，对于环形子数组，需要考虑的是前后元素之间的大小关系，比如[1,2,3,-4]，在环形数组中即为：[1,2,3,-4,1,2,3,-4…],我们要利用动态规划，找到区间子数组最小值和最大值，分别进行判断操作。</p></blockquote><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><ul><li><p>给定一个长度为 <code>n</code> 的<strong>环形整数数组</strong> <code>nums</code> ，返回 <em><code>nums</code> 的非空 <strong>子数组</strong> 的最大可能和</em> 。</p></li><li><p><strong>环形数组</strong> 意味着数组的末端将会与开头相连呈环状。形式上， <code>nums[i]</code> 的下一个元素是 <code>nums[(i + 1) % n]</code> ， <code>nums[i]</code> 的前一个元素是 <code>nums[(i - 1 + n) % n]</code> 。</p></li><li><p><strong>子数组</strong> 最多只能包含固定缓冲区 <code>nums</code> 中的每个元素一次。形式上，对于子数组 <code>nums[i], nums[i + 1], ..., nums[j]</code> ，不存在 <code>i &lt;= k1, k2 &lt;= j</code> 其中 <code>k1 % n == k2 % n</code> 。</p></li></ul><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,-2,3,-2]输出：3解释：从子数组 [3] 得到最大和 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​</p><hr><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><ul><li><p>首先需要明确的是：<code>环形子数组的最大和</code>包含两种可能性，一是直接动态规划得到子数组的最大和<code>MaxF</code>，二是环形子数组的出现循环，此时需要将元素之和<code>sum</code>减去子数组中的区间最小值<code>minS</code>后的值同<code>MaxS</code>进行比较.</p><ul><li><p>具体而言：由于是循环数组，我们可以选择将某一个区间剔除，计算剩余部分的最大子数组和。剔除的区间就是使得 <code>minS</code>取最小值的那个区间。</p></li><li><p>如果我们将剔除的区间放在数组的开头或结尾，那么剩余的部分即包含了原始数组的循环部分。</p><p>因此，<code>sum - minS</code> 就代表了考虑循环的情况下，剔除特定区间后剩余部分的最大子数组和。</p></li></ul></li><li><p>动态规划包含了对于数组元素的选或不选的问题，这里直接遍历即可.</p></li></ul><hr><h3 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3. 具体代码</h3><ul><li><p>该算法使用了动态规划的思想。通过遍历数组<code>nums</code>，维护以下变量：</p><ul><li><code>maxS</code>：最大子数组和，初值设为<code>负无穷大</code>。</li><li><code>minS</code>：最小子数组和，初值设为<code>0</code>（因为可以为空数组）。</li><li><code>maxF</code>：以当前元素为结尾的最大子数组和。</li><li><code>minF</code>：以当前元素为结尾的最小子数组和。</li><li><code>sum</code>：数组<code>nums</code>的总和。</li></ul></li><li><p><strong>代码如下：</strong></p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution{    public int maxSubarraySumCircular(int[] nums){        int maxS = Integer.MIN_VALUE; // 最大子数组和，不能为空        int minS = 0; // 最小子数组和，可以为空        int maxF = 0, minF = 0, sum = 0;        for (int x : nums) {            // 以 nums[i-1] 结尾的子数组选或不选（取 max）+ x = 以 x 结尾的最大子数组和            maxF = Math.max(maxF, 0) + x;            maxS = Math.max(maxS, maxF);            // 以 nums[i-1] 结尾的子数组选或不选（取 min）+ x = 以 x 结尾的最小子数组和            minF = Math.min(minF, 0) + x;            minS = Math.min(minS, minF);            sum += x;        }        return sum == minS ? maxS : Math.max(maxS, sum - minS);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>,其中的n代表数组<code>nums</code>的长度，代码使用了<strong>1次遍历进行计算最大子数组和最小子数组</strong></li><li><strong>空间复杂度</strong>：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq>,代码中仅使用了若干常数，为开辟新的存储空间</li></ul><p>​</p><hr><center><span style="font-size:30px;color:orange;font-weight:bolder">继续努力✊</span></center></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周赛360 T1与T2</title>
      <link href="/2023/08/27/zhou-sai-360-t1-yu-t2/"/>
      <url>/2023/08/27/zhou-sai-360-t1-yu-t2/</url>
      
        <content type="html"><![CDATA[<h3 id="%E5%91%A8%E8%B5%9B360%EF%BC%9At1%E4%B8%8Et2" tabindex="-1">周赛360：T1与T2</h3><blockquote><p>要说的话：隔了好多天又开始比赛了，还是2题选手，这回的前两题感觉还是比较容易想到的；后续的2题不太熟，所以等掌握了之后再回来补题解。</p></blockquote><h3 id="t1-.%E8%B7%9D%E7%A6%BB%E5%8E%9F%E7%82%B9%E6%9C%80%E8%BF%9C%E7%9A%84%E7%82%B9" tabindex="-1">T1 <a href="https://leetcode.cn/problems/furthest-point-from-origin/">.距离原点最远的点</a></h3><h4 id="1.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1.1 题目说明</h4><p>给你一个长度为 <code>n</code> 的字符串 <code>moves</code> ，该字符串仅由字符 <code>'L'</code>、<code>'R'</code> 和 <code>'_'</code> 组成。字符串表示你在一条原点为 <code>0</code> 的数轴上的若干次移动。</p><p>你的初始位置就在原点（<code>0</code>），第 <code>i</code> 次移动过程中，你可以根据对应字符选择移动方向：</p><ul><li>如果 <code>moves[i] = 'L'</code> 或 <code>moves[i] = '_'</code> ，可以选择向左移动一个单位距离</li><li>如果 <code>moves[i] = 'R'</code> 或 <code>moves[i] = '_'</code> ，可以选择向右移动一个单位距离</li></ul><p>移动 <code>n</code> 次之后，请你找出可以到达的距离原点 <strong>最远</strong> 的点，并返回 <strong>从原点到这一点的距离</strong></p><p>​</p><p><strong>示例1</strong>：</p><pre class="line-numbers language-none"><code class="language-none">输入：moves = "L_RL__R"输出：3解释：可以到达的距离原点 0 最远的点是 -3 ，移动的序列为 "LLRLLLR" 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​</p><hr><h4 id="1.2-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">1.2 解答分析</h4><ul><li><strong>分析</strong>：对于距离原点的距离，<code>_</code>是可以随意替换的（可左可右），此时决定最大的距离的是<code>L</code>与<code>R</code>的个数问题，是否可以抵消？接着加上<code>_</code>的个数即可。下面是具体的代码方法<ul><li>对于字符串的每一位，可以利用<code>charAt()</code>,也可以将字符串转化为字符串数组，利用<code>toCharArray</code>的方法。</li><li><code>L和R的个数的抵消</code>，想到的是利用减法进行，但是需要绝对值<code>Math.abs()</code></li></ul></li></ul><hr><h4 id="1.3-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">1.3 具体代码</h4><ul><li><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int furthestDistanceFromOrigin(String moves) {    int distance=0;    int r=0,l=0;    for(char m:moves.toCharArray()){        if(m=='_'){            distance++;        }        if(m=='L'){            l++;        }        if(m=='R'){            r++;        }    }    distance=distance+Math.abs(r-l);    return distance;            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><ul><li><p>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>，其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></eq>为$ moves$的长度。</p></li><li><p>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq>。仅用到若干额外变量</p></li></ul></li></ul><hr><h3 id="t2-%E6%89%BE%E5%87%BA%E7%BE%8E%E4%B8%BD%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%92%8C" tabindex="-1">T2 <a href="https://leetcode.cn/problems/find-the-minimum-possible-sum-of-a-beautiful-array/">找出美丽数组的最小和</a></h3><h4 id="2.1-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">2.1 题目说明</h4><p>给你两个正整数：<code>n</code> 和 <code>target</code> 。</p><p>如果数组 <code>nums</code> 满足下述条件，则称其为 <strong>美丽数组</strong> 。</p><ul><li><code>nums.length == n</code>.</li><li><code>nums</code> 由两两互不相同的正整数组成。</li><li>在范围 <code>[0, n-1]</code> 内，<strong>不存在</strong> 两个 <strong>不同</strong> 下标 <code>i</code> 和 <code>j</code> ，使得 <code>nums[i] + nums[j] == target</code> 。</li></ul><p>返回符合条件的美丽数组所可能具备的 <strong>最小</strong> 和。</p><p>​</p><p><strong>示例1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：n = 2, target = 3输出：4解释：nums = [1,3] 是美丽数组。- nums 的长度为 n = 2 。- nums 由两两互不相同的正整数组成。- 不存在两个不同下标 i 和 j ，使得 nums[i] + nums[j] == 3 。可以证明 4 是符合条件的美丽数组所可能具备的最小和。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><hr><h4 id="2.2-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2.2 解答分析</h4><ul><li><p><strong>分析1</strong>:</p><ul><li><p>这道题目需要用到贪心算法。一个简单的思路，假设我们期望加入1，那么 k - 1 就不再符合要求。但是1和k - 1之间，我们肯定选择1，因为很直观的1更小。因为提示给的范围很小1 &lt;= n, k &lt;= 50。暴力计数，只要n能满足。</p></li><li><p>具体这里用到的是<code>HashSet</code>，利用对数据元素（Object）的储存功能进行配对。<code>HashSet</code>的用法中不存在<code>键值对</code>的说法，本题要用到的<code>contains()</code>也仅代表的是值功能</p></li></ul></li><li><p><strong>分析2</strong>：</p><ul><li>数学方法，对元素进行模拟（找规律），将<code>target</code>记作<code>k</code>,对于全体元素而言，比如<code>1和k-1</code>两个只能选一个，因此可以直到<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k//2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">//2</span></span></span></span></eq>(表示向下取整,数学上直接<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">/2</span></span></span></span></eq>)，此时可以假设<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>k</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m=(min(k//2,n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">//2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></eq>,元素和为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(1+m)m/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mord mathnormal">m</span><span class="mord">/2</span></span></span></span></eq></li><li>同时，剩余的<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n-m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></eq>个数，只能从<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></eq>后面开始选，那么第二段就是从<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></eq>到<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k+n-m-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></eq>，元素和这里与上面雷同</li><li>将上述的两段之和相加即可</li></ul></li></ul><hr><h4 id="2.3-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">2.3 具体代码</h4><ul><li><p><strong>代码1：贪心算法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public long minimumPossibleSum(int n, int target) {    long res = 0;    int i = 1;    Set&lt;Integer&gt; set=new HashSet&lt;&gt;();    while(n&gt;0){        if(!(set.contains(i))){            set.add(target-i);            res+=i;            n--;        }        i++;        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><ul><li><p>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></eq></p><blockquote><p>其中的<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>是<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">set.contains()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ain</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span></eq>的时间复杂度</p></blockquote></li><li><p>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></p><blockquote><p>HashSet额外开辟的存储空间n</p></blockquote></li></ul></li><li><p><strong>代码2：数学模拟</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public long minimumPossibleSum(int n, int k) {        long m = Math.min(k / 2, n);        return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><ul><li><p>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq></p></li><li><p>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq></p></li></ul></li></ul><hr><h3 id="%E6%80%BB%E7%BB%93" tabindex="-1">总结</h3><blockquote><p>路漫漫其修远兮，吾将上下而求索。刷题的路还很长，开学了要每天坚持学习算法知识，希望可以早日有所突破吧！加油，奥力给！</p><p>😉🤗</p></blockquote><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/08/27/zhou-sai-360-t1-yu-t2/Cyberpunk&amp;Bupt.jpg" alt="Cyberpunk&amp;Bupt" style="zoom:25%;"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 560:和为k的子数组</title>
      <link href="/2023/08/25/leetcode-560-he-wei-k-de-zi-shu-zu/"/>
      <url>/2023/08/25/leetcode-560-he-wei-k-de-zi-shu-zu/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-560%EF%BC%9A%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84" tabindex="-1">Leetcode-560：和为k的子数组</h3><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><ul><li><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 <strong>k</strong> 的<strong>连续的子数组</strong>的个数。</p><blockquote><p>示例 1 :</p><p>输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</p></blockquote></li></ul><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90%EF%BC%88%E5%90%AB%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%89" tabindex="-1">2. 解答分析（含复杂度）</h3><ul><li><p>题目本质上是可以利用暴力解决的，也就是用双重循环进行和为<code>k</code>的子数组的个数统计即可，但是这里我们想利用更多的方法，主要分为3部分：</p><ol><li><p><strong>暴力</strong></p></li><li><p><strong>前缀和</strong></p></li><li><p><strong>前缀和+HashMap</strong></p></li></ol><hr></li></ul><h3 id="%E2%91%A0-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95" tabindex="-1">① 暴力解法</h3><ul><li>直接上代码：</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int subarraySum(int[] nums, int k) {         int len = nums.length;         int sum = 0;         int count = 0;         //双重循环         for (int i = 0; i &lt; len; ++i) {             for (int j = i; j &lt; len; ++j) {                 sum += nums[j];                 //发现符合条件的区间                 if (sum == k) {                     count++;                 }             }             //记得归零，重新遍历             sum = 0;         }         return count;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>复杂度分析</strong>：<ul><li>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>，这里 $N $是数组的长度；</li><li>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq>。</li></ul></li></ul><hr><h3 id="%E2%91%A1-%E5%89%8D%E7%BC%80%E5%92%8C" tabindex="-1">② 前缀和</h3><ul><li>前缀和<code>pre[i]</code>的关键是找到前一个和后一个的关系，这里的连续子数组的元素之和恰好满足前缀求和的关系，所以可以采取。</li><li>需要注意的是：<ol><li>注意偏移，因为我们的<code>nums[2]</code>到<code>nums[4]</code>等于<code>pre[5]-pre[2]</code>，所以这样就可以得到<code>nums[i,j]</code>区间内的和</li><li>前缀和是从<code>pre[1]</code>开始填充的</li></ol></li><li>上代码：</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int subarraySum(int[] nums, int k) {        //前缀和数组        int[] presum = new int[nums.length+1];        for (int i = 0; i &lt; nums.length; i++) {            pre[i+1] = nums[i] + pre[i];        }        //统计个数        int count = 0;        for (int i = 0; i &lt; nums.length; ++i) {            for (int j = i; j &lt; nums.length; ++j) {                              if (pre[j+1] - pre[i] == k) {                    count++;                }            }        }        return count;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析</strong>：</p><ul><li><p>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>，这里 N 是数组的长度；</p></li><li><p>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>。</p></li></ul></li></ul><hr><h3 id="%E2%91%A2-%E5%89%8D%E7%BC%80%E5%92%8C-%2B-hashmap" tabindex="-1">③ 前缀和 + HashMap</h3><ul><li><p>分析上述的前缀和方法不难看出：该代码虽然用到了前缀和数组，但是对比暴力法并没有提升性能，时间复杂度仍为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>，空间复杂度成了 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>。</p></li><li><p>在两数之和的题目中，我们可以看出利用<code>HashMap</code>进行的遍历求解，只用遍历循环数组一次即可，这里我们同样采用的做法是，我们将数组的值和索引存入<code>map</code>中，当我们遍历到某一值 <code>x </code>时，判断 <code>map </code>中是否含有<code> target - x</code>即可。</p></li><li><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int[] twoSum(int[] nums, int target) {        HashMap&lt;Integer,Integer&gt; map  = new HashMap&lt;&gt;();        //一次遍历        for (int i = 0; i &lt; nums.length; ++i) {            //存在时，我们用数组得值为 key，索引为 value            if (map.containsKey(target - nums[i])){                             return new int[]{i,map.get(target-nums[i])};            }            //存入值            map.put(nums[i],i);        }        //返回        return new int[]{};    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><blockquote><p>我们完全可以通过 presum - k的个数获得 k 的个数,如图所示:</p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/08/25/leetcode-560-he-wei-k-de-zi-shu-zu/presum-k.png" alt="presum-k" style="zoom:67%;"></blockquote></li><li><p>本题的代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int subarraySum(int[] nums, int k) {        if (nums.length == 0) {            return 0;        }        HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();        //细节，这里需要预存前缀和为 0 的情况，会漏掉前几位就满足的情况        //例如输入[1,1,0]，k = 2 如果没有这行代码，则会返回0,漏掉了1+1=2，和1+1+0=2的情况        //输入：[3,1,1,0] k = 2时则不会漏掉        //因为presum[3] - presum[0]表示前面 3 位的和，所以需要map.put(0,1),垫下底        map.put(0, 1);        int count = 0;        int presum = 0;        for (int x : nums) {            presum += x;            //当前前缀和已知，判断是否含有 presum - k的前缀和，那么我们就知道某一区间的和为 k 了。            if (map.containsKey(presum - k)) {                count += map.get(presum - k);//获取次数            }            //更新            map.put(presum,map.getOrDefault(presum,0) + 1);        }        return count;    }}//或者是：class Solution {    public int subarraySum(int[] nums, int k) {        /*        前缀和+HashMap(两数之和进阶版)        若存在i与j满足sum[i,j]=sum[j+1]-sum[i]=k，对于j+1，满足条件的i的个数可以先统计出来        前面符合条件的数据为:sum[i]=sum[j+1]-k，这里注意是i&lt;=j，因此需要先统计了前面的再更新当前的        与两数之和是差不多的思路，不过这个多了个前缀和        时间复杂度:O(N) 空间复杂度:O(N)         */        int res = 0;        // 前缀和还可以进一步空间优化        int sum = 0;        // 哈希表存储前缀和数组中缺少了某个数的个数        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        map.put(0, 1);  // 初始前缀和        for (int num : nums) {            sum += num;            // 先统计            res += map.getOrDefault(sum - k, 0);            // 再更新当前的            map.put(sum, map.getOrDefault(sum, 0) + 1);        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>复杂度分析</strong>：</p><ul><li><p>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>，这里 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></eq>是数组的长度；</p></li><li><p>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>。</p></li></ul></li></ul><hr><h3 id="3.-%E5%8F%98%E5%BC%8F%E9%A2%98%E7%9B%AE" tabindex="-1">3. 变式题目</h3><blockquote><p><a href="https://leetcode.cn/problems/count-number-of-nice-subarrays/">1248. 统计「优美子数组」</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。如果某个连续子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「<strong>优美子数组</strong>」。</p><p>请返回这个数组中 <strong>「优美子数组」</strong> 的数目。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,1,2,1,1], k = 3输出：2解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><p>分析解答：类似，只是在遇到奇数的时候将prenum更新而已。类似于<code>HashMap</code>,这里用数组的索引来表示哈希表中的<code>key</code>，对应的值模拟哈希表中的<code>value</code>.代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int numberOfSubarrays(int[] nums, int k) {        int len=nums.length;        int []map=new int[len+1];        map[0]=1;        int oddnum=0;        int count=0;        for(int i=0;i&lt;len;i++){            if(nums[i]%2!=0){//如果是奇数的话，存入oddnum                oddnum++;            }            if(oddnum&gt;=k){                count+=map[oddnum-k];            }            map[oddnum]++;        }        return count;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="4.-%E5%B1%95%E6%9C%9B%EF%BC%88%E4%B8%8E%E9%A2%98%E7%9B%AE%E6%97%A0%E5%85%B3%EF%BC%89" tabindex="-1">4. 展望（与题目无关）</h3><blockquote><p>开学了，还是会继续学习算法，刷力扣，博客也会经常更新自己的学习动态，加油哇！🤗👍大三希望有机会找到一份实习，前后端都行，美化简历😊</p></blockquote><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/08/25/leetcode-560-he-wei-k-de-zi-shu-zu/Bupt.jpg" alt="Bupt" style="zoom:20%;">  <center><span style="font-size:30px;color:red;font-weight:bolder;">END~</span><center><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css"></center></center>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PriorityQueue实现最小堆和最大堆的用法[JAVA]</title>
      <link href="/2023/07/27/priorityqueue-shi-xian-zui-xiao-dui-he-zui-da-dui-de-yong-fa-java/"/>
      <url>/2023/07/27/priorityqueue-shi-xian-zui-xiao-dui-he-zui-da-dui-de-yong-fa-java/</url>
      
        <content type="html"><![CDATA[<h3 id="%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D" tabindex="-1">一、基本介绍</h3><ol><li><p><strong>介绍</strong></p><p>PriorityQueue翻译为优先队列，“优先”指元素在队列中按一定的顺序（优先级）进行存放，“队列”指一种先进先出的数据结构。因此PriorityQueue可以实现按照一定的优先级存取元素。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/07/27/priorityqueue-shi-xian-zui-xiao-dui-he-zui-da-dui-de-yong-fa-java/%E7%AE%80%E4%BB%8B.png" alt="简介"></p></li><li><p><strong>用法</strong></p></li></ol>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">//默认容量为 11  private static final int DEFAULT_INITIAL_CAPACITY = 11;  //1、无参构造，默认容量和默认排序方法  public PriorityQueue() {          this(DEFAULT_INITIAL_CAPACITY, null);      }  //2、指定容量  public PriorityQueue(int initialCapacity) {          this(initialCapacity, null);      }  //3、指定排序方法  public PriorityQueue(Comparator&lt;? super E&gt; comparator) {          this(DEFAULT_INITIAL_CAPACITY, comparator);      }  //4、指定容量和排序方法  public PriorityQueue(int initialCapacity,                           Comparator&lt;? super E&gt; comparator) {          // Note: This restriction of at least one is not actually needed,          // but continues for 1.5 compatibility          if (initialCapacity &lt; 1)              throw new IllegalArgumentException();          this.queue = new Object[initialCapacity];          this.comparator = comparator;      }  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在构造PriorityQueue时候我们可以指定初始容量和元素在队列中的排序方法，如果不指定，则默认初始容量为11，默认的排序方式是将元素从小到大进行排序。</p></blockquote><ol start="3"><li><strong>最小堆构造</strong></li></ol>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">PriorityQueue&lt;Integer&gt; minheap = new PriorityQueue&lt;&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用无参构造，元素在队列中按照默认从小到大的顺序排列，可以保证每次出队列的元素都是队列中的最小的元素。</li></ul><ol start="4"><li><p><strong>最大堆构造</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">PriorityQueue&lt;Integer&gt; maxheap = new PriorityQueue&lt;&gt;(Collections.reverseOrder());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>将排序方法指定为反序，元素是从大到小的顺序排列，也就是保证每次出队列的元素是队列中的最大的元素。</li></ul></li></ol><h3 id="%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95" tabindex="-1">二、常用的方法</h3><ul><li><p>以<code>Integer</code>的类型为例：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/07/27/priorityqueue-shi-xian-zui-xiao-dui-he-zui-da-dui-de-yong-fa-java/%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95.png" alt="常见用法"></p></li></ul><p>​</p><hr><h3 id="%E4%B8%89%E3%80%81%E4%B8%BE%E4%BE%8B" tabindex="-1">三、举例</h3><blockquote><p>Leetcode 2208. 将数组和减半的最少操作次数</p></blockquote><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><p>给你一个正整数数组 <code>nums</code> 。每一次操作中，你可以从 <code>nums</code> 中选择 <strong>任意</strong> 一个数并将它减小到 <strong>恰好</strong> 一半。（注意，在后续操作中你可以对减半过的数继续执行操作）</p><p>请你返回将 <code>nums</code> 数组和 <strong>至少</strong> 减少一半的 <strong>最少</strong> 操作数。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [5,19,8,1]输出：3解释：初始 nums 的和为 5 + 19 + 8 + 1 = 33 。以下是将数组和减少至少一半的一种方法：选择数字 19 并减小为 9.5 。选择数字 9.5 并减小为 4.75 。选择数字 8 并减小为 4 。最终数组为 [5, 4.75, 4, 1] ，和为 5 + 4.75 + 4 + 1 = 14.75 。nums 的和减小了 33 - 14.75 = 18.25 ，减小的部分超过了初始数组和的一半，18.25 &gt;= 33/2 = 16.5 。我们需要 3 个操作实现题目要求，所以返回 3 。可以证明，无法通过少于 3 个操作使数组和减少至少一半。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="2.-%E5%88%86%E6%9E%90%E8%A7%A3%E7%AD%94" tabindex="-1">2. 分析解答</h3><ul><li>常见的题目，由于每一次操作都会使得数组中的一个数字减半。要想使得总的数组中的减少的次数最少，<strong>其实就是从当前的数组中选取最大值进行减半的操作</strong></li><li>这里可以利用大根堆（优先队列）维护数组中的所有数，每次都是从优先队列中取出最大值 ttt，将其减半，然后将减半后的数重新放入优先队列中，同时更新 <code>s</code>，直到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">s≤0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></eq>为止。那么此时的操作次数就是答案。</li><li>用到的算法知识点是：贪心算法（每次选取队列中的最大值）+优先队列（大根堆，每次都更新排列）</li></ul><hr><h3 id="3.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" tabindex="-1">3.代码实现</h3><ul><li>Java代码（利用上述的<code>PriorityQueue</code>队列知识）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int halveArray(int[] nums) {        double s=0;        PriorityQueue&lt;Double&gt; q = new PriorityQueue&lt;&gt;(Collections.reverseOrder());        //上述的是最大堆，确保每次都是队列中最大的数出来,元素从大到小排列        for(int i:nums){            q.offer(i*1.0);//注意除半时候出现的浮点数值，先进行转换，添加队列中去            s+=i;//s为根堆（优先队列）元素之和        }        s/=2.0;//取半        int ans=0;        while(s&gt;0){//循环，直到s&lt;=0为止            double t =q.poll();//队头元素出列（当前的最大值）            s-=t/2.0;  //元素值减半，从s值中减去            q.offer(t/2.0);  //更新队列中的元素，找到最大值            ++ans;        }        return ans;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n * log_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>​</strong>。</p></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>​</strong>，其中的n指的是数组的长度。</p></li></ul><hr><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消失的她</title>
      <link href="/2023/07/10/xiao-shi-de-ta/"/>
      <url>/2023/07/10/xiao-shi-de-ta/</url>
      
        <content type="html"><![CDATA[<h3 id="%E6%B6%88%E5%A4%B1%E7%9A%84%E5%A5%B9%E5%BD%B1%E8%AF%84" tabindex="-1">消失的她影评</h3><blockquote><p>当利益过于庞大的时候，人性的阴暗面就会展露出来</p></blockquote><p>7月9号和哥们去看了《消失的她》，虽然之前在营销号内已经看过大致的剧情走向，但是真正到电影院里看完全片后，又有了不同的感觉。倒不是对爱情观又有什么执念了😂（毕竟牡丹20年），这里重点讨论人性和选择。</p><hr><h3 id="1.-%E6%95%85%E4%BA%8B%E6%A6%82%E8%BF%B0" tabindex="-1">1. 故事概述</h3><ul><li><p>《消失的她》讲述了这样一个故事：东南亚某地，何非（朱一龙 饰）的老婆李木子，突然失踪了。何非去警察局报案，结果第二天，他的床上莫名空降了个陌生女人。陌生女人说，她就是李木子，并且还拿出了照片作为证据。但，即使看到了所谓的证据，何非也还是不相信陌生女人。真正的李木子不见了踪影，成为了“消失的她”。随着剧情的发展，一张精心设置好的大局慢慢展开，凶手的身份逐渐明显起来。</p></li><li><p>作为一部悬疑片电影，和爱情扯上关系显然有点不合适，其实在电影放到一半时，也就是赌徒出现的时候，大概率就已经猜到了凶手正是丈夫何非。可是在看完电影后，内心却很难平静，倒不是因为剧情带来的震撼，相反，剧情给我的感觉和国外的悬疑电影很像，有反转但不多，细想也都合乎情理（至少符合角色的身份）。带给我震撼的其实是何非这个角色的设定，从最初的寻妻心切的“好丈夫”，到“亡命奔走”的赌徒，这才是人性的多面性所在，也是电影中最具阴暗面的地方。</p><hr></li></ul><h3 id="2.%E4%BA%AE%E7%82%B9%E5%88%86%E6%9E%90" tabindex="-1">2.亮点分析</h3><blockquote><ol><li>何非的回忆</li></ol></blockquote><ul><li>在电影中，可以很清楚地看到何非的回忆录，按照他的描述，他和李木子二人很恩爱，从第一段在潜水馆中救下险些溺水得李木子，到一起聊艺术，去看梵高的《星空》，再到车祸发生，出现了何非的表白“我会一辈子在你身边保护你”。回忆至此，故事画面充满了幸福和甜蜜，可是，从遇见到恋爱到结婚，这一切都是如此顺利，仿佛暗中已经挖好了陷阱，等待李木子的到来…</li><li>电影开始并未介绍何非的职业和爱好，留给观众的只有一个寻妻的丈夫形象，作为婚姻的一方，倘若二者发自内心深爱，妻子的失踪必然会引起丈夫的心急。何非确实这样做了，也正如他回忆录中所描述的一般，最初看电影的时候也是这样想的。但是随着后续剧情的进展，出现假李木子之后，何非的关注重心仿佛从真李木子身上转移，当前的首要目标是“除去假李木子”，为什么着急立案？为什么害怕假妻子的出现？为什么当问及李木子的时候总是会开始回忆过去的美好点滴，对妻子的失踪避而不谈，在整部电影中，何非的回忆是串联起这一切的关键线索，为后续的反转一步步埋下伏笔。</li></ul><blockquote><ol start="2"><li>陈麦（沈曼）的出现</li></ol></blockquote><ul><li>李木子最好的闺蜜是沈曼，在木子失踪后，沈曼本应该第一时间出现，但是站在何非的角度却从未出现过？所以，最初金牌律师陈麦的出现，明显就有暗示。剧中也有大量相关的片段镜头，诸如李木子和陈麦泡茶时都喜欢放柠檬，杯子底下的‘M’标记和表演箱上的M呼应，是否暗示着一切都是设好的局？</li><li>其次，在假李木子出现的时候，何非的眼神并不是害怕，感觉更多地是一种慌张。他以为这是曼曼的安排（曼曼本身对他就有偏见），所以才在一步步布局当中找到所谓的金牌律师陈麦，想着将假妻子的事情弄下去，自己好快速立案得到凭证。沈曼也是利用了赌徒的心理暗示，不愿相信任何人，除非可以对其利益实现最大化的特征，将何非圈在自己设定的陷阱当中。</li></ul><blockquote><ol start="3"><li>潜水和沙滩</li></ol></blockquote><ul><li><p>在本部电影中，令我感触最深的就是所谓的“海底星空”和阳光轻掠过的沙滩。电影中这两处场景的色调截然相反，代表着何非和李木子二人的性格特征和心理变化历程。</p><ul><li><p>何非对应的是海底的幽暗和未知，在其深潜馆中的上浮，我感觉更像一种自我的安慰救赎，而不是对生命的尊重和渴望，以至于后来到海底的“星空”，更像是一种未知的牢笼，将所谓的爱情和欲望深深锁在海底，不见光明，令人感受到郁闷和压抑。</p></li><li><p>李木子则是在温暖的海滩下留下了背影，将何非的脸照亮，更多是一种类似于乌托邦的幻想和对爱情的向往，这种渴望不是物欲的追求，相反，是明知物欲横流，却仍然想将爱留在彼此心间。所以这里的阳光和沙滩代表着爱情和爱人的简单纯粹，不带杂念，将彼此存储于世间温暖的阳光里。</p></li></ul><hr></li></ul><h3 id="3.-%E8%A7%82%E5%BD%B1%E6%84%9F%E6%82%9F" tabindex="-1">3. 观影感悟</h3><ol><li>相信世间仍然存在爱情，但是在爱中不要忽视人性中的恶与贪，切勿将个人的欲念强加于双方，甚至混融在婚姻生活中。<ul><li>爱情和婚姻仍然是两码事，学会了爱人，但是不一定学会了长久得爱人和生活，一旦对物欲得渴望超过了两人之间的能力匹配关系，那必然会导致婚姻的失衡，甚至走向破灭。</li></ul></li><li>“让你看到海底星空，但却将你置于黑暗的牢笼。”人性的恶如果被激活、放大了，那就无所谓对与错了，因为恶本身就是二者权衡的产物，只要有了开端和征兆，就会被无限放大直至坠落。<ul><li>就如影片中的何非好赌，从他开始押下赌注的时候，内心的恶被激活，他所做的一切是为了自己服务，在他眼中是正确的、合理的，可是在外人眼中确实错误的、疯狂的，以至于最后那婚姻作为最大的赌注。</li></ul></li><li>最后说一些恋爱相关的话题，虽然我是牡丹，但是目前和未来希望可以获得一段健康、积极的恋爱关系，双方不是彼此的附属品，更不是因为物质匹配来的恋爱。<ul><li>影片中的‘李木子’，说实话有些恋爱脑，也就是在爱情、婚姻中始终扮演着弱势的一方，渴望得到陪伴与爱，但是前提是需要对方的同意，把个人的想法寄托在他人身上，是不明智的。</li><li>我觉得，一段积极健康的恋爱关系，双方应该是彼此的肩膀，而非靠山，也就是生活里需要你的安慰和鼓励，并不是直接的索取和丢弃，我可以成为你的“消息中转站”，为你暂时排忧解难、分享与分担，等到心情变好的时候再将“消息”归还，由你自己处理；而不是你的“垃圾桶”，将所有不好归咎到对方，将负面消息发送给对方就置之不理。</li><li>希望在未来可以遇到合适的人吧。虽然看完电影后劲有点大，但是对于爱情，依然保持憧憬和向往~~</li></ul></li></ol><p><span style="color:lightblue;font-size:2em;">End~</span></p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 55：跳跃游戏</title>
      <link href="/2023/07/08/leetcode-55-tiao-yue-you-xi/"/>
      <url>/2023/07/08/leetcode-55-tiao-yue-you-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-55%EF%BC%9A%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89" tabindex="-1">Leetcode 55：跳跃游戏（贪心）</h3><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><ul><li><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。 <strong>判断你是否能够到达最后一个下标</strong></p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><hr><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><ul><li><strong>分析：</strong></li><li><ul><li>本题的关键是对于每一步的把控，例如当处于<code>nums[0]</code>时，此时的值为<code>2</code>，也就是可以跳跃一步或者两步，这样下去对应数组中的每个数字都可以由不同的<code>跳跃方法</code>。</li><li><strong>但是我们要注意：每个位置跳多少步不是关键，而是最后的跳跃范围是否可以覆盖到最后一个数（也就是终点）</strong> 那么我们可以尝试每次移动取最大的跳跃步数（目的是得到最大的范围），依次更新覆盖的范围。</li><li><strong>本题的贪心算法的关键是：<mark>局部最优解</mark>，每次取最大的跳跃步数（取最大的覆盖范围）；<mark>整体最优解：</mark> 最后得到整体的最大覆盖范围，看看能否到达最后一个数（终点）</strong></li></ul></li></ul><hr><ul><li><p><strong>代码：</strong></p></li><li><pre class="line-numbers language-language-Java"><code class="language-language-Java">class Solution{    public boolean canJump(int[] nums){        if(nums.length==1){            return true;//特例：第一个数字自己就是终点        }        //开始覆盖范围        int cover=nums[0];//初始值        //在第一个数的覆盖范围内继续不断地更新最大覆盖范围        for(int i=0;i<=cover;i++){        //这里之所以可以取等，因为我们要求的相当于是每个位置的数值，那当然可以取等，如nums[0]==3,那么我们可以跳跃三次到nums[3],再更新最大范围;    cover=Math.max(cover,i+nums[i]);//当前的编号，加上可跳跃的数值，即为范围        if(cover>=nums.length-1){//覆盖范围可以到达最后一个数字的下标（终点）            return true;        }          }        return false;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h3 id="3.-%E6%80%BB%E7%BB%93" tabindex="-1">3. 总结</h3><ul><li><p>**时间复杂度考虑最坏的情况，如果全部元素都是1，那么循环需要n-1次，时间复杂度为：O(n); **</p></li><li><p><strong>空间复杂度：由于只引入了若干变量，未占用内存存储空间：O(1)</strong></p></li></ul><blockquote><p><span style="color:red;font-weight:3em;font-size:2em">继续努力</span></p></blockquote><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双周赛100 T1：把钱分给最多的儿童</title>
      <link href="/2023/07/07/shuang-zhou-sai-100-t1-ba-qian-fen-gei-zui-duo-de-er-tong/"/>
      <url>/2023/07/07/shuang-zhou-sai-100-t1-ba-qian-fen-gei-zui-duo-de-er-tong/</url>
      
        <content type="html"><![CDATA[<h3 id="%E5%8F%8C%E5%91%A8%E8%B5%9B100t1%EF%BC%9A%E5%B0%86%E9%92%B1%E5%88%86%E7%BB%99%E6%9C%80%E5%A4%9A%E7%9A%84%E5%84%BF%E7%AB%A5" tabindex="-1">双周赛100T1：将钱分给最多的儿童</h3><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><p>​给你一个整数 <code>money</code> ，表示你总共有的钱数（单位为美元）和另一个整数 <code>children</code> ，表示你要将钱分配给多少个儿童。</p><p>​你需要按照如下规则分配：</p><ul><li><p>所有的钱都必须被分配。</p></li><li><p>每个儿童至少获得 <code>1</code> 美元。</p></li><li><p>没有人获得 <code>4</code> 美元。</p><p>请你按照上述规则分配金钱，并返回 <strong>最多</strong> 有多少个儿童获得 <strong>恰好</strong> <code>8</code> 美元。如果没有任何分配方案，返回 <code>-1</code>.</p></li></ul><hr><ul><li><p><strong>示例</strong>：</p></li><li><pre><code>输入：money = 20, children = 3输出：1解释：最多获得 8 美元的儿童数为 1 。一种分配方案为：- 给第一个儿童分配 8 美元。- 给第二个儿童分配 9 美元。- 给第三个儿童分配 3 美元。没有分配方案能让获得 8 美元的儿童数超过 1 。</code></pre></li></ul><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><ul><li><strong>分析：</strong></li><li><ul><li>最开始一以为这类题目都是直接模拟来做，但是发现限定条件有点多，主要是不好分类。这里<code>条件2:每个儿童至少获得1美元</code>，这里需要保证的是儿童分到的钱不为<code>0</code>，至少为<code>1</code>。<mark>换句话说就是先给每个儿童分配1美元</mark>  //对应的是：money-children。此时如果money&lt;0，那么直接返回-1。</li><li>然后<code>目的：返回获得8美元的儿童的最大数量</code>，此时条件改为每个获得<code>7</code>美元的儿童最大个数，我们将此时的money / 7 ，让尽可能多的儿童分到<code>7</code>美元，并向下取整，并且需要同当前的儿童的个数进行对比，不能够超过儿童实际人数，返回的是<code>ans=Math.min(money/7,children);</code>并且此时的<code>money-=ans*7;//最后的钱数</code>,<code>children-=ans;//剩余的未分配的儿童人数</code>。</li><li>此时开始判定<code>条件1和条件3：每个人都必须分配，没有儿童分到了4美元</code>。<ul><li><ol><li>如果此时剩余<code>0</code>人，也就是全部儿童都分完了（钱数都是<code>8</code>）,如果money&gt;0,说明还需要再分给一个儿童，也就是<code>ans-1</code>,有一个儿童不是8。</li></ol></li><li><ol start="2"><li>如果此时剩余1人（此时此人的钱数是<code>1</code>），且<code>money=3</code>,为了避免分配<code>4</code>美元，需要的是将此时的<code>3</code>分配给一个分到<code>8</code>的儿童，此时<code>ans-1</code>;</li></ol></li><li><ol start="3"><li>其余情况全部给一个人，如果这个人分配到<code>4</code>美元，那么它可以继续分给其他人，<code>ans</code>的总数保持不变。(<strong>也就是剩余money的值无非是mod7的正整数剩余系，4，5；6就进一位了，人数向下取整的时候要+1;对应的人数也是如此，剩余2、3…人数越多越可以分配剩余钱数不到4美元</strong>)。</li></ol></li></ul></li></ul></li></ul><hr><h3 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3. 具体代码</h3><ul><li><p><strong>代码</strong>：</p></li><li><pre class="line-numbers language-language-Java"><code class="language-language-Java">class Solution{    public int distMoney(int money,int children){        money-=chilrdren;//最开始的每个人初始值要为1        if(money<0) return -1;//不满足每个儿童获得钱数至少为1的条件，返回-1、        int ans=Math.min(money/7,children);        money-=ans*7;        children-=ans;        if(children==0 && money>0          ||children==1 && money==3){            ans--;        }        return ans;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>总结：</strong> <strong>时间复杂度为O(1),未用到循环遍历</strong>；<strong>空间复杂度为：O(1)，仅使用了若干额外的变量。</strong></p></li></ul><hr><p><span style="color:lightblue;font-size:30px;">END~</span></p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/07/07/shuang-zhou-sai-100-t1-ba-qian-fen-gei-zui-duo-de-er-tong/2.jpg" alt="2" style="zoom:80%;"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Offer26：重排链表</title>
      <link href="/2023/07/07/offer26-chong-pai-lian-biao/"/>
      <url>/2023/07/07/offer26-chong-pai-lian-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="offer26%EF%BC%9A%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8" tabindex="-1">Offer26：重排链表</h3><hr><h3 id="1.-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" tabindex="-1">1. 题目描述</h3><ul><li><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><p><code>L0 → L1 → … → Ln-1 → Ln</code><br>请将其重新排列后变为：</p><pre class="line-numbers language-none"><code class="language-none">L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例 1:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入: head = [1,2,3,4]输出: [1,4,2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr></li></ul><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><ul><li><p><strong>分析：</strong> 这题不难发现，最后需要输出的链表其实是<code>前半部分</code>和<code>后半部分的翻转</code>,接着再头连着头，依次进行排序输出。</p><ul><li>所以最原始的方法是需要3个不同的函数功能。<ol><li><code>reorderList()</code>函数：主函数，用于均分两半链表，并将它们进行操作。</li><li>``reverse()`函数：翻转后半部分的链表。</li><li><code>link()</code>函数：用于连接前半部分链表、后半部分链表。</li></ol></li></ul><hr></li><li><p><strong>代码：</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution{    public void recorderList(ListNode head){        ListNode dummy=new ListNode(0);        dummy.next=head;//哨兵        ListNode fast=dummy;//快指针        ListNode slow=dummy;//慢指针       while(fast!=null &amp;&amp; fast.next!=null){           slow=slow.next;           fast=fast.next.next;       }                ListNode temp=slow.next;//中间节点的指针暂定为temp        slow.next=null;//准备连接，slow.next为空了        link(head,reverse(temp),dummy);//开始连接    }    private ListNode reverse(ListNode head){//反转链表，注意指针的指向位置        ListNode prev=null;        ListNode cur=head;        while(cur!=null){            ListNode next=cur.next;            cur.next=prev;            prev=cur;            cur=next;        }        return prev;    }    private void link(ListNode node1,ListNode node2,ListNode head){//借助原链表的头结点head（在本题函数中指的是哨兵节点dummy）,按照题目要求连接前后两部分，新链表的头节点为prev        ListNode prev=head;        while(node1!=null &amp;&amp; node2!=null){            ListNode temp=node1.next;//当前node1节点的下一个位置为temp                       prev.next=node1;//prev指针指向node1部分第一个节点            node1.next=node2;//node1后面连的是反转后node2的第一个            prev=node2;//prev开始下一次连接                        node1=temp;//node1后移            node2=node2.next;//node2后移        }        if(node1!=null){            prev.next=node1;//这一个if是用来判断前半部分链表必须比后半部分多，当node1无法匹配连接node2时，直接连接返回node1的节点值。        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr></li></ul><h3 id="3.-%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93" tabindex="-1">3. 思考总结</h3><ul><li><p><strong>思考：</strong> 其实代码不用写三个函数，用在一个函数内部即可，不需要来回调用，实现<code>折半翻转再重连</code>即可。代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution {    public void reorderList(ListNode head) {        ListNode f = head, s = head;        while (f.next != null &amp;&amp; f.next.next != null) {            s = s.next;//慢指针找到中间的节点            f = f.next.next;//快指针直接到末尾节点        }        ListNode t = s.next;//暂存的t节点是慢指针的下一位        f=null;//快指针此时位于最后一个节点，赋值为空        while (t != null) {//翻转            t = s.next;            s.next = f;            f = s;            s = t;        }        s = head;//这里是将后半部分翻转。此时快指针指向原链表的最后一位元素        while (s != null) {//再重新进行连接            t = s.next;//保留当前位置的下一位            s.next = f;//后半部分的最后一位            s = f;            f = t;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>END</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/07/07/offer26-chong-pai-lian-biao/1.jpg" alt="1"></p></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指Offer（专项） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 1.两数之和</title>
      <link href="/2023/07/07/leetcode-1-liang-shu-zhi-he/"/>
      <url>/2023/07/07/leetcode-1-liang-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C" tabindex="-1">Leetcode 1.两数之和</h3><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><ul><li><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><hr><p>###2. 解答分析</p><ul><li><p>本题有好多种解法，这里选择两种常见的解法，一种是直接上循环，不断遍历数组；另外一种是利用哈希表，返回对应表的下标（利用<code>key</code> 和<code>value</code>）</p><ul><li><h5 id="%E6%96%B9%E6%B3%951%EF%BC%9A%E5%88%A9%E7%94%A8%E9%81%8D%E5%8E%86%E6%A8%A1%E6%8B%9F" tabindex="-1"><strong>方法1：利用遍历模拟</strong></h5><ul><li>本题要求的是返回两个数字和为<code>target</code>的数组元素的下标，这里可以直接交换遍历，比如最简单的for循环，我们会把两个指针所指向的值之和，依次比较，最后返回数组元素的下标（构建新的数组）</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution{    public int[] twoSum(int []nums,int target){        int j=1;        int i=0;        int maxLen=nums.length-1;        while(nums[i]+nums[j]!=target){            if(j==maxLen)}{            i++;            j=i;        }        j++:        }    return new int[]{i,j};    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>时间复杂度：O(n<sup>2</sup>)</strong>,一个是i，另外一个是j的循环遍历，至少需要**n(n-1)**的步骤；<strong>空间复杂度为O(1)</strong></li></ul><hr></li><li><h5 id="%E6%96%B9%E6%B3%952%EF%BC%9Ahash%E8%A1%A8" tabindex="-1"><strong>方法2：Hash表</strong></h5><ul><li>Hash表是一种数据结构关系，利用==键(key)<mark>和</mark>值(value)==的<code>一一对应</code>的关系，生成map。map目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）</li><li>在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素</li><li>本题的map我们这样定义：<code>key</code>为数组中的num[i]值，对应的<code>value</code>为 ：下标元素i；</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution{    public int[] twoSum(int[] nums,int target){        int[]res=new int[2];//首先生成最后需要返回的数组，保存的是数组的元素下标        if(nums==null || nums.length==0){            return res;//考虑特例        }        Map&lt;Integer,Integer&gt;map=new HashMap&lt;&gt;();//建立HashMap        for(int i=0;i&lt;nums.length;i++){            int temp=target-nums[i];//从第i个元素开始，看看当前的元素数组中是否存在可以满足条件的值            if(map.containsKey(temp)){                res[1]=i;                res[0]=map.get(temp);//这里的get返回的是满足条件的temp数组元素的下标，注意我们定义Value是数组元素的下标，对应的Key是数组元素的值                break;//跳出循环            }            map.put(nums[i],i);//如果没有找到匹配的对，对于大的循环而言，只需要在HashMap中添加对应的nums值和下标即可，为后续的元素查找匹配提供map数据资源。        }        return res;//返回需要的元素数组下标的新数组    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>时间复杂度：O(n)</strong>，利用HashMap的数据结构大大提高了查找的效率，就相当于是额外开辟内存空间进行数组元素的值、下标的匹配关系映射，通过牺牲空间复杂度换取时间、效率的提高，<strong>空间复杂度为：O(n),（相当于为每个元素都开辟了n-1的空间）。</strong></li></ul></li></ul></li></ul><hr><h3 id="3.%E6%80%BB%E7%BB%93" tabindex="-1">3.总结</h3><p>​这道题很经典，其实还有很多其他的解法，这里由于篇幅就不一一介绍了。对于不同的数据结构和算法而言，我们实现的目标、途径都是不同，同样，时间和空间的各自复杂度的考虑也存在差异，多加练习，多多增加对于每道题目的不同思考方式，继续加油！</p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>First_In</title>
      <link href="/2023/07/05/first-in/"/>
      <url>/2023/07/05/first-in/</url>
      
        <content type="html"><![CDATA[<h3 id="test" tabindex="-1">Test</h3><ol><li>第一篇博客简单测试实现的功能，后续会继续优化网页的显示</li><li>得抓紧时间学习新知识，争取找点找到实习工作</li><li>一切都拼尽全力，一切都顺其自然，让自己快乐快乐这才叫做意义</li></ol><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/05/hello-world/"/>
      <url>/2023/07/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start" tabindex="-1">Quick Start</h2><h3 id="create-a-new-post" tabindex="-1">Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server" tabindex="-1">Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files" tabindex="-1">Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites" tabindex="-1">Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
