<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Offer26：重排链表</title>
      <link href="/2023/07/07/offer26-chong-pai-lian-biao/"/>
      <url>/2023/07/07/offer26-chong-pai-lian-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="Offer26：重排链表"><a href="#Offer26：重排链表" class="headerlink" title="Offer26：重排链表"></a>Offer26：重排链表</h3><hr><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h3><ul><li><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><p><code>L0 → L1 → … → Ln-1 → Ln</code><br>请将其重新排列后变为：</p><pre class="line-numbers language-none"><code class="language-none">L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例 1:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入: head = [1,2,3,4]输出: [1,4,2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr></li></ul><h3 id="2-解答分析"><a href="#2-解答分析" class="headerlink" title="2. 解答分析"></a>2. 解答分析</h3><ul><li><p><strong>分析：</strong> 这题不难发现，最后需要输出的链表其实是<code>前半部分</code>和<code>后半部分的翻转</code>,接着再头连着头，依次进行排序输出。</p><ul><li>所以最原始的方法是需要3个不同的函数功能。<ol><li><code>reorderList()</code>函数：主函数，用于均分两半链表，并将它们进行操作。</li><li>``reverse()`函数：翻转后半部分的链表。</li><li><code>link()</code>函数：用于连接前半部分链表、后半部分链表。</li></ol></li></ul><hr></li><li><p><strong>代码：</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution{    public void recorderList(ListNode head){        ListNode dummy=new ListNode(0);        dummy.next=head;//哨兵        ListNode fast=dummy;//快指针        ListNode slow=dummy;//慢指针       while(fast!=null &amp;&amp; fast.next!=null){           slow=slow.next;           fast=fast.next.next;       }                ListNode temp=slow.next;//中间节点的指针暂定为temp        slow.next=null;//准备连接，slow.next为空了        link(head,reverse(temp),dummy);//开始连接    }    private ListNode reverse(ListNode head){//反转链表，注意指针的指向位置        ListNode prev=null;        ListNode cur=head;        while(cur!=null){            ListNode next=cur.next;            cur.next=prev;            prev=cur;            cur=next;        }        return prev;    }    private void link(ListNode node1,ListNode node2,ListNode head){//借助原链表的头结点head（在本题函数中指的是哨兵节点dummy）,按照题目要求连接前后两部分，新链表的头节点为prev        ListNode prev=head;        while(node1!=null &amp;&amp; node2!=null){            ListNode temp=node1.next;//当前node1节点的下一个位置为temp                       prev.next=node1;//prev指针指向node1部分第一个节点            node1.next=node2;//node1后面连的是反转后node2的第一个            prev=node2;//prev开始下一次连接                        node1=temp;//node1后移            node2=node2.next;//node2后移        }        if(node1!=null){            prev.next=node1;//这一个if是用来判断前半部分链表必须比后半部分多，当node1无法匹配连接node2时，直接连接返回node1的节点值。        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr></li></ul><h3 id="3-思考总结"><a href="#3-思考总结" class="headerlink" title="3. 思考总结"></a>3. 思考总结</h3><ul><li><p><strong>思考：</strong> 其实代码不用写三个函数，用在一个函数内部即可，不需要来回调用，实现<code>折半翻转再重连</code>即可。代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution {    public void reorderList(ListNode head) {        ListNode f = head, s = head;        while (f.next != null &amp;&amp; f.next.next != null) {            s = s.next;//慢指针找到中间的节点            f = f.next.next;//快指针直接到末尾节点        }        ListNode t = s.next;//暂存的t节点是慢指针的下一位        f=null;//快指针此时位于最后一个节点，赋值为空        while (t != null) {//翻转            t = s.next;            s.next = f;            f = s;            s = t;        }        s = head;//这里是将后半部分翻转。此时快指针指向原链表的最后一位元素        while (s != null) {//再重新进行连接            t = s.next;//保留当前位置的下一位            s.next = f;//后半部分的最后一位            s = f;            f = t;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>END</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/07/07/offer26-chong-pai-lian-biao/1.jpg" alt="1"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指Offer（专项） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 1.两数之和</title>
      <link href="/2023/07/07/leetcode-1-liang-shu-zhi-he/"/>
      <url>/2023/07/07/leetcode-1-liang-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<h3 id="Leetcode-1-两数之和"><a href="#Leetcode-1-两数之和" class="headerlink" title="Leetcode 1.两数之和"></a>Leetcode 1.两数之和</h3><h3 id="1-题目说明"><a href="#1-题目说明" class="headerlink" title="1. 题目说明"></a>1. 题目说明</h3><ul><li><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><hr><h3 id="2-解答分析"><a href="#2-解答分析" class="headerlink" title="2. 解答分析"></a>2. 解答分析</h3><ul><li><p>本题有好多种解法，这里选择两种常见的解法，一种是直接上循环，不断遍历数组；另外一种是利用哈希表，返回对应表的下标（利用<code>key</code> 和<code>value</code>）</p><ul><li><h5 id="方法1：利用遍历模拟"><a href="#方法1：利用遍历模拟" class="headerlink" title="方法1：利用遍历模拟"></a><strong>方法1：利用遍历模拟</strong></h5><ul><li>本题要求的是返回两个数字和为<code>target</code>的数组元素的下标，这里可以直接交换遍历，比如最简单的for循环，我们会把两个指针所指向的值之和，依次比较，最后返回数组元素的下标（构建新的数组）</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution{    public int[] twoSum(int []nums,int target){        int j=1;        int i=0;        int maxLen=nums.length-1;        while(nums[i]+nums[j]!=target){            if(j==maxLen)}{            i++;            j=i;        }        j++:        }    return new int[]{i,j};    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>时间复杂度：O(n^2^)</strong>,一个是i，另外一个是j的循环遍历，至少需要<strong>n(n-1)<strong>的步骤；</strong>空间复杂度为O(1)</strong></li></ul><hr></li><li><h5 id="方法2：Hash表"><a href="#方法2：Hash表" class="headerlink" title="方法2：Hash表"></a><strong>方法2：Hash表</strong></h5><ul><li>Hash表是一种数据结构关系，利用==键(key)==和==值(value)==的<code>一一对应</code>的关系，生成map。map目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）</li><li>在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素</li><li>本题的map我们这样定义：<code>key</code>为数组中的num[i]值，对应的<code>value</code>为 ：下标元素i；</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution{    public int[] twoSum(int[] nums,int target){        int[]res=new int[2];//首先生成最后需要返回的数组，保存的是数组的元素下标        if(nums==null || nums.length==0){            return res;//考虑特例        }        Map&lt;Integer,Integer&gt;map=new HashMap&lt;&gt;();//建立HashMap        for(int i=0;i&lt;nums.length;i++){            int temp=target-nums[i];//从第i个元素开始，看看当前的元素数组中是否存在可以满足条件的值            if(map.containsKey(temp)){                res[1]=i;                res[0]=map.get(temp);//这里的get返回的是满足条件的temp数组元素的下标，注意我们定义Value是数组元素的下标，对应的Key是数组元素的值                break;//跳出循环            }            map.put(nums[i],i);//如果没有找到匹配的对，对于大的循环而言，只需要在HashMap中添加对应的nums值和下标即可，为后续的元素查找匹配提供map数据资源。        }        return res;//返回需要的元素数组下标的新数组    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>时间复杂度：O(n)<strong>，利用HashMap的数据结构大大提高了查找的效率，就相当于是额外开辟内存空间进行数组元素的值、下标的匹配关系映射，通过牺牲空间复杂度换取时间、效率的提高，</strong>空间复杂度为：O(n),（相当于为每个元素都开辟了n-1的空间）。</strong></li></ul></li></ul></li></ul><hr><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>​这道题很经典，其实还有很多其他的解法，这里由于篇幅就不一一介绍了。对于不同的数据结构和算法而言，我们实现的目标、途径都是不同，同样，时间和空间的各自复杂度的考虑也存在差异，多加练习，多多增加对于每道题目的不同思考方式，继续加油！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode刷题 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>First_In</title>
      <link href="/2023/07/05/first-in/"/>
      <url>/2023/07/05/first-in/</url>
      
        <content type="html"><![CDATA[<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><ol><li>第一篇博客简单测试实现的功能，后续会继续优化网页的显示</li><li>得抓紧时间学习新知识，争取找点找到实习工作</li><li>一切都拼尽全力，一切都顺其自然，让自己快乐快乐这才叫做意义</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/05/hello-world/"/>
      <url>/2023/07/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
