<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode 560:和为k的子数组</title>
      <link href="/2023/08/25/leetcode-560-he-wei-k-de-zi-shu-zu/"/>
      <url>/2023/08/25/leetcode-560-he-wei-k-de-zi-shu-zu/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-560%EF%BC%9A%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84" tabindex="-1">Leetcode-560：和为k的子数组</h3><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><ul><li><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 <strong>k</strong> 的<strong>连续的子数组</strong>的个数。</p><blockquote><p>示例 1 :</p><p>输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</p></blockquote></li></ul><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90%EF%BC%88%E5%90%AB%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%89" tabindex="-1">2. 解答分析（含复杂度）</h3><ul><li><p>题目本质上是可以利用暴力解决的，也就是用双重循环进行和为<code>k</code>的子数组的个数统计即可，但是这里我们想利用更多的方法，主要分为3部分：</p><ol><li><p><strong>暴力</strong></p></li><li><p><strong>前缀和</strong></p></li><li><p><strong>前缀和+HashMap</strong></p></li></ol><hr></li><li><h3 id="%E2%91%A0-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95" tabindex="-1"><strong>① 暴力解法</strong></h3><ul><li>直接上代码：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int subarraySum(int[] nums, int k) {         int len = nums.length;         int sum = 0;         int count = 0;         //双重循环         for (int i = 0; i &lt; len; ++i) {             for (int j = i; j &lt; len; ++j) {                 sum += nums[j];                 //发现符合条件的区间                 if (sum == k) {                     count++;                 }             }             //记得归零，重新遍历             sum = 0;         }         return count;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>复杂度分析</strong>：<ul><li>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>，这里 $N $是数组的长度；</li><li>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq>。</li></ul></li></ul><hr></li><li><h3 id="%E2%91%A1-%E5%89%8D%E7%BC%80%E5%92%8C" tabindex="-1">② 前缀和</h3><ul><li>前缀和<code>pre[i]</code>的关键是找到前一个和后一个的关系，这里的连续子数组的元素之和恰好满足前缀求和的关系，所以可以采取。</li><li>需要注意的是：<ol><li>注意偏移，因为我们的<code>nums[2]</code>到<code>nums[4]</code>等于<code>pre[5]-pre[2]</code>，所以这样就可以得到<code>nums[i,j]</code>区间内的和</li><li>前缀和是从<code>pre[1]</code>开始填充的</li></ol></li><li>上代码：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int subarraySum(int[] nums, int k) {        //前缀和数组        int[] presum = new int[nums.length+1];        for (int i = 0; i &lt; nums.length; i++) {            pre[i+1] = nums[i] + pre[i];        }        //统计个数        int count = 0;        for (int i = 0; i &lt; nums.length; ++i) {            for (int j = i; j &lt; nums.length; ++j) {                              if (pre[j+1] - pre[i] == k) {                    count++;                }            }        }        return count;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>复杂度分析</strong>：</p><ul><li><p>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></eq>，这里 N 是数组的长度；</p></li><li><p>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>。</p></li></ul></li></ul><hr></li><li><h3 id="%E2%91%A2-%E5%89%8D%E7%BC%80%E5%92%8C-%2B-hashmap" tabindex="-1">③ 前缀和 + HashMap</h3><ul><li><p>分析上述的前缀和方法不难看出：该代码虽然用到了前缀和数组，但是对比暴力法并没有提升性能，时间复杂度仍为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>，空间复杂度成了 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>。</p></li><li><p>在两数之和的题目中，我们可以看出利用<code>HashMap</code>进行的遍历求解，只用遍历循环数组一次即可，这里我们同样采用的做法是，我们将数组的值和索引存入<code>map</code>中，当我们遍历到某一值 <code>x </code>时，判断 <code>map </code>中是否含有<code> target - x</code>即可。</p></li><li><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int[] twoSum(int[] nums, int target) {        HashMap&lt;Integer,Integer&gt; map  = new HashMap&lt;&gt;();        //一次遍历        for (int i = 0; i &lt; nums.length; ++i) {            //存在时，我们用数组得值为 key，索引为 value            if (map.containsKey(target - nums[i])){                             return new int[]{i,map.get(target-nums[i])};            }            //存入值            map.put(nums[i],i);        }        //返回        return new int[]{};    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><blockquote><p>我们完全可以通过 presum - k的个数获得 k 的个数,如图所示:</p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/08/25/leetcode-560-he-wei-k-de-zi-shu-zu/presum-k.png" alt="presum-k" style="zoom:67%;"></blockquote></li><li><p>本题的代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int subarraySum(int[] nums, int k) {        if (nums.length == 0) {            return 0;        }        HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();        //细节，这里需要预存前缀和为 0 的情况，会漏掉前几位就满足的情况        //例如输入[1,1,0]，k = 2 如果没有这行代码，则会返回0,漏掉了1+1=2，和1+1+0=2的情况        //输入：[3,1,1,0] k = 2时则不会漏掉        //因为presum[3] - presum[0]表示前面 3 位的和，所以需要map.put(0,1),垫下底        map.put(0, 1);        int count = 0;        int presum = 0;        for (int x : nums) {            presum += x;            //当前前缀和已知，判断是否含有 presum - k的前缀和，那么我们就知道某一区间的和为 k 了。            if (map.containsKey(presum - k)) {                count += map.get(presum - k);//获取次数            }            //更新            map.put(presum,map.getOrDefault(presum,0) + 1);        }        return count;    }}//或者是：class Solution {    public int subarraySum(int[] nums, int k) {        /*        前缀和+HashMap(两数之和进阶版)        若存在i与j满足sum[i,j]=sum[j+1]-sum[i]=k，对于j+1，满足条件的i的个数可以先统计出来        前面符合条件的数据为:sum[i]=sum[j+1]-k，这里注意是i&lt;=j，因此需要先统计了前面的再更新当前的        与两数之和是差不多的思路，不过这个多了个前缀和        时间复杂度:O(N) 空间复杂度:O(N)         */        int res = 0;        // 前缀和还可以进一步空间优化        int sum = 0;        // 哈希表存储前缀和数组中缺少了某个数的个数        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        map.put(0, 1);  // 初始前缀和        for (int num : nums) {            sum += num;            // 先统计            res += map.getOrDefault(sum - k, 0);            // 再更新当前的            map.put(sum, map.getOrDefault(sum, 0) + 1);        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>复杂度分析</strong>：</p><ul><li><p>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>，这里 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></eq>是数组的长度；</p></li><li><p>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>。</p></li></ul></li></ul><hr><h3 id="3.-%E5%B1%95%E6%9C%9B%EF%BC%88%E4%B8%8E%E9%A2%98%E7%9B%AE%E6%97%A0%E5%85%B3%EF%BC%89" tabindex="-1">3. 展望（与题目无关）</h3><blockquote><p>开学了，还是会继续学习算法，刷力扣，博客也会经常更新自己的学习动态，加油哇！🤗👍大三希望有机会找到一份实习，前后端都行，美化简历😊</p></blockquote><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/08/25/leetcode-560-he-wei-k-de-zi-shu-zu/Bupt.jpg" alt="Bupt" style="zoom:20%;"><center><span style="font-size:30px;color:red;font-weight:bolder;">END~</span><center></center></center></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PriorityQueue实现最小堆和最大堆的用法[JAVA]</title>
      <link href="/2023/07/27/priorityqueue-shi-xian-zui-xiao-dui-he-zui-da-dui-de-yong-fa-java/"/>
      <url>/2023/07/27/priorityqueue-shi-xian-zui-xiao-dui-he-zui-da-dui-de-yong-fa-java/</url>
      
        <content type="html"><![CDATA[<h3 id="%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D" tabindex="-1">一、基本介绍</h3><ol><li><p><strong>介绍</strong></p><p>PriorityQueue翻译为优先队列，“优先”指元素在队列中按一定的顺序（优先级）进行存放，“队列”指一种先进先出的数据结构。因此PriorityQueue可以实现按照一定的优先级存取元素。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/07/27/priorityqueue-shi-xian-zui-xiao-dui-he-zui-da-dui-de-yong-fa-java/%E7%AE%80%E4%BB%8B.png" alt="简介"></p></li><li><p><strong>用法</strong></p></li></ol>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">//默认容量为 11  private static final int DEFAULT_INITIAL_CAPACITY = 11;  //1、无参构造，默认容量和默认排序方法  public PriorityQueue() {          this(DEFAULT_INITIAL_CAPACITY, null);      }  //2、指定容量  public PriorityQueue(int initialCapacity) {          this(initialCapacity, null);      }  //3、指定排序方法  public PriorityQueue(Comparator&lt;? super E&gt; comparator) {          this(DEFAULT_INITIAL_CAPACITY, comparator);      }  //4、指定容量和排序方法  public PriorityQueue(int initialCapacity,                           Comparator&lt;? super E&gt; comparator) {          // Note: This restriction of at least one is not actually needed,          // but continues for 1.5 compatibility          if (initialCapacity &lt; 1)              throw new IllegalArgumentException();          this.queue = new Object[initialCapacity];          this.comparator = comparator;      }  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在构造PriorityQueue时候我们可以指定初始容量和元素在队列中的排序方法，如果不指定，则默认初始容量为11，默认的排序方式是将元素从小到大进行排序。</p></blockquote><ol start="3"><li><strong>最小堆</strong></li></ol><p>构造最小堆:</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">PriorityQueue&lt;Integer&gt; minheap = new PriorityQueue&lt;&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用无参构造，元素在队列中按照默认从小到大的顺序排列，可以保证每次出队列的元素都是队列中的最小的元素。</li></ul><ol start="4"><li><p><strong>最大堆</strong></p><p>构造最大堆：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">PriorityQueue&lt;Integer&gt; maxheap = new PriorityQueue&lt;&gt;(Collections.reverseOrder());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>将排序方法指定为反序，元素是从大到小的顺序排列，也就是保证每次出队列的元素是队列中的最大的元素。</li></ul></li></ol><h3 id="%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95" tabindex="-1">二、常用的方法</h3><ul><li><p>以<code>Integer</code>的类型为例：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/07/27/priorityqueue-shi-xian-zui-xiao-dui-he-zui-da-dui-de-yong-fa-java/%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95.png" alt="常见用法"></p></li></ul><p>​</p><hr><h3 id="%E4%B8%89%E3%80%81%E4%B8%BE%E4%BE%8B" tabindex="-1">三、举例</h3><blockquote><p>Leetcode 2208. 将数组和减半的最少操作次数</p></blockquote><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><p>给你一个正整数数组 <code>nums</code> 。每一次操作中，你可以从 <code>nums</code> 中选择 <strong>任意</strong> 一个数并将它减小到 <strong>恰好</strong> 一半。（注意，在后续操作中你可以对减半过的数继续执行操作）</p><p>请你返回将 <code>nums</code> 数组和 <strong>至少</strong> 减少一半的 <strong>最少</strong> 操作数。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [5,19,8,1]输出：3解释：初始 nums 的和为 5 + 19 + 8 + 1 = 33 。以下是将数组和减少至少一半的一种方法：选择数字 19 并减小为 9.5 。选择数字 9.5 并减小为 4.75 。选择数字 8 并减小为 4 。最终数组为 [5, 4.75, 4, 1] ，和为 5 + 4.75 + 4 + 1 = 14.75 。nums 的和减小了 33 - 14.75 = 18.25 ，减小的部分超过了初始数组和的一半，18.25 &gt;= 33/2 = 16.5 。我们需要 3 个操作实现题目要求，所以返回 3 。可以证明，无法通过少于 3 个操作使数组和减少至少一半。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="2.-%E5%88%86%E6%9E%90%E8%A7%A3%E7%AD%94" tabindex="-1">2. 分析解答</h3><ul><li>常见的题目，由于每一次操作都会使得数组中的一个数字减半。要想使得总的数组中的减少的次数最少，<strong>其实就是从当前的数组中选取最大值进行减半的操作</strong></li><li>这里可以利用大根堆（优先队列）维护数组中的所有数，每次都是从优先队列中取出最大值 ttt，将其减半，然后将减半后的数重新放入优先队列中，同时更新 <code>s</code>，直到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">s≤0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></eq>为止。那么此时的操作次数就是答案。</li><li>用到的算法知识点是：贪心算法（每次选取队列中的最大值）+优先队列（大根堆，每次都更新排列）</li></ul><hr><h3 id="3.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" tabindex="-1">3.代码实现</h3><ul><li>Java代码（利用上述的<code>PriorityQueue</code>队列知识）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int halveArray(int[] nums) {        double s=0;        PriorityQueue&lt;Double&gt; q = new PriorityQueue&lt;&gt;(Collections.reverseOrder());        //上述的是最大堆，确保每次都是队列中最大的数出来,元素从大到小排列        for(int i:nums){            q.offer(i*1.0);//注意除半时候出现的浮点数值，先进行转换，添加队列中去            s+=i;//s为根堆（优先队列）元素之和        }        s/=2.0;//取半        int ans=0;        while(s&gt;0){//循环，直到s&lt;=0为止            double t =q.poll();//队头元素出列（当前的最大值）            s-=t/2.0;  //元素值减半，从s值中减去            q.offer(t/2.0);  //更新队列中的元素，找到最大值            ++ans;        }        return ans;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>时间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n * log_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>​</strong>。</p></li><li><p><strong>空间复杂度：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>​</strong>，其中的n指的是数组的长度。</p></li></ul><hr><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消失的她</title>
      <link href="/2023/07/10/xiao-shi-de-ta/"/>
      <url>/2023/07/10/xiao-shi-de-ta/</url>
      
        <content type="html"><![CDATA[<h3 id="%E6%B6%88%E5%A4%B1%E7%9A%84%E5%A5%B9%E5%BD%B1%E8%AF%84" tabindex="-1">消失的她影评</h3><blockquote><p>当利益过于庞大的时候，人性的阴暗面就会展露出来</p></blockquote><p>7月9号和哥们去看了《消失的她》，虽然之前在营销号内已经看过大致的剧情走向，但是真正到电影院里看完全片后，又有了不同的感觉。倒不是对爱情观又有什么执念了😂（毕竟牡丹20年），这里重点讨论人性和选择。</p><hr><h3 id="1.-%E6%95%85%E4%BA%8B%E6%A6%82%E8%BF%B0" tabindex="-1">1. 故事概述</h3><ul><li><p>《消失的她》讲述了这样一个故事：东南亚某地，何非（朱一龙 饰）的老婆李木子，突然失踪了。何非去警察局报案，结果第二天，他的床上莫名空降了个陌生女人。陌生女人说，她就是李木子，并且还拿出了照片作为证据。但，即使看到了所谓的证据，何非也还是不相信陌生女人。真正的李木子不见了踪影，成为了“消失的她”。随着剧情的发展，一张精心设置好的大局慢慢展开，凶手的身份逐渐明显起来。</p></li><li><p>作为一部悬疑片电影，和爱情扯上关系显然有点不合适，其实在电影放到一半时，也就是赌徒出现的时候，大概率就已经猜到了凶手正是丈夫何非。可是在看完电影后，内心却很难平静，倒不是因为剧情带来的震撼，相反，剧情给我的感觉和国外的悬疑电影很像，有反转但不多，细想也都合乎情理（至少符合角色的身份）。带给我震撼的其实是何非这个角色的设定，从最初的寻妻心切的“好丈夫”，到“亡命奔走”的赌徒，这才是人性的多面性所在，也是电影中最具阴暗面的地方。</p><hr></li></ul><h3 id="2.%E4%BA%AE%E7%82%B9%E5%88%86%E6%9E%90" tabindex="-1">2.亮点分析</h3><blockquote><ol><li>何非的回忆</li></ol></blockquote><ul><li>在电影中，可以很清楚地看到何非的回忆录，按照他的描述，他和李木子二人很恩爱，从第一段在潜水馆中救下险些溺水得李木子，到一起聊艺术，去看梵高的《星空》，再到车祸发生，出现了何非的表白“我会一辈子在你身边保护你”。回忆至此，故事画面充满了幸福和甜蜜，可是，从遇见到恋爱到结婚，这一切都是如此顺利，仿佛暗中已经挖好了陷阱，等待李木子的到来…</li><li>电影开始并未介绍何非的职业和爱好，留给观众的只有一个寻妻的丈夫形象，作为婚姻的一方，倘若二者发自内心深爱，妻子的失踪必然会引起丈夫的心急。何非确实这样做了，也正如他回忆录中所描述的一般，最初看电影的时候也是这样想的。但是随着后续剧情的进展，出现假李木子之后，何非的关注重心仿佛从真李木子身上转移，当前的首要目标是“除去假李木子”，为什么着急立案？为什么害怕假妻子的出现？为什么当问及李木子的时候总是会开始回忆过去的美好点滴，对妻子的失踪避而不谈，在整部电影中，何非的回忆是串联起这一切的关键线索，为后续的反转一步步埋下伏笔。</li></ul><blockquote><ol start="2"><li>陈麦（沈曼）的出现</li></ol></blockquote><ul><li>李木子最好的闺蜜是沈曼，在木子失踪后，沈曼本应该第一时间出现，但是站在何非的角度却从未出现过？所以，最初金牌律师陈麦的出现，明显就有暗示。剧中也有大量相关的片段镜头，诸如李木子和陈麦泡茶时都喜欢放柠檬，杯子底下的‘M’标记和表演箱上的M呼应，是否暗示着一切都是设好的局？</li><li>其次，在假李木子出现的时候，何非的眼神并不是害怕，感觉更多地是一种慌张。他以为这是曼曼的安排（曼曼本身对他就有偏见），所以才在一步步布局当中找到所谓的金牌律师陈麦，想着将假妻子的事情弄下去，自己好快速立案得到凭证。沈曼也是利用了赌徒的心理暗示，不愿相信任何人，除非可以对其利益实现最大化的特征，将何非圈在自己设定的陷阱当中。</li></ul><blockquote><ol start="3"><li>潜水和沙滩</li></ol></blockquote><ul><li><p>在本部电影中，令我感触最深的就是所谓的“海底星空”和阳光轻掠过的沙滩。电影中这两处场景的色调截然相反，代表着何非和李木子二人的性格特征和心理变化历程。</p><ul><li><p>何非对应的是海底的幽暗和未知，在其深潜馆中的上浮，我感觉更像一种自我的安慰救赎，而不是对生命的尊重和渴望，以至于后来到海底的“星空”，更像是一种未知的牢笼，将所谓的爱情和欲望深深锁在海底，不见光明，令人感受到郁闷和压抑。</p></li><li><p>李木子则是在温暖的海滩下留下了背影，将何非的脸照亮，更多是一种类似于乌托邦的幻想和对爱情的向往，这种渴望不是物欲的追求，相反，是明知物欲横流，却仍然想将爱留在彼此心间。所以这里的阳光和沙滩代表着爱情和爱人的简单纯粹，不带杂念，将彼此存储于世间温暖的阳光里。</p></li></ul><hr></li></ul><h3 id="3.-%E8%A7%82%E5%BD%B1%E6%84%9F%E6%82%9F" tabindex="-1">3. 观影感悟</h3><ol><li>相信世间仍然存在爱情，但是在爱中不要忽视人性中的恶与贪，切勿将个人的欲念强加于双方，甚至混融在婚姻生活中。<ul><li>爱情和婚姻仍然是两码事，学会了爱人，但是不一定学会了长久得爱人和生活，一旦对物欲得渴望超过了两人之间的能力匹配关系，那必然会导致婚姻的失衡，甚至走向破灭。</li></ul></li><li>“让你看到海底星空，但却将你置于黑暗的牢笼。”人性的恶如果被激活、放大了，那就无所谓对与错了，因为恶本身就是二者权衡的产物，只要有了开端和征兆，就会被无限放大直至坠落。<ul><li>就如影片中的何非好赌，从他开始押下赌注的时候，内心的恶被激活，他所做的一切是为了自己服务，在他眼中是正确的、合理的，可是在外人眼中确实错误的、疯狂的，以至于最后那婚姻作为最大的赌注。</li></ul></li><li>最后说一些恋爱相关的话题，虽然我是牡丹，但是目前和未来希望可以获得一段健康、积极的恋爱关系，双方不是彼此的附属品，更不是因为物质匹配来的恋爱。<ul><li>影片中的‘李木子’，说实话有些恋爱脑，也就是在爱情、婚姻中始终扮演着弱势的一方，渴望得到陪伴与爱，但是前提是需要对方的同意，把个人的想法寄托在他人身上，是不明智的。</li><li>我觉得，一段积极健康的恋爱关系，双方应该是彼此的肩膀，而非靠山，也就是生活里需要你的安慰和鼓励，并不是直接的索取和丢弃，我可以成为你的“消息中转站”，为你暂时排忧解难、分享与分担，等到心情变好的时候再将“消息”归还，由你自己处理；而不是你的“垃圾桶”，将所有不好归咎到对方，将负面消息发送给对方就置之不理。</li><li>希望在未来可以遇到合适的人吧。虽然看完电影后劲有点大，但是对于爱情，依然保持憧憬和向往~~</li></ul></li></ol><p><span style="color:lightblue;font-size:2em;">End~</span></p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 55：跳跃游戏</title>
      <link href="/2023/07/08/leetcode-55-tiao-yue-you-xi/"/>
      <url>/2023/07/08/leetcode-55-tiao-yue-you-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-55%EF%BC%9A%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89" tabindex="-1">Leetcode 55：跳跃游戏（贪心）</h3><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><ul><li><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。 <strong>判断你是否能够到达最后一个下标</strong></p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><hr><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><ul><li><strong>分析：</strong></li><li><ul><li>本题的关键是对于每一步的把控，例如当处于<code>nums[0]</code>时，此时的值为<code>2</code>，也就是可以跳跃一步或者两步，这样下去对应数组中的每个数字都可以由不同的<code>跳跃方法</code>。</li><li><strong>但是我们要注意：每个位置跳多少步不是关键，而是最后的跳跃范围是否可以覆盖到最后一个数（也就是终点）</strong> 那么我们可以尝试每次移动取最大的跳跃步数（目的是得到最大的范围），依次更新覆盖的范围。</li><li><strong>本题的贪心算法的关键是：<mark>局部最优解</mark>，每次取最大的跳跃步数（取最大的覆盖范围）；<mark>整体最优解：</mark> 最后得到整体的最大覆盖范围，看看能否到达最后一个数（终点）</strong></li></ul></li></ul><hr><ul><li><p><strong>代码：</strong></p></li><li><pre class="line-numbers language-language-Java"><code class="language-language-Java">class Solution{    public boolean canJump(int[] nums){        if(nums.length==1){            return true;//特例：第一个数字自己就是终点        }        //开始覆盖范围        int cover=nums[0];//初始值        //在第一个数的覆盖范围内继续不断地更新最大覆盖范围        for(int i=0;i<=cover;i++){        //这里之所以可以取等，因为我们要求的相当于是每个位置的数值，那当然可以取等，如nums[0]==3,那么我们可以跳跃三次到nums[3],再更新最大范围;    cover=Math.max(cover,i+nums[i]);//当前的编号，加上可跳跃的数值，即为范围        if(cover>=nums.length-1){//覆盖范围可以到达最后一个数字的下标（终点）            return true;        }          }        return false;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h3 id="3.-%E6%80%BB%E7%BB%93" tabindex="-1">3. 总结</h3><ul><li><p>**时间复杂度考虑最坏的情况，如果全部元素都是1，那么循环需要n-1次，时间复杂度为：O(n); **</p></li><li><p><strong>空间复杂度：由于只引入了若干变量，未占用内存存储空间：O(1)</strong></p></li></ul><blockquote><p><span style="color:red;font-weight:3em;font-size:2em">继续努力</span></p></blockquote><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双周赛100 T1：把钱分给最多的儿童</title>
      <link href="/2023/07/07/shuang-zhou-sai-100-t1-ba-qian-fen-gei-zui-duo-de-er-tong/"/>
      <url>/2023/07/07/shuang-zhou-sai-100-t1-ba-qian-fen-gei-zui-duo-de-er-tong/</url>
      
        <content type="html"><![CDATA[<h3 id="%E5%8F%8C%E5%91%A8%E8%B5%9B100t1%EF%BC%9A%E5%B0%86%E9%92%B1%E5%88%86%E7%BB%99%E6%9C%80%E5%A4%9A%E7%9A%84%E5%84%BF%E7%AB%A5" tabindex="-1">双周赛100T1：将钱分给最多的儿童</h3><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><p>​给你一个整数 <code>money</code> ，表示你总共有的钱数（单位为美元）和另一个整数 <code>children</code> ，表示你要将钱分配给多少个儿童。</p><p>​你需要按照如下规则分配：</p><ul><li><p>所有的钱都必须被分配。</p></li><li><p>每个儿童至少获得 <code>1</code> 美元。</p></li><li><p>没有人获得 <code>4</code> 美元。</p><p>请你按照上述规则分配金钱，并返回 <strong>最多</strong> 有多少个儿童获得 <strong>恰好</strong> <code>8</code> 美元。如果没有任何分配方案，返回 <code>-1</code>.</p></li></ul><hr><ul><li><p><strong>示例</strong>：</p></li><li><pre><code>输入：money = 20, children = 3输出：1解释：最多获得 8 美元的儿童数为 1 。一种分配方案为：- 给第一个儿童分配 8 美元。- 给第二个儿童分配 9 美元。- 给第三个儿童分配 3 美元。没有分配方案能让获得 8 美元的儿童数超过 1 。</code></pre></li></ul><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><ul><li><strong>分析：</strong></li><li><ul><li>最开始一以为这类题目都是直接模拟来做，但是发现限定条件有点多，主要是不好分类。这里<code>条件2:每个儿童至少获得1美元</code>，这里需要保证的是儿童分到的钱不为<code>0</code>，至少为<code>1</code>。<mark>换句话说就是先给每个儿童分配1美元</mark>  //对应的是：money-children。此时如果money&lt;0，那么直接返回-1。</li><li>然后<code>目的：返回获得8美元的儿童的最大数量</code>，此时条件改为每个获得<code>7</code>美元的儿童最大个数，我们将此时的money / 7 ，让尽可能多的儿童分到<code>7</code>美元，并向下取整，并且需要同当前的儿童的个数进行对比，不能够超过儿童实际人数，返回的是<code>ans=Math.min(money/7,children);</code>并且此时的<code>money-=ans*7;//最后的钱数</code>,<code>children-=ans;//剩余的未分配的儿童人数</code>。</li><li>此时开始判定<code>条件1和条件3：每个人都必须分配，没有儿童分到了4美元</code>。<ul><li><ol><li>如果此时剩余<code>0</code>人，也就是全部儿童都分完了（钱数都是<code>8</code>）,如果money&gt;0,说明还需要再分给一个儿童，也就是<code>ans-1</code>,有一个儿童不是8。</li></ol></li><li><ol start="2"><li>如果此时剩余1人（此时此人的钱数是<code>1</code>），且<code>money=3</code>,为了避免分配<code>4</code>美元，需要的是将此时的<code>3</code>分配给一个分到<code>8</code>的儿童，此时<code>ans-1</code>;</li></ol></li><li><ol start="3"><li>其余情况全部给一个人，如果这个人分配到<code>4</code>美元，那么它可以继续分给其他人，<code>ans</code>的总数保持不变。(<strong>也就是剩余money的值无非是mod7的正整数剩余系，4，5；6就进一位了，人数向下取整的时候要+1;对应的人数也是如此，剩余2、3…人数越多越可以分配剩余钱数不到4美元</strong>)。</li></ol></li></ul></li></ul></li></ul><hr><h3 id="3.-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" tabindex="-1">3. 具体代码</h3><ul><li><p><strong>代码</strong>：</p></li><li><pre class="line-numbers language-language-Java"><code class="language-language-Java">class Solution{    public int distMoney(int money,int children){        money-=chilrdren;//最开始的每个人初始值要为1        if(money<0) return -1;//不满足每个儿童获得钱数至少为1的条件，返回-1、        int ans=Math.min(money/7,children);        money-=ans*7;        children-=ans;        if(children==0 && money>0          ||children==1 && money==3){            ans--;        }        return ans;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>总结：</strong> <strong>时间复杂度为O(1),未用到循环遍历</strong>；<strong>空间复杂度为：O(1)，仅使用了若干额外的变量。</strong></p></li></ul><hr><p><span style="color:lightblue;font-size:30px;">END~</span></p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/07/07/shuang-zhou-sai-100-t1-ba-qian-fen-gei-zui-duo-de-er-tong/2.jpg" alt="2" style="zoom:80%;"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Offer26：重排链表</title>
      <link href="/2023/07/07/offer26-chong-pai-lian-biao/"/>
      <url>/2023/07/07/offer26-chong-pai-lian-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="offer26%EF%BC%9A%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8" tabindex="-1">Offer26：重排链表</h3><hr><h3 id="1.-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" tabindex="-1">1. 题目描述</h3><ul><li><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><p><code>L0 → L1 → … → Ln-1 → Ln</code><br>请将其重新排列后变为：</p><pre class="line-numbers language-none"><code class="language-none">L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例 1:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入: head = [1,2,3,4]输出: [1,4,2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr></li></ul><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><ul><li><p><strong>分析：</strong> 这题不难发现，最后需要输出的链表其实是<code>前半部分</code>和<code>后半部分的翻转</code>,接着再头连着头，依次进行排序输出。</p><ul><li>所以最原始的方法是需要3个不同的函数功能。<ol><li><code>reorderList()</code>函数：主函数，用于均分两半链表，并将它们进行操作。</li><li>``reverse()`函数：翻转后半部分的链表。</li><li><code>link()</code>函数：用于连接前半部分链表、后半部分链表。</li></ol></li></ul><hr></li><li><p><strong>代码：</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution{    public void recorderList(ListNode head){        ListNode dummy=new ListNode(0);        dummy.next=head;//哨兵        ListNode fast=dummy;//快指针        ListNode slow=dummy;//慢指针       while(fast!=null &amp;&amp; fast.next!=null){           slow=slow.next;           fast=fast.next.next;       }                ListNode temp=slow.next;//中间节点的指针暂定为temp        slow.next=null;//准备连接，slow.next为空了        link(head,reverse(temp),dummy);//开始连接    }    private ListNode reverse(ListNode head){//反转链表，注意指针的指向位置        ListNode prev=null;        ListNode cur=head;        while(cur!=null){            ListNode next=cur.next;            cur.next=prev;            prev=cur;            cur=next;        }        return prev;    }    private void link(ListNode node1,ListNode node2,ListNode head){//借助原链表的头结点head（在本题函数中指的是哨兵节点dummy）,按照题目要求连接前后两部分，新链表的头节点为prev        ListNode prev=head;        while(node1!=null &amp;&amp; node2!=null){            ListNode temp=node1.next;//当前node1节点的下一个位置为temp                       prev.next=node1;//prev指针指向node1部分第一个节点            node1.next=node2;//node1后面连的是反转后node2的第一个            prev=node2;//prev开始下一次连接                        node1=temp;//node1后移            node2=node2.next;//node2后移        }        if(node1!=null){            prev.next=node1;//这一个if是用来判断前半部分链表必须比后半部分多，当node1无法匹配连接node2时，直接连接返回node1的节点值。        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr></li></ul><h3 id="3.-%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93" tabindex="-1">3. 思考总结</h3><ul><li><p><strong>思考：</strong> 其实代码不用写三个函数，用在一个函数内部即可，不需要来回调用，实现<code>折半翻转再重连</code>即可。代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution {    public void reorderList(ListNode head) {        ListNode f = head, s = head;        while (f.next != null &amp;&amp; f.next.next != null) {            s = s.next;//慢指针找到中间的节点            f = f.next.next;//快指针直接到末尾节点        }        ListNode t = s.next;//暂存的t节点是慢指针的下一位        f=null;//快指针此时位于最后一个节点，赋值为空        while (t != null) {//翻转            t = s.next;            s.next = f;            f = s;            s = t;        }        s = head;//这里是将后半部分翻转。此时快指针指向原链表的最后一位元素        while (s != null) {//再重新进行连接            t = s.next;//保留当前位置的下一位            s.next = f;//后半部分的最后一位            s = f;            f = t;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>END</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2023/07/07/offer26-chong-pai-lian-biao/1.jpg" alt="1"></p></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指Offer（专项） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 1.两数之和</title>
      <link href="/2023/07/07/leetcode-1-liang-shu-zhi-he/"/>
      <url>/2023/07/07/leetcode-1-liang-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C" tabindex="-1">Leetcode 1.两数之和</h3><h3 id="1.-%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E" tabindex="-1">1. 题目说明</h3><ul><li><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><hr><h3 id="2.-%E8%A7%A3%E7%AD%94%E5%88%86%E6%9E%90" tabindex="-1">2. 解答分析</h3><ul><li><p>本题有好多种解法，这里选择两种常见的解法，一种是直接上循环，不断遍历数组；另外一种是利用哈希表，返回对应表的下标（利用<code>key</code> 和<code>value</code>）</p><ul><li><h5 id="%E6%96%B9%E6%B3%951%EF%BC%9A%E5%88%A9%E7%94%A8%E9%81%8D%E5%8E%86%E6%A8%A1%E6%8B%9F" tabindex="-1"><strong>方法1：利用遍历模拟</strong></h5><ul><li>本题要求的是返回两个数字和为<code>target</code>的数组元素的下标，这里可以直接交换遍历，比如最简单的for循环，我们会把两个指针所指向的值之和，依次比较，最后返回数组元素的下标（构建新的数组）</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution{    public int[] twoSum(int []nums,int target){        int j=1;        int i=0;        int maxLen=nums.length-1;        while(nums[i]+nums[j]!=target){            if(j==maxLen)}{            i++;            j=i;        }        j++:        }    return new int[]{i,j};    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>时间复杂度：O(n<sup>2</sup>)</strong>,一个是i，另外一个是j的循环遍历，至少需要**n(n-1)**的步骤；<strong>空间复杂度为O(1)</strong></li></ul><hr></li><li><h5 id="%E6%96%B9%E6%B3%952%EF%BC%9Ahash%E8%A1%A8" tabindex="-1"><strong>方法2：Hash表</strong></h5><ul><li>Hash表是一种数据结构关系，利用==键(key)<mark>和</mark>值(value)==的<code>一一对应</code>的关系，生成map。map目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）</li><li>在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素</li><li>本题的map我们这样定义：<code>key</code>为数组中的num[i]值，对应的<code>value</code>为 ：下标元素i；</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution{    public int[] twoSum(int[] nums,int target){        int[]res=new int[2];//首先生成最后需要返回的数组，保存的是数组的元素下标        if(nums==null || nums.length==0){            return res;//考虑特例        }        Map&lt;Integer,Integer&gt;map=new HashMap&lt;&gt;();//建立HashMap        for(int i=0;i&lt;nums.length;i++){            int temp=target-nums[i];//从第i个元素开始，看看当前的元素数组中是否存在可以满足条件的值            if(map.containsKey(temp)){                res[1]=i;                res[0]=map.get(temp);//这里的get返回的是满足条件的temp数组元素的下标，注意我们定义Value是数组元素的下标，对应的Key是数组元素的值                break;//跳出循环            }            map.put(nums[i],i);//如果没有找到匹配的对，对于大的循环而言，只需要在HashMap中添加对应的nums值和下标即可，为后续的元素查找匹配提供map数据资源。        }        return res;//返回需要的元素数组下标的新数组    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>时间复杂度：O(n)</strong>，利用HashMap的数据结构大大提高了查找的效率，就相当于是额外开辟内存空间进行数组元素的值、下标的匹配关系映射，通过牺牲空间复杂度换取时间、效率的提高，<strong>空间复杂度为：O(n),（相当于为每个元素都开辟了n-1的空间）。</strong></li></ul></li></ul></li></ul><hr><h3 id="3.%E6%80%BB%E7%BB%93" tabindex="-1">3.总结</h3><p>​这道题很经典，其实还有很多其他的解法，这里由于篇幅就不一一介绍了。对于不同的数据结构和算法而言，我们实现的目标、途径都是不同，同样，时间和空间的各自复杂度的考虑也存在差异，多加练习，多多增加对于每道题目的不同思考方式，继续加油！</p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode刷题 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>First_In</title>
      <link href="/2023/07/05/first-in/"/>
      <url>/2023/07/05/first-in/</url>
      
        <content type="html"><![CDATA[<h3 id="test" tabindex="-1">Test</h3><ol><li>第一篇博客简单测试实现的功能，后续会继续优化网页的显示</li><li>得抓紧时间学习新知识，争取找点找到实习工作</li><li>一切都拼尽全力，一切都顺其自然，让自己快乐快乐这才叫做意义</li></ol><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/05/hello-world/"/>
      <url>/2023/07/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start" tabindex="-1">Quick Start</h2><h3 id="create-a-new-post" tabindex="-1">Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server" tabindex="-1">Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files" tabindex="-1">Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites" tabindex="-1">Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
